/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap.native/dist/bootstrap-native-v4 */ \"./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\");\n/* harmony import */ var bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _bootstrap_popper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bootstrap_popper.js */ \"./assets/js/bootstrap_popper.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _toast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toast.js */ \"./assets/js/toast.js\");\n/* harmony import */ var _form_submit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./form_submit.js */ \"./assets/js/form_submit.js\");\n/* harmony import */ var _form_upload_progress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./form_upload_progress.js */ \"./assets/js/form_upload_progress.js\");\n/* harmony import */ var _modal_close_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modal_close.js */ \"./assets/js/modal_close.js\");\n/* harmony import */ var _clipboard_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./clipboard.js */ \"./assets/js/clipboard.js\");\n\n\n\n\n\n\n\n\n\n// configure htmx\n(htmx_org__WEBPACK_IMPORTED_MODULE_2___default().config.defaultFocusScroll) = true;\nhtmx_org__WEBPACK_IMPORTED_MODULE_2___default().onLoad(function (rootEl) {\n  bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_0___default().initCallback(rootEl);\n  (0,_bootstrap_popper_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rootEl);\n  (0,_toast_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(rootEl);\n  (0,_form_submit_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(rootEl);\n  (0,_form_upload_progress_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(rootEl);\n  (0,_modal_close_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(rootEl);\n  (0,_clipboard_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(rootEl);\n});\nwindow.htmx = (htmx_org__WEBPACK_IMPORTED_MODULE_2___default());\ndocument.body.addEventListener('htmx:configRequest', function (evt) {\n  evt.detail.headers['X-CSRF-Token'] = document.querySelector('meta[name=\"csrf_token\"]').content;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTREO0FBQ1Q7QUFDeEI7QUFDRztBQUNXO0FBQ2lCO0FBQ2pCO0FBQ0g7O0FBRXRDO0FBQ0FFLDJFQUE4QixHQUFHLElBQUk7QUFDckNBLHNEQUFXLENBQUMsVUFBU1MsTUFBTSxFQUFFO0VBQ3pCWCw2RkFBZ0IsQ0FBQ1csTUFBTSxDQUFDO0VBQ3hCVixnRUFBZSxDQUFDVSxNQUFNLENBQUM7RUFDdkJSLHFEQUFLLENBQUNRLE1BQU0sQ0FBQztFQUNiUCwyREFBVSxDQUFDTyxNQUFNLENBQUM7RUFDbEJOLG9FQUFrQixDQUFDTSxNQUFNLENBQUM7RUFDMUJMLDJEQUFVLENBQUNLLE1BQU0sQ0FBQztFQUNsQkoseURBQVMsQ0FBQ0ksTUFBTSxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGRSxNQUFNLENBQUNYLElBQUksR0FBR0EsaURBQUk7QUFFbEJZLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsRUFBRSxVQUFDQyxHQUFHLEVBQUs7RUFDMURBLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUMsY0FBYyxDQUFDLEdBQUdMLFFBQVEsQ0FBQ00sYUFBYSxDQUFDLHlCQUF5QixDQUFDLENBQUNDLE9BQU87QUFDbEcsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FwcC5qcz8yNWZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCU04gZnJvbSAnYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQnO1xuaW1wb3J0IGJvb3RzdHJhcFBvcHBlciBmcm9tICcuL2Jvb3RzdHJhcF9wb3BwZXIuanMnXG5pbXBvcnQgaHRteCBmcm9tICdodG14Lm9yZydcbmltcG9ydCB0b2FzdCBmcm9tICcuL3RvYXN0LmpzJ1xuaW1wb3J0IGZvcm1TdWJtaXQgZnJvbSAnLi9mb3JtX3N1Ym1pdC5qcydcbmltcG9ydCBmb3JtVXBsb2FkUHJvZ3Jlc3MgZnJvbSAnLi9mb3JtX3VwbG9hZF9wcm9ncmVzcy5qcydcbmltcG9ydCBtb2RhbENsb3NlIGZyb20gJy4vbW9kYWxfY2xvc2UuanMnXG5pbXBvcnQgY2xpcGJvYXJkIGZyb20gJy4vY2xpcGJvYXJkLmpzJ1xuXG4vLyBjb25maWd1cmUgaHRteFxuaHRteC5jb25maWcuZGVmYXVsdEZvY3VzU2Nyb2xsID0gdHJ1ZVxuaHRteC5vbkxvYWQoZnVuY3Rpb24ocm9vdEVsKSB7XG4gICAgQlNOLmluaXRDYWxsYmFjayhyb290RWwpXG4gICAgYm9vdHN0cmFwUG9wcGVyKHJvb3RFbClcbiAgICB0b2FzdChyb290RWwpXG4gICAgZm9ybVN1Ym1pdChyb290RWwpXG4gICAgZm9ybVVwbG9hZFByb2dyZXNzKHJvb3RFbClcbiAgICBtb2RhbENsb3NlKHJvb3RFbClcbiAgICBjbGlwYm9hcmQocm9vdEVsKVxufSk7XG5cbndpbmRvdy5odG14ID0gaHRteFxuXG5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2h0bXg6Y29uZmlnUmVxdWVzdCcsIChldnQpID0+IHtcbiAgICBldnQuZGV0YWlsLmhlYWRlcnNbJ1gtQ1NSRi1Ub2tlbiddID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZl90b2tlblwiXScpLmNvbnRlbnRcbn0pXG4iXSwibmFtZXMiOlsiQlNOIiwiYm9vdHN0cmFwUG9wcGVyIiwiaHRteCIsInRvYXN0IiwiZm9ybVN1Ym1pdCIsImZvcm1VcGxvYWRQcm9ncmVzcyIsIm1vZGFsQ2xvc2UiLCJjbGlwYm9hcmQiLCJjb25maWciLCJkZWZhdWx0Rm9jdXNTY3JvbGwiLCJvbkxvYWQiLCJyb290RWwiLCJpbml0Q2FsbGJhY2siLCJ3aW5kb3ciLCJkb2N1bWVudCIsImJvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZ0IiwiZGV0YWlsIiwiaGVhZGVycyIsInF1ZXJ5U2VsZWN0b3IiLCJjb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/app.js\n");

/***/ }),

/***/ "./assets/js/bootstrap_popper.js":
/*!***************************************!*\
  !*** ./assets/js/bootstrap_popper.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\");\n\n\n// Wire in popper.js support. This ensure popups stays within the viewport.\n// See: https://github.com/thednp/bootstrap.native/issues/211\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rootEl) {\n  rootEl.querySelectorAll(\"div.dropdown > button\").forEach(function (button) {\n    button.addEventListener(\"click\", function (evt) {\n      var menu = button.parentElement.children.item(1);\n      if (menu.classList.contains(\"show\")) {\n        menu.removeAttribute(\"x-placement\");\n        menu.removeAttribute(\"style\");\n        var popper = new popper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](button, menu, {\n          modifiers: {\n            preventOverflow: {\n              enabled: true\n            },\n            flip: {\n              enabled: true\n            },\n            hide: {\n              enabled: false\n            }\n          }\n        });\n      }\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvYm9vdHN0cmFwX3BvcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLDZCQUFlLG9DQUFTQyxNQUFNLEVBQUU7RUFDNUJBLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsdUJBQXVCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVNDLE1BQU0sRUFBRTtJQUN0RUEsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBU0MsR0FBRyxFQUFFO01BQzNDLElBQUlDLElBQUksR0FBR0gsTUFBTSxDQUFDSSxhQUFhLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FBQztNQUVoRCxJQUFJSCxJQUFJLENBQUNJLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ2pDTCxJQUFJLENBQUNNLGVBQWUsQ0FBQyxhQUFhLENBQUM7UUFDbkNOLElBQUksQ0FBQ00sZUFBZSxDQUFDLE9BQU8sQ0FBQztRQUU3QixJQUFJQyxNQUFNLEdBQUcsSUFBSWQsaURBQU0sQ0FBQ0ksTUFBTSxFQUFFRyxJQUFJLEVBQUU7VUFDbENRLFNBQVMsRUFBRTtZQUNQQyxlQUFlLEVBQUU7Y0FBRUMsT0FBTyxFQUFFO1lBQUssQ0FBQztZQUNsQ0MsSUFBSSxFQUFFO2NBQUVELE9BQU8sRUFBRTtZQUFJLENBQUM7WUFDdEJFLElBQUksRUFBRTtjQUFFRixPQUFPLEVBQUU7WUFBSztVQUMxQjtRQUNKLENBQUMsQ0FBQztNQUNOO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYm9vdHN0cmFwX3BvcHBlci5qcz81ODUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuXG4vLyBXaXJlIGluIHBvcHBlci5qcyBzdXBwb3J0LiBUaGlzIGVuc3VyZSBwb3B1cHMgc3RheXMgd2l0aGluIHRoZSB2aWV3cG9ydC5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2lzc3Vlcy8yMTFcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJvb3RFbCkge1xuICAgIHJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKFwiZGl2LmRyb3Bkb3duID4gYnV0dG9uXCIpLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBsZXQgbWVudSA9IGJ1dHRvbi5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLml0ZW0oMSk7XG5cbiAgICAgICAgICAgIGlmIChtZW51LmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIikpIHtcbiAgICAgICAgICAgICAgICBtZW51LnJlbW92ZUF0dHJpYnV0ZShcIngtcGxhY2VtZW50XCIpO1xuICAgICAgICAgICAgICAgIG1lbnUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgcG9wcGVyID0gbmV3IFBvcHBlcihidXR0b24sIG1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpcDogeyBlbmFibGVkOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IHsgZW5hYmxlZDogZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KTtcbn0iXSwibmFtZXMiOlsiUG9wcGVyIiwicm9vdEVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJidXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwiZXZ0IiwibWVudSIsInBhcmVudEVsZW1lbnQiLCJjaGlsZHJlbiIsIml0ZW0iLCJjbGFzc0xpc3QiLCJjb250YWlucyIsInJlbW92ZUF0dHJpYnV0ZSIsInBvcHBlciIsIm1vZGlmaWVycyIsInByZXZlbnRPdmVyZmxvdyIsImVuYWJsZWQiLCJmbGlwIiwiaGlkZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/bootstrap_popper.js\n");

/***/ }),

/***/ "./assets/js/clipboard.js":
/*!********************************!*\
  !*** ./assets/js/clipboard.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var restoreTimeout = 1500;\n  var evtHandler = function evtHandler(evt) {\n    var value = this.dataset.value;\n    var btn = this;\n    navigator.clipboard.writeText(value).then(function () {\n      btn.classList.remove(\"btn-outline-secondary\");\n      btn.classList.add(\"btn-outline-success\");\n      var icon = btn.querySelector(\"i\");\n      icon.classList.remove(\"if-copy\", \"text-primary\");\n      icon.classList.add(\"if-check\", \"text-success\");\n      var span = btn.querySelector(\"span\");\n      if (span) {\n        span.classList.remove(\"text-primary\");\n        span.classList.add(\"text-success\");\n        span.setAttribute(\"aria-live\", \"polite\");\n        span.innerText = \"Link copied\";\n      }\n      setTimeout(function () {\n        icon.classList.remove(\"if-check\", \"text-success\");\n        icon.classList.add(\"if-copy\", \"text-primary\");\n        if (span) {\n          span.classList.remove(\"text-success\");\n          span.classList.add(\"text-primary\");\n          span.innerText = \"Copy link\";\n        }\n        btn.classList.remove(\"btn-outline-success\");\n        btn.classList.add(\"btn-outline-secondary\");\n      }, restoreTimeout);\n    });\n  };\n  document.querySelectorAll(\".btn-copy-to-clipboard\").forEach(function (btn) {\n    btn.addEventListener(\"click\", evtHandler);\n  });\n  document.querySelectorAll(\".input-select-text\").forEach(function (el) {\n    el.addEventListener(\"click\", function (evt) {\n      this.select();\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvY2xpcGJvYXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2QkFBZSxzQ0FBWTtFQUV6QixJQUFNQSxjQUFjLEdBQUcsSUFBSTtFQUUzQixJQUFJQyxVQUFVLEdBQUcsU0FBYkEsVUFBVSxDQUFZQyxHQUFHLEVBQUM7SUFDNUIsSUFBSUMsS0FBSyxHQUFHLElBQUksQ0FBQ0MsT0FBTyxDQUFDRCxLQUFLO0lBQzlCLElBQUlFLEdBQUcsR0FBRyxJQUFJO0lBRWRDLFNBQVMsQ0FBQ0MsU0FBUyxDQUFDQyxTQUFTLENBQUNMLEtBQUssQ0FBQyxDQUFDTSxJQUFJLENBQUMsWUFBVztNQUNuREosR0FBRyxDQUFDSyxTQUFTLENBQUNDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQztNQUM3Q04sR0FBRyxDQUFDSyxTQUFTLENBQUNFLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQztNQUV4QyxJQUFJQyxJQUFJLEdBQUdSLEdBQUcsQ0FBQ1MsYUFBYSxDQUFDLEdBQUcsQ0FBQztNQUNqQ0QsSUFBSSxDQUFDSCxTQUFTLENBQUNDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDO01BQ2hERSxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLFVBQVUsRUFBRSxjQUFjLENBQUM7TUFFOUMsSUFBSUcsSUFBSSxHQUFHVixHQUFHLENBQUNTLGFBQWEsQ0FBQyxNQUFNLENBQUM7TUFDcEMsSUFBSUMsSUFBSSxFQUFFO1FBQ1JBLElBQUksQ0FBQ0wsU0FBUyxDQUFDQyxNQUFNLENBQUMsY0FBYyxDQUFDO1FBQ3JDSSxJQUFJLENBQUNMLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLGNBQWMsQ0FBQztRQUNsQ0csSUFBSSxDQUFDQyxZQUFZLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQztRQUN4Q0QsSUFBSSxDQUFDRSxTQUFTLEdBQUMsYUFBYTtNQUM5QjtNQUVBQyxVQUFVLENBQUMsWUFBVTtRQUNuQkwsSUFBSSxDQUFDSCxTQUFTLENBQUNDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDO1FBQ2pERSxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUM7UUFFN0MsSUFBSUcsSUFBSSxFQUFFO1VBQ1JBLElBQUksQ0FBQ0wsU0FBUyxDQUFDQyxNQUFNLENBQUMsY0FBYyxDQUFDO1VBQ3JDSSxJQUFJLENBQUNMLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLGNBQWMsQ0FBQztVQUNsQ0csSUFBSSxDQUFDRSxTQUFTLEdBQUMsV0FBVztRQUM1QjtRQUVBWixHQUFHLENBQUNLLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLHFCQUFxQixDQUFDO1FBQzNDTixHQUFHLENBQUNLLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLHVCQUF1QixDQUFDO01BQzVDLENBQUMsRUFBRVosY0FBYyxDQUFDO0lBQ3BCLENBQUMsQ0FBQztFQUNKLENBQUM7RUFFRG1CLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVNoQixHQUFHLEVBQUM7SUFDdkVBLEdBQUcsQ0FBQ2lCLGdCQUFnQixDQUFDLE9BQU8sRUFBRXJCLFVBQVUsQ0FBQztFQUMzQyxDQUFDLENBQUM7RUFFRmtCLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVNFLEVBQUUsRUFBQztJQUNsRUEsRUFBRSxDQUFDRCxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBU3BCLEdBQUcsRUFBRTtNQUN6QyxJQUFJLENBQUNzQixNQUFNLEVBQUU7SUFDZixDQUFDLENBQUM7RUFDSixDQUFDLENBQUM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9qcy9jbGlwYm9hcmQuanM/OTk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cbiAgY29uc3QgcmVzdG9yZVRpbWVvdXQgPSAxNTAwXG5cbiAgbGV0IGV2dEhhbmRsZXIgPSBmdW5jdGlvbihldnQpe1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YXNldC52YWx1ZVxuICAgIGxldCBidG4gPSB0aGlzXG5cbiAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh2YWx1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwiYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIpXG4gICAgICBidG4uY2xhc3NMaXN0LmFkZChcImJ0bi1vdXRsaW5lLXN1Y2Nlc3NcIilcblxuICAgICAgbGV0IGljb24gPSBidG4ucXVlcnlTZWxlY3RvcihcImlcIilcbiAgICAgIGljb24uY2xhc3NMaXN0LnJlbW92ZShcImlmLWNvcHlcIiwgXCJ0ZXh0LXByaW1hcnlcIilcbiAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImlmLWNoZWNrXCIsIFwidGV4dC1zdWNjZXNzXCIpXG5cbiAgICAgIGxldCBzcGFuID0gYnRuLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpXG4gICAgICBpZiAoc3Bhbikge1xuICAgICAgICBzcGFuLmNsYXNzTGlzdC5yZW1vdmUoXCJ0ZXh0LXByaW1hcnlcIilcbiAgICAgICAgc3Bhbi5jbGFzc0xpc3QuYWRkKFwidGV4dC1zdWNjZXNzXCIpXG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpXG4gICAgICAgIHNwYW4uaW5uZXJUZXh0PVwiTGluayBjb3BpZWRcIlxuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGljb24uY2xhc3NMaXN0LnJlbW92ZShcImlmLWNoZWNrXCIsIFwidGV4dC1zdWNjZXNzXCIpXG4gICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImlmLWNvcHlcIiwgXCJ0ZXh0LXByaW1hcnlcIilcblxuICAgICAgICBpZiAoc3Bhbikge1xuICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LnJlbW92ZShcInRleHQtc3VjY2Vzc1wiKVxuICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZChcInRleHQtcHJpbWFyeVwiKVxuICAgICAgICAgIHNwYW4uaW5uZXJUZXh0PVwiQ29weSBsaW5rXCJcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoXCJidG4tb3V0bGluZS1zdWNjZXNzXCIpXG4gICAgICAgIGJ0bi5jbGFzc0xpc3QuYWRkKFwiYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIpXG4gICAgICB9LCByZXN0b3JlVGltZW91dClcbiAgICB9KVxuICB9XG5cbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5idG4tY29weS10by1jbGlwYm9hcmRcIikuZm9yRWFjaChmdW5jdGlvbihidG4pe1xuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZ0SGFuZGxlcilcbiAgfSlcblxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmlucHV0LXNlbGVjdC10ZXh0XCIpLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KClcbiAgICB9KVxuICB9KVxufVxuIl0sIm5hbWVzIjpbInJlc3RvcmVUaW1lb3V0IiwiZXZ0SGFuZGxlciIsImV2dCIsInZhbHVlIiwiZGF0YXNldCIsImJ0biIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsInRoZW4iLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJhZGQiLCJpY29uIiwicXVlcnlTZWxlY3RvciIsInNwYW4iLCJzZXRBdHRyaWJ1dGUiLCJpbm5lclRleHQiLCJzZXRUaW1lb3V0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbCIsInNlbGVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/clipboard.js\n");

/***/ }),

/***/ "./assets/js/form_submit.js":
/*!**********************************!*\
  !*** ./assets/js/form_submit.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rootEl) {\n  rootEl.querySelectorAll(\"[data-submit-target]\").forEach(function (btn) {\n    btn.addEventListener(\"click\", function () {\n      var form = document.querySelector(btn.dataset.submitTarget);\n      form.submit();\n    });\n  });\n  rootEl.querySelectorAll(\"form.change-submit\").forEach(function (form) {\n    form.addEventListener(\"change\", function () {\n      var btn = form.querySelector(\"button[type='submit']\");\n      if (btn !== null) {\n        btn.disabled = true;\n        var loadingText = btn.dataset.loading || \"Loading...\";\n        btn.innerHTML = '<span class=\"spinner-border\" role=\"status\" aria-hidden=\"true\"></span> ' + loadingText;\n      }\n      form.submit();\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvZm9ybV9zdWJtaXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUFlLG9DQUFTQSxNQUFNLEVBQUU7RUFDNUJBLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsc0JBQXNCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQUNDLEdBQUcsRUFBSztJQUM3REEsR0FBRyxDQUFDQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsWUFBTTtNQUNoQyxJQUFJQyxJQUFJLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDSixHQUFHLENBQUNLLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDO01BQzNESixJQUFJLENBQUNLLE1BQU0sRUFBRTtJQUNqQixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7RUFFRlYsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDQyxPQUFPLENBQUMsVUFBQ0csSUFBSSxFQUFLO0lBQzVEQSxJQUFJLENBQUNELGdCQUFnQixDQUFDLFFBQVEsRUFBRSxZQUFNO01BQ2xDLElBQUlELEdBQUcsR0FBR0UsSUFBSSxDQUFDRSxhQUFhLENBQUMsdUJBQXVCLENBQUM7TUFDckQsSUFBSUosR0FBRyxLQUFLLElBQUksRUFBRTtRQUNkQSxHQUFHLENBQUNRLFFBQVEsR0FBRyxJQUFJO1FBQ25CLElBQUlDLFdBQVcsR0FBR1QsR0FBRyxDQUFDSyxPQUFPLENBQUNLLE9BQU8sSUFBSSxZQUFZO1FBQ3JEVixHQUFHLENBQUNXLFNBQVMsR0FBRyx3RUFBd0UsR0FDcEZGLFdBQVc7TUFDbkI7TUFDQVAsSUFBSSxDQUFDSyxNQUFNLEVBQUU7SUFDakIsQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvZm9ybV9zdWJtaXQuanM/NTBmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyb290RWwpIHtcbiAgICByb290RWwucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXN1Ym1pdC10YXJnZXRdXCIpLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihidG4uZGF0YXNldC5zdWJtaXRUYXJnZXQpXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJmb3JtLmNoYW5nZS1zdWJtaXRcIikuZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ0biA9IGZvcm0ucXVlcnlTZWxlY3RvcihcImJ1dHRvblt0eXBlPSdzdWJtaXQnXVwiKVxuICAgICAgICAgICAgaWYgKGJ0biAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJ0bi5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgICAgICAgICBsZXQgbG9hZGluZ1RleHQgPSBidG4uZGF0YXNldC5sb2FkaW5nIHx8IFwiTG9hZGluZy4uLlwiXG4gICAgICAgICAgICAgICAgYnRuLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInNwaW5uZXItYm9yZGVyXCIgcm9sZT1cInN0YXR1c1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4gJyArIFxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nVGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0iXSwibmFtZXMiOlsicm9vdEVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJidG4iLCJhZGRFdmVudExpc3RlbmVyIiwiZm9ybSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImRhdGFzZXQiLCJzdWJtaXRUYXJnZXQiLCJzdWJtaXQiLCJkaXNhYmxlZCIsImxvYWRpbmdUZXh0IiwibG9hZGluZyIsImlubmVySFRNTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/form_submit.js\n");

/***/ }),

/***/ "./assets/js/form_upload_progress.js":
/*!*******************************************!*\
  !*** ./assets/js/form_upload_progress.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rootEl) {\n  rootEl.querySelectorAll('form input[data-upload-progress-target]').forEach(function (input) {\n    input.addEventListener('change', function () {\n      var files = Array.from(input.files);\n      if (!files.length) return;\n      var target = document.getElementById(input.dataset.uploadProgressTarget);\n      var form = input.closest('form');\n      var csrfToken = document.querySelector('meta[name=csrf_token]').content;\n      files.forEach(function (file, i) {\n        var tmpl = document.getElementById('tmpl-upload-progress').content.firstElementChild.cloneNode(true);\n        tmpl.querySelector('.upload-name').innerText = file.name;\n        target.appendChild(tmpl);\n        var hideBtnCancelUpload = function hideBtnCancelUpload() {\n          var b = tmpl.querySelector('.btn-cancel-upload');\n          if (b == null) return;\n          b.parentElement.removeChild(b);\n        };\n        var showBtnRemoveUpload = function showBtnRemoveUpload() {\n          var b = tmpl.querySelector('.btn-remove-upload');\n          if (b == null) return;\n          b.classList.remove('d-none');\n        };\n        tmpl.querySelector('.btn-remove-upload').addEventListener('click', function () {\n          var i = this.closest('.list-group-item');\n          i.parentElement.removeChild(i);\n        });\n        var showMessage = function showMessage(msg, level) {\n          var m = tmpl.querySelector('.upload-msg');\n          var cl = 'text-muted';\n          if (level == 'info') {\n            cl = 'text-muted';\n          } else if (level = 'error') {\n            cl = 'text-danger';\n          }\n          m.classList.remove('text-muted');\n          m.classList.add(cl);\n          m.innerText = msg;\n        };\n        var hlPgBar = function hlPgBar(pgBar, level) {\n          var cl = 'bg-info';\n          if (level == 'warning') {\n            cl = 'bg-warning';\n          } else if (level == 'error') {\n            cl = 'bg-danger';\n          }\n          pgBar.classList.remove('bg-info');\n          pgBar.classList.add(cl);\n        };\n\n        // prevent file upload when above max file size\n        var maxFileSize = input.dataset.uploadMaxFileSize;\n        if (!isNaN(maxFileSize) && file.size > maxFileSize) {\n          hideBtnCancelUpload();\n          showBtnRemoveUpload();\n          showMessage(input.dataset.uploadMsgFileTooLarge, 'error');\n          hlPgBar(tmpl.querySelector('.progress-bar'), 'error');\n          return;\n        }\n\n        // send headers along with request\n        var headers = [['X-CSRF-Token', csrfToken],\n        // weird, but makes sure that middleware does not try to read _method from form\n        ['X-HTTP-Method-Override', 'POST'],\n        //\"Failed to execute 'setRequestHeader' on 'XMLHttpRequest': String contains non ISO-8859-1 code point\"\n        ['X-Upload-Filename', encodeURIComponent(file.name)],\n        //refused by browser\n        //['Content-Length', file.size],\n        ['Content-Type', file.type]];\n        var req = new XMLHttpRequest();\n        req.addEventListener('abort', function (e) {\n          showMessage(input.dataset.uploadMsgFileAborted, 'error');\n          hlPgBar(tmpl.querySelector('.progress-bar'), 'error');\n          hideBtnCancelUpload();\n          showBtnRemoveUpload();\n        }, false);\n        req.upload.addEventListener('progress', function (e) {\n          if (!e.lengthComputable) return;\n          var percent = Math.floor(e.loaded / e.total * 100);\n          tmpl.querySelector('.upload-size').innerText = friendlyBytes(e.loaded);\n          tmpl.querySelector('.upload-percent').innerText = percent;\n          var pb = tmpl.querySelector('.progress-bar');\n          pb.style['width'] = \"\".concat(percent, \"%\");\n          pb.setAttribute('aria-valuenow', percent);\n          if (e.loaded == e.total) {\n            hideBtnCancelUpload();\n            showMessage(input.dataset.uploadMsgFileProcessing, 'info');\n          } else {\n            showMessage(input.dataset.uploadMsgFileUploading, 'info');\n          }\n        }, false);\n        req.addEventListener('readystatechange', function (evt) {\n          if (req.readyState !== 4) return;\n          hideBtnCancelUpload();\n\n          // file created\n          if (req.status == 200 || req.status == 201) {\n            tmpl.parentElement.removeChild(tmpl);\n            var filesBody = document.getElementById('files');\n            filesBody.innerHTML = req.response;\n            // trigger htmx on newly added elements\n            htmx.process(filesBody);\n            htmx.trigger(filesBody, 'htmx:load');\n          }\n\n          /*\n           * file too large. Unfortunately this cannot be detected\n           * anymore at server as the error is wrapped inside others.\n           */else if (req.status == 413) {\n            showBtnRemoveUpload();\n            showMessage(input.dataset.uploadMsgFileTooLarge, 'error');\n            hlPgBar(tmpl.querySelector('.progress-bar'), 'error');\n          }\n          // directory has been removed in the meantime\n          else if (req.status == 404) {\n            showBtnRemoveUpload();\n            showMessage(input.dataset.uploadMsgDirNotFound, 'error');\n            hlPgBar(tmpl.querySelector('.progress-bar'), 'error');\n          }\n          // undetermined errors\n          else {\n            showBtnRemoveUpload();\n            showMessage(input.dataset.uploadMsgUnexpected, 'error');\n            hlPgBar(tmpl.querySelector('.progress-bar'), 'error');\n          }\n        });\n        req.open(form.method, form.action);\n        for (var _i = 0; _i < headers.length; _i++) {\n          req.setRequestHeader(headers[_i][0], headers[_i][1]);\n        }\n        tmpl.querySelector('.btn-cancel-upload').addEventListener('click', function (evt) {\n          evt.preventDefault();\n          req.abort();\n        });\n        req.send(file);\n      });\n\n      // important to retrigger \"change\" when someone enters the same file again\n      input.value = \"\";\n    });\n  });\n}\nvar byteUnits = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'];\nfunction friendlyBytes(n) {\n  if (n < 10) {\n    return n + ' B';\n  }\n  var e = Math.floor(Math.log(n) / Math.log(1000));\n  var unit = byteUnits[e];\n  var val = Math.floor(n / Math.pow(1000, e) * 10 + 0.5) / 10;\n  if (val < 10 && !Number.isInteger(val)) {\n    return val.toFixed(1) + ' ' + unit;\n  }\n  return val.toFixed(0) + ' ' + unit;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQztBQUUzRCxTQUFTekIsYUFBYSxDQUFDMEIsQ0FBQyxFQUFFO0VBQ3RCLElBQUlBLENBQUMsR0FBRyxFQUFFLEVBQUU7SUFDUixPQUFPQSxDQUFDLEdBQUcsSUFBSTtFQUNuQjtFQUNBLElBQUluQyxDQUFDLEdBQUdLLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxJQUFJLENBQUMrQixHQUFHLENBQUNELENBQUMsQ0FBQyxHQUFHOUIsSUFBSSxDQUFDK0IsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ2hELElBQUlDLElBQUksR0FBR0gsU0FBUyxDQUFDbEMsQ0FBQyxDQUFDO0VBQ3ZCLElBQUlzQyxHQUFHLEdBQUlqQyxJQUFJLENBQUNDLEtBQUssQ0FBQzZCLENBQUMsR0FBRzlCLElBQUksQ0FBQ2tDLEdBQUcsQ0FBQyxJQUFJLEVBQUV2QyxDQUFDLENBQUMsR0FBQyxFQUFFLEdBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtFQUN4RCxJQUFJc0MsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDRSxNQUFNLENBQUNDLFNBQVMsQ0FBQ0gsR0FBRyxDQUFDLEVBQUU7SUFDcEMsT0FBT0EsR0FBRyxDQUFDSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHTCxJQUFJO0VBQ3RDO0VBQ0EsT0FBT0MsR0FBRyxDQUFDSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHTCxJQUFJO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2Zvcm1fdXBsb2FkX3Byb2dyZXNzLmpzP2M4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocm9vdEVsKSB7XG4gICAgcm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0gaW5wdXRbZGF0YS11cGxvYWQtcHJvZ3Jlc3MtdGFyZ2V0XScpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGlucHV0LmZpbGVzKVxuXG4gICAgICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXQuZGF0YXNldC51cGxvYWRQcm9ncmVzc1RhcmdldClcbiAgICAgICAgICAgIGxldCBmb3JtID0gaW5wdXQuY2xvc2VzdCgnZm9ybScpXG4gICAgICAgICAgICBsZXQgY3NyZlRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPWNzcmZfdG9rZW5dJykuY29udGVudFxuXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG1wbC11cGxvYWQtcHJvZ3Jlc3MnKS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgICAgICAgIHRtcGwucXVlcnlTZWxlY3RvcignLnVwbG9hZC1uYW1lJykuaW5uZXJUZXh0ID0gZmlsZS5uYW1lXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHRtcGwpXG5cbiAgICAgICAgICAgICAgICBsZXQgaGlkZUJ0bkNhbmNlbFVwbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICBsZXQgYiA9IHRtcGwucXVlcnlTZWxlY3RvcignLmJ0bi1jYW5jZWwtdXBsb2FkJylcbiAgICAgICAgICAgICAgICAgIGlmIChiID09IG51bGwpIHJldHVyblxuICAgICAgICAgICAgICAgICAgYi5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzaG93QnRuUmVtb3ZlVXBsb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIGxldCBiID0gdG1wbC5xdWVyeVNlbGVjdG9yKCcuYnRuLXJlbW92ZS11cGxvYWQnKVxuICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gbnVsbCkgcmV0dXJuXG4gICAgICAgICAgICAgICAgICBiLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtcGwucXVlcnlTZWxlY3RvcignLmJ0bi1yZW1vdmUtdXBsb2FkJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmNsb3Nlc3QoJy5saXN0LWdyb3VwLWl0ZW0nKVxuICAgICAgICAgICAgICAgICAgaS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBsZXQgc2hvd01lc3NhZ2UgPSBmdW5jdGlvbihtc2csIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbSA9IHRtcGwucXVlcnlTZWxlY3RvcignLnVwbG9hZC1tc2cnKVxuICAgICAgICAgICAgICAgICAgbGV0IGNsID0gJ3RleHQtbXV0ZWQnXG4gICAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT0gJ2luZm8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsID0gJ3RleHQtbXV0ZWQnXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYobGV2ZWwgPSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsID0gJ3RleHQtZGFuZ2VyJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbS5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LW11dGVkJylcbiAgICAgICAgICAgICAgICAgIG0uY2xhc3NMaXN0LmFkZChjbClcbiAgICAgICAgICAgICAgICAgIG0uaW5uZXJUZXh0ID0gbXNnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBobFBnQmFyID0gZnVuY3Rpb24ocGdCYXIsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2wgPSAnYmctaW5mbydcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2wgPSAnYmctd2FybmluZydcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihsZXZlbCA9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsID0gJ2JnLWRhbmdlcidcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHBnQmFyLmNsYXNzTGlzdC5yZW1vdmUoJ2JnLWluZm8nKVxuICAgICAgICAgICAgICAgICAgcGdCYXIuY2xhc3NMaXN0LmFkZChjbClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZpbGUgdXBsb2FkIHdoZW4gYWJvdmUgbWF4IGZpbGUgc2l6ZVxuICAgICAgICAgICAgICAgIGxldCBtYXhGaWxlU2l6ZSA9IGlucHV0LmRhdGFzZXQudXBsb2FkTWF4RmlsZVNpemVcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1heEZpbGVTaXplKSAmJiBmaWxlLnNpemUgPiBtYXhGaWxlU2l6ZSkge1xuXG4gICAgICAgICAgICAgICAgICBoaWRlQnRuQ2FuY2VsVXBsb2FkKClcbiAgICAgICAgICAgICAgICAgIHNob3dCdG5SZW1vdmVVcGxvYWQoKVxuICAgICAgICAgICAgICAgICAgc2hvd01lc3NhZ2UoaW5wdXQuZGF0YXNldC51cGxvYWRNc2dGaWxlVG9vTGFyZ2UsICdlcnJvcicpXG4gICAgICAgICAgICAgICAgICBobFBnQmFyKHRtcGwucXVlcnlTZWxlY3RvcignLnByb2dyZXNzLWJhcicpLCAnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZW5kIGhlYWRlcnMgYWxvbmcgd2l0aCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSBbXG4gICAgICAgICAgICAgICAgICBbJ1gtQ1NSRi1Ub2tlbicsIGNzcmZUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAvLyB3ZWlyZCwgYnV0IG1ha2VzIHN1cmUgdGhhdCBtaWRkbGV3YXJlIGRvZXMgbm90IHRyeSB0byByZWFkIF9tZXRob2QgZnJvbSBmb3JtXG4gICAgICAgICAgICAgICAgICBbJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCAnUE9TVCddLFxuICAgICAgICAgICAgICAgICAgLy9cIkZhaWxlZCB0byBleGVjdXRlICdzZXRSZXF1ZXN0SGVhZGVyJyBvbiAnWE1MSHR0cFJlcXVlc3QnOiBTdHJpbmcgY29udGFpbnMgbm9uIElTTy04ODU5LTEgY29kZSBwb2ludFwiXG4gICAgICAgICAgICAgICAgICBbJ1gtVXBsb2FkLUZpbGVuYW1lJywgZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUubmFtZSldLFxuICAgICAgICAgICAgICAgICAgLy9yZWZ1c2VkIGJ5IGJyb3dzZXJcbiAgICAgICAgICAgICAgICAgIC8vWydDb250ZW50LUxlbmd0aCcsIGZpbGUuc2l6ZV0sXG4gICAgICAgICAgICAgICAgICBbJ0NvbnRlbnQtVHlwZScsIGZpbGUudHlwZV1cbiAgICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgICBsZXQgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICAgICAgICByZXEuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlID0+IHtcblxuICAgICAgICAgICAgICAgICAgc2hvd01lc3NhZ2UoaW5wdXQuZGF0YXNldC51cGxvYWRNc2dGaWxlQWJvcnRlZCwgJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgIGhsUGdCYXIodG1wbC5xdWVyeVNlbGVjdG9yKCcucHJvZ3Jlc3MtYmFyJyksICdlcnJvcicpXG4gICAgICAgICAgICAgICAgICBoaWRlQnRuQ2FuY2VsVXBsb2FkKClcbiAgICAgICAgICAgICAgICAgIHNob3dCdG5SZW1vdmVVcGxvYWQoKVxuXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgcmVxLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUubGVuZ3RoQ29tcHV0YWJsZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gTWF0aC5mbG9vcihlLmxvYWRlZCAvIGUudG90YWwgKiAxMDApXG4gICAgICAgICAgICAgICAgICAgIHRtcGwucXVlcnlTZWxlY3RvcignLnVwbG9hZC1zaXplJykuaW5uZXJUZXh0ID0gZnJpZW5kbHlCeXRlcyhlLmxvYWRlZClcbiAgICAgICAgICAgICAgICAgICAgdG1wbC5xdWVyeVNlbGVjdG9yKCcudXBsb2FkLXBlcmNlbnQnKS5pbm5lclRleHQgPSBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYiA9IHRtcGwucXVlcnlTZWxlY3RvcignLnByb2dyZXNzLWJhcicpXG4gICAgICAgICAgICAgICAgICAgIHBiLnN0eWxlWyd3aWR0aCddID0gYCR7cGVyY2VudH0lYFxuICAgICAgICAgICAgICAgICAgICBwYi5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBwZXJjZW50KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxvYWRlZCA9PSBlLnRvdGFsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICBoaWRlQnRuQ2FuY2VsVXBsb2FkKClcbiAgICAgICAgICAgICAgICAgICAgICBzaG93TWVzc2FnZShpbnB1dC5kYXRhc2V0LnVwbG9hZE1zZ0ZpbGVQcm9jZXNzaW5nLCAnaW5mbycpXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgIHNob3dNZXNzYWdlKGlucHV0LmRhdGFzZXQudXBsb2FkTXNnRmlsZVVwbG9hZGluZywgJ2luZm8nKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZXZ0ID0+IHtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgaGlkZUJ0bkNhbmNlbFVwbG9hZCgpXG5cbiAgICAgICAgICAgICAgICAgIC8vIGZpbGUgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwIHx8IHJlcS5zdGF0dXMgPT0gMjAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdG1wbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRtcGwpXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlc0JvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZXMnKVxuICAgICAgICAgICAgICAgICAgICBmaWxlc0JvZHkuaW5uZXJIVE1MID0gcmVxLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgaHRteCBvbiBuZXdseSBhZGRlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBodG14LnByb2Nlc3MoZmlsZXNCb2R5KVxuICAgICAgICAgICAgICAgICAgICBodG14LnRyaWdnZXIoZmlsZXNCb2R5LCAnaHRteDpsb2FkJylcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAqIGZpbGUgdG9vIGxhcmdlLiBVbmZvcnR1bmF0ZWx5IHRoaXMgY2Fubm90IGJlIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgICAgKiBhbnltb3JlIGF0IHNlcnZlciBhcyB0aGUgZXJyb3IgaXMgd3JhcHBlZCBpbnNpZGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmKHJlcS5zdGF0dXMgPT0gNDEzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hvd0J0blJlbW92ZVVwbG9hZCgpXG4gICAgICAgICAgICAgICAgICAgIHNob3dNZXNzYWdlKGlucHV0LmRhdGFzZXQudXBsb2FkTXNnRmlsZVRvb0xhcmdlLCAnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICBobFBnQmFyKHRtcGwucXVlcnlTZWxlY3RvcignLnByb2dyZXNzLWJhcicpLCAnZXJyb3InKVxuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBkaXJlY3RvcnkgaGFzIGJlZW4gcmVtb3ZlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYocmVxLnN0YXR1cyA9PSA0MDQpIHtcblxuICAgICAgICAgICAgICAgICAgICBzaG93QnRuUmVtb3ZlVXBsb2FkKClcbiAgICAgICAgICAgICAgICAgICAgc2hvd01lc3NhZ2UoaW5wdXQuZGF0YXNldC51cGxvYWRNc2dEaXJOb3RGb3VuZCwgJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgaGxQZ0Jhcih0bXBsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcy1iYXInKSwgJ2Vycm9yJylcblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gdW5kZXRlcm1pbmVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hvd0J0blJlbW92ZVVwbG9hZCgpXG4gICAgICAgICAgICAgICAgICAgIHNob3dNZXNzYWdlKGlucHV0LmRhdGFzZXQudXBsb2FkTXNnVW5leHBlY3RlZCwgJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgaGxQZ0Jhcih0bXBsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcy1iYXInKSwgJ2Vycm9yJylcblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHJlcS5vcGVuKGZvcm0ubWV0aG9kLCBmb3JtLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlcnNbaV1bMF0sIGhlYWRlcnNbaV1bMV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtcGwucXVlcnlTZWxlY3RvcignLmJ0bi1jYW5jZWwtdXBsb2FkJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICByZXEuYWJvcnQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgcmVxLnNlbmQoZmlsZSk7XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0byByZXRyaWdnZXIgXCJjaGFuZ2VcIiB3aGVuIHNvbWVvbmUgZW50ZXJzIHRoZSBzYW1lIGZpbGUgYWdhaW5cbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgfSlcbiAgICB9KTtcbn1cblxuY29uc3QgYnl0ZVVuaXRzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJ11cblxuZnVuY3Rpb24gZnJpZW5kbHlCeXRlcyhuKSB7XG4gICAgaWYgKG4gPCAxMCkge1xuICAgICAgICByZXR1cm4gbiArICcgQidcbiAgICB9XG4gICAgbGV0IGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMTAwMCkpXG4gICAgbGV0IHVuaXQgPSBieXRlVW5pdHNbZV1cbiAgICBsZXQgdmFsID0gIE1hdGguZmxvb3IobiAvIE1hdGgucG93KDEwMDAsIGUpKjEwKzAuNSkgLyAxMFxuICAgIGlmICh2YWwgPCAxMCAmJiAhTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgxKSArICcgJyArIHVuaXRcbiAgICB9XG4gICAgcmV0dXJuIHZhbC50b0ZpeGVkKDApICsgJyAnICsgdW5pdFxufVxuIl0sIm5hbWVzIjpbInJvb3RFbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5wdXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZmlsZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJ0YXJnZXQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZGF0YXNldCIsInVwbG9hZFByb2dyZXNzVGFyZ2V0IiwiZm9ybSIsImNsb3Nlc3QiLCJjc3JmVG9rZW4iLCJxdWVyeVNlbGVjdG9yIiwiY29udGVudCIsImZpbGUiLCJpIiwidG1wbCIsImZpcnN0RWxlbWVudENoaWxkIiwiY2xvbmVOb2RlIiwiaW5uZXJUZXh0IiwibmFtZSIsImFwcGVuZENoaWxkIiwiaGlkZUJ0bkNhbmNlbFVwbG9hZCIsImIiLCJwYXJlbnRFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJzaG93QnRuUmVtb3ZlVXBsb2FkIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwic2hvd01lc3NhZ2UiLCJtc2ciLCJsZXZlbCIsIm0iLCJjbCIsImFkZCIsImhsUGdCYXIiLCJwZ0JhciIsIm1heEZpbGVTaXplIiwidXBsb2FkTWF4RmlsZVNpemUiLCJpc05hTiIsInNpemUiLCJ1cGxvYWRNc2dGaWxlVG9vTGFyZ2UiLCJoZWFkZXJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidHlwZSIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0IiwiZSIsInVwbG9hZE1zZ0ZpbGVBYm9ydGVkIiwidXBsb2FkIiwibGVuZ3RoQ29tcHV0YWJsZSIsInBlcmNlbnQiLCJNYXRoIiwiZmxvb3IiLCJsb2FkZWQiLCJ0b3RhbCIsImZyaWVuZGx5Qnl0ZXMiLCJwYiIsInN0eWxlIiwic2V0QXR0cmlidXRlIiwidXBsb2FkTXNnRmlsZVByb2Nlc3NpbmciLCJ1cGxvYWRNc2dGaWxlVXBsb2FkaW5nIiwiZXZ0IiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsImZpbGVzQm9keSIsImlubmVySFRNTCIsInJlc3BvbnNlIiwiaHRteCIsInByb2Nlc3MiLCJ0cmlnZ2VyIiwidXBsb2FkTXNnRGlyTm90Rm91bmQiLCJ1cGxvYWRNc2dVbmV4cGVjdGVkIiwib3BlbiIsIm1ldGhvZCIsImFjdGlvbiIsInNldFJlcXVlc3RIZWFkZXIiLCJwcmV2ZW50RGVmYXVsdCIsImFib3J0Iiwic2VuZCIsInZhbHVlIiwiYnl0ZVVuaXRzIiwibiIsImxvZyIsInVuaXQiLCJ2YWwiLCJwb3ciLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/form_upload_progress.js\n");

/***/ }),

/***/ "./assets/js/modal_close.js":
/*!**********************************!*\
  !*** ./assets/js/modal_close.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rootEl) {\n  rootEl.querySelectorAll(\".modal-close\").forEach(function (btn) {\n    btn.addEventListener(\"click\", function (evt) {\n      document.getElementById(\"modals\").innerHTML = \"\";\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvbW9kYWxfY2xvc2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUFlLG9DQUFTQSxNQUFNLEVBQUU7RUFDNUJBLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFVQyxHQUFHLEVBQUU7SUFDM0RBLEdBQUcsQ0FBQ0MsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUFDLEdBQUcsRUFBSTtNQUNqQ0MsUUFBUSxDQUFDQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUNDLFNBQVMsR0FBRyxFQUFFO0lBQ3BELENBQUMsQ0FBQztFQUNOLENBQUMsQ0FBQztBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21vZGFsX2Nsb3NlLmpzPzQxNDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocm9vdEVsKSB7XG4gICAgcm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubW9kYWwtY2xvc2VcIikuZm9yRWFjaChmdW5jdGlvbiAoYnRuKSB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZ0ID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibW9kYWxzXCIpLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iXSwibmFtZXMiOlsicm9vdEVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJidG4iLCJhZGRFdmVudExpc3RlbmVyIiwiZXZ0IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/modal_close.js\n");

/***/ }),

/***/ "./assets/js/toast.js":
/*!****************************!*\
  !*** ./assets/js/toast.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rootEl) {\n  rootEl.querySelectorAll('[data-dismiss=\"toast\"]').forEach(function (el) {\n    el.Toast.show();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvanMvdG9hc3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUFlLG9DQUFVQSxNQUFNLEVBQUU7RUFDN0JBLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQUNDLEVBQUUsRUFBSztJQUM5REEsRUFBRSxDQUFDQyxLQUFLLENBQUNDLElBQUksRUFBRTtFQUNuQixDQUFDLENBQUM7QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9qcy90b2FzdC5qcz9iNTE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChyb290RWwpIHtcbiAgICByb290RWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuVG9hc3Quc2hvdygpXG4gICAgfSlcbn0iXSwibmFtZXMiOlsicm9vdEVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsIlRvYXN0Iiwic2hvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/toast.js\n");

/***/ }),

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native-v4.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native-v4.js ***!
  \*******************************************************************/
/***/ (function(module) {

eval("/*!\n  * Native JavaScript for Bootstrap v4.1.0 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022  dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  /**\n   * A global namespace for `document.head`.\n   */\n  var documentHead = document.head;\n\n  /**\n   * A global `boolean` for CSS3 transition support.\n   * @type {boolean}\n   */\n  var supportTransition = 'webkitTransition' in documentHead.style || 'transition' in documentHead.style;\n\n  /**\n   * A global namespace for 'transitionend' string.\n   * @type {string}\n   */\n  var transitionEndEvent = 'webkitTransition' in documentHead.style ? 'webkitTransitionEnd' : 'transitionend';\n\n  /**\n   * A global namespace for 'transitionDelay' string.\n   * @type {string}\n   */\n  var transitionDelay = 'webkitTransition' in documentHead.style ? 'webkitTransitionDelay' : 'transitionDelay';\n\n  /**\n   * A global namespace for:\n   * * `transitionProperty` string for modern brosers,\n   * * `webkitTransition` for legacy Chrome / Safari browsers\n   *\n   * @type {string}\n   */\n  var transitionProperty = 'webkitTransition' in documentHead.style ? 'webkitTransitionProperty' : 'transitionProperty';\n\n  /**\n   * Shortcut for `window.getComputedStyle(element).propertyName`\n   * static method.\n   *\n   * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n   * throws a `ReferenceError`.\n   *\n   * @param {HTMLElement | Element} element target\n   * @param {string} property the css property\n   * @return {string} the css property value\n   */\n  function getElementStyle(element, property) {\n    var computedStyle = getComputedStyle(element);\n\n    // @ts-ignore -- must use camelcase strings,\n    // or non-camelcase strings with `getPropertyValue`\n    return property in computedStyle ? computedStyle[property] : '';\n  }\n\n  /**\n   * Utility to get the computed `transitionDelay`\n   * from Element in miliseconds.\n   *\n   * @param {HTMLElement | Element} element target\n   * @return {number} the value in miliseconds\n   */\n  function getElementTransitionDelay(element) {\n    var propertyValue = getElementStyle(element, transitionProperty);\n    var delayValue = getElementStyle(element, transitionDelay);\n    var delayScale = delayValue.includes('ms') ? 1 : 1000;\n    var duration = supportTransition && propertyValue && propertyValue !== 'none'\n      ? parseFloat(delayValue) * delayScale : 0;\n\n    return !Number.isNaN(duration) ? duration : 0;\n  }\n\n  /**\n   * A global namespace for 'transitionDuration' string.\n   * @type {string}\n   */\n  var transitionDuration = 'webkitTransition' in documentHead.style ? 'webkitTransitionDuration' : 'transitionDuration';\n\n  /**\n   * Utility to get the computed `transitionDuration`\n   * from Element in miliseconds.\n   *\n   * @param {HTMLElement | Element} element target\n   * @return {number} the value in miliseconds\n   */\n  function getElementTransitionDuration(element) {\n    var propertyValue = getElementStyle(element, transitionProperty);\n    var durationValue = getElementStyle(element, transitionDuration);\n    var durationScale = durationValue.includes('ms') ? 1 : 1000;\n    var duration = supportTransition && propertyValue && propertyValue !== 'none'\n      ? parseFloat(durationValue) * durationScale : 0;\n\n    return !Number.isNaN(duration) ? duration : 0;\n  }\n\n  /**\n   * Utility to make sure callbacks are consistently\n   * called when transition ends.\n   *\n   * @param {HTMLElement | Element} element target\n   * @param {EventListener} handler `transitionend` callback\n   */\n  function emulateTransitionEnd(element, handler) {\n    var called = 0;\n    var endEvent = new Event(transitionEndEvent);\n    var duration = getElementTransitionDuration(element);\n    var delay = getElementTransitionDelay(element);\n\n    if (supportTransition && duration) {\n      /**\n       * Wrap the handler in on -> off callback\n       * @param {Event} e Event object\n       */\n      var transitionEndWrapper = function (e) {\n        if (e.target === element) {\n          handler.apply(element, [e]);\n          element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n          called = 1;\n        }\n      };\n      element.addEventListener(transitionEndEvent, transitionEndWrapper);\n      setTimeout(function () {\n        if (!called) { element.dispatchEvent(endEvent); }\n      }, duration + delay + 17);\n    } else {\n      handler.apply(element, [endEvent]);\n    }\n  }\n\n  /**\n   * Returns the `document` or the `#document` element.\n   * @see https://github.com/floating-ui/floating-ui\n   * @param {(Node | HTMLElement | Element | globalThis)=} node\n   * @returns {Document}\n   */\n  function getDocument(node) {\n    if (node instanceof HTMLElement) { return node.ownerDocument; }\n    if (node instanceof Window) { return node.document; }\n    return window.document;\n  }\n\n  /**\n   * A global array of possible `ParentNode`.\n   */\n  var parentNodes = [Document, Element, HTMLElement];\n\n  /**\n   * A global array with `Element` | `HTMLElement`.\n   */\n  var elementNodes = [Element, HTMLElement];\n\n  /**\n   * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n   * or find one that matches a selector.\n   *\n   * @param {HTMLElement | Element | string} selector the input selector or target element\n   * @param {(HTMLElement | Element | Document)=} parent optional node to look into\n   * @return {(HTMLElement | Element)?} the `HTMLElement` or `querySelector` result\n   */\n  function querySelector(selector, parent) {\n    var lookUp = parentNodes.some(function (x) { return parent instanceof x; })\n      ? parent : getDocument();\n\n    // @ts-ignore\n    return elementNodes.some(function (x) { return selector instanceof x; })\n      // @ts-ignore\n      ? selector : lookUp.querySelector(selector);\n  }\n\n  /** BSN v4 custom event */\n  function bootstrapCustomEvent(eventType, componentName, eventProperties) {\n    var OriginalCustomEvent = new CustomEvent((eventType + \".bs.\" + componentName), { cancelable: true });\n\n    if (typeof eventProperties !== 'undefined') {\n      Object.keys(eventProperties).forEach(function (key) {\n        Object.defineProperty(OriginalCustomEvent, key, {\n          value: eventProperties[key],\n        });\n      });\n    }\n    return OriginalCustomEvent;\n  }\n\n  /**\n   * A quick shortcut for `dispatchEvent` v4.\n   * @param {CustomEvent} customEvent the event object\n   */\n  function dispatchCustomEvent(customEvent) {\n    if (this) { this.dispatchEvent(customEvent); }\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Alert\n  -------------------------------------------- */\n\n  // ALERT DEFINITION\n  // ================\n\n  function Alert(elem) {\n    var element;\n\n    // bind\n    var self = this;\n\n    // the target alert\n    var alert;\n\n    // custom events\n    var closeCustomEvent = bootstrapCustomEvent('close', 'alert');\n    var closedCustomEvent = bootstrapCustomEvent('closed', 'alert');\n\n    // private methods\n    function triggerHandler() {\n      if (alert.classList.contains('fade')) { emulateTransitionEnd(alert, transitionEndHandler); }\n      else { transitionEndHandler(); }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('click', clickHandler, false);\n    }\n\n    // event handlers\n    function clickHandler(e) {\n      alert = e && e.target.closest('.alert');\n      element = querySelector('[data-dismiss=\"alert\"]', alert);\n      if (element && alert && (element === e.target || element.contains(e.target))) { self.close(); }\n    }\n    function transitionEndHandler() {\n      toggleEvents();\n      alert.parentNode.removeChild(alert);\n      dispatchCustomEvent.call(alert, closedCustomEvent);\n    }\n\n    // PUBLIC METHODS\n    self.close = function () {\n      if (alert && element && alert.classList.contains('show')) {\n        dispatchCustomEvent.call(alert, closeCustomEvent);\n        if (closeCustomEvent.defaultPrevented) { return; }\n        self.dispose();\n        alert.classList.remove('show');\n        triggerHandler();\n      }\n    };\n\n    self.dispose = function () {\n      toggleEvents();\n      delete element.Alert;\n    };\n\n    // INIT\n    // initialization element\n    element = querySelector(elem);\n\n    // find the target alert\n    alert = element.closest('.alert');\n\n    // reset on re-init\n    if (element.Alert) { element.Alert.dispose(); }\n\n    // prevent adding event handlers twice\n    if (!element.Alert) { toggleEvents(1); }\n\n    // store init object within target element\n    self.element = element;\n    element.Alert = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Button\n  ---------------------------------------------*/\n\n  // BUTTON DEFINITION\n  // =================\n\n  function Button(elem) {\n    var element;\n\n    // bind and labels\n    var self = this;\n    var labels;\n\n    // changeEvent\n    var changeCustomEvent = bootstrapCustomEvent('change', 'button');\n\n    // private methods\n    function toggle(e) {\n      var eTarget = e.target;\n      var parentLabel = eTarget.closest('LABEL'); // the .btn label\n      var label = null;\n\n      if (eTarget.tagName === 'LABEL') {\n        label = eTarget;\n      } else if (parentLabel) {\n        label = parentLabel;\n      }\n\n      // current input\n      var input = label && label.getElementsByTagName('INPUT')[0];\n\n      // invalidate if no input\n      if (!input) { return; }\n\n      dispatchCustomEvent.call(input, changeCustomEvent); // trigger the change for the input\n      dispatchCustomEvent.call(element, changeCustomEvent); // trigger the change for the btn-group\n\n      // manage the dom manipulation\n      if (input.type === 'checkbox') { // checkboxes\n        if (changeCustomEvent.defaultPrevented) { return; } // discontinue when defaultPrevented is true\n\n        if (!input.checked) {\n          label.classList.add('active');\n          input.getAttribute('checked');\n          input.setAttribute('checked', 'checked');\n          input.checked = true;\n        } else {\n          label.classList.remove('active');\n          input.getAttribute('checked');\n          input.removeAttribute('checked');\n          input.checked = false;\n        }\n\n        if (!element.toggled) { // prevent triggering the event twice\n          element.toggled = true;\n        }\n      }\n\n      if (input.type === 'radio' && !element.toggled) { // radio buttons\n        if (changeCustomEvent.defaultPrevented) { return; }\n        // don't trigger if already active\n        // (the OR condition is a hack to check if the buttons were selected\n        // with key press and NOT mouse click)\n        if (!input.checked || (e.screenX === 0 && e.screenY === 0)) {\n          label.classList.add('active');\n          label.classList.add('focus');\n          input.setAttribute('checked', 'checked');\n          input.checked = true;\n\n          element.toggled = true;\n          Array.from(labels).forEach(function (otherLabel) {\n            var otherInput = otherLabel.getElementsByTagName('INPUT')[0];\n            if (otherLabel !== label && otherLabel.classList.contains('active')) {\n              dispatchCustomEvent.call(otherInput, changeCustomEvent); // trigger the change\n              otherLabel.classList.remove('active');\n              otherInput.removeAttribute('checked');\n              otherInput.checked = false;\n            }\n          });\n        }\n      }\n      setTimeout(function () { element.toggled = false; }, 50);\n    }\n\n    // handlers\n    function keyHandler(e) {\n      var key = e.which || e.keyCode;\n      if (key === 32 && e.target === document.activeElement) { toggle(e); }\n    }\n    function preventScroll(e) {\n      var key = e.which || e.keyCode;\n      if (key === 32) { e.preventDefault(); }\n    }\n    function focusToggle(e) {\n      if (e.target.tagName === 'INPUT') {\n        var action = e.type === 'focusin' ? 'add' : 'remove';\n        e.target.closest('.btn').classList[action]('focus');\n      }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('click', toggle, false);\n      element[action]('keyup', keyHandler, false);\n      element[action]('keydown', preventScroll, false);\n      element[action]('focusin', focusToggle, false);\n      element[action]('focusout', focusToggle, false);\n    }\n\n    // public method\n    self.dispose = function () {\n      toggleEvents();\n      delete element.Button;\n    };\n\n    // init\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Button) { element.Button.dispose(); }\n\n    labels = element.getElementsByClassName('btn');\n\n    // invalidate\n    if (!labels.length) { return; }\n\n    // prevent adding event handlers twice\n    if (!element.Button) { toggleEvents(1); }\n\n    // set initial toggled state\n    // toggled makes sure to prevent triggering twice the change.bs.button events\n    element.toggled = false;\n\n    // associate target with init object\n    element.Button = self;\n\n    // activate items on load\n    Array.from(labels).forEach(function (btn) {\n      var hasChecked = querySelector('input:checked', btn);\n      if (!btn.classList.contains('active') && hasChecked) {\n        btn.classList.add('active');\n      }\n      if (btn.classList.contains('active') && !hasChecked) {\n        btn.classList.remove('active');\n      }\n    });\n  }\n\n  /**\n   * A global namespace for mouse hover events.\n   * @type {[string, string]}\n   */\n  var mouseHoverEvents = ('onmouseleave' in document) ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'];\n\n  /**\n   * A global namespace for most scroll event listeners.\n   * @type {Partial<AddEventListenerOptions>}\n   */\n  var passiveHandler = { passive: true };\n\n  /**\n   * Returns the bounding client rect of a target `HTMLElement`.\n   *\n   * @see https://github.com/floating-ui/floating-ui\n   *\n   * @param {HTMLElement | Element} element event.target\n   * @param {boolean=} includeScale when *true*, the target scale is also computed\n   * @returns {SHORTER.BoundingClientRect} the bounding client rect object\n   */\n  function getBoundingClientRect(element, includeScale) {\n    var ref = element.getBoundingClientRect();\n    var width = ref.width;\n    var height = ref.height;\n    var top = ref.top;\n    var right = ref.right;\n    var bottom = ref.bottom;\n    var left = ref.left;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (includeScale && element instanceof HTMLElement) {\n      var offsetWidth = element.offsetWidth;\n      var offsetHeight = element.offsetHeight;\n      scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth || 1 : 1;\n      scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight || 1 : 1;\n    }\n\n    return {\n      width: width / scaleX,\n      height: height / scaleY,\n      top: top / scaleY,\n      right: right / scaleX,\n      bottom: bottom / scaleY,\n      left: left / scaleX,\n      x: left / scaleX,\n      y: top / scaleY,\n    };\n  }\n\n  /**\n   * Returns the `document.documentElement` or the `<html>` element.\n   *\n   * @param {(Node | HTMLElement | Element | globalThis)=} node\n   * @returns {HTMLElement | HTMLHtmlElement}\n   */\n  function getDocumentElement(node) {\n    return getDocument(node).documentElement;\n  }\n\n  /**\n   * Utility to determine if an `HTMLElement`\n   * is partially visible in viewport.\n   *\n   * @param {HTMLElement | Element} element target\n   * @return {boolean} the query result\n   */\n  var isElementInScrollRange = function (element) {\n    var ref = getBoundingClientRect(element);\n    var top = ref.top;\n    var bottom = ref.bottom;\n    var ref$1 = getDocumentElement(element);\n    var clientHeight = ref$1.clientHeight;\n    // checks bottom && top\n    return top <= clientHeight && bottom >= 0;\n  };\n\n  /**\n   * Utility to force re-paint of an `HTMLElement` target.\n   *\n   * @param {HTMLElement | Element} element is the target\n   * @return {number} the `Element.offsetHeight` value\n   */\n  // @ts-ignore\n  var reflow = function (element) { return element.offsetHeight; };\n\n  /* Native JavaScript for Bootstrap 4 | Carousel\n  ----------------------------------------------- */\n\n  // CAROUSEL DEFINITION\n  // ===================\n\n  function Carousel(elem, opsInput) {\n    var assign, assign$1, assign$2;\n\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // internal variables\n    var vars;\n    var ops;\n\n    // custom events\n    var slideCustomEvent;\n    var slidCustomEvent;\n\n    // carousel elements\n    var slides;\n    var leftArrow;\n    var rightArrow;\n    var indicator;\n    var indicators;\n\n    // handlers\n    function pauseHandler() {\n      if (ops.interval !== false && !element.classList.contains('paused')) {\n        element.classList.add('paused');\n        if (!vars.isSliding) {\n          clearInterval(vars.timer);\n          vars.timer = null;\n        }\n      }\n    }\n    function resumeHandler() {\n      if (ops.interval !== false && element.classList.contains('paused')) {\n        element.classList.remove('paused');\n        if (!vars.isSliding) {\n          clearInterval(vars.timer);\n          vars.timer = null;\n          self.cycle();\n        }\n      }\n    }\n    function indicatorHandler(e) {\n      e.preventDefault();\n      if (vars.isSliding) { return; }\n\n      var eventTarget = e.target; // event target | the current active item\n\n      if (eventTarget && !eventTarget.classList.contains('active') && eventTarget.getAttribute('data-slide-to')) {\n        vars.index = +(eventTarget.getAttribute('data-slide-to'));\n      } else { return; }\n\n      self.slideTo(vars.index); // Do the slide\n    }\n    function controlsHandler(e) {\n      e.preventDefault();\n      if (vars.isSliding) { return; }\n\n      var eventTarget = e.currentTarget || e.srcElement;\n\n      if (eventTarget === rightArrow) {\n        vars.index += 1;\n      } else if (eventTarget === leftArrow) {\n        vars.index -= 1;\n      }\n\n      self.slideTo(vars.index); // Do the slide\n    }\n    function keyHandler(ref) {\n      var which = ref.which;\n\n      if (vars.isSliding) { return; }\n      switch (which) {\n        case 39:\n          vars.index += 1;\n          break;\n        case 37:\n          vars.index -= 1;\n          break;\n        default: return;\n      }\n      self.slideTo(vars.index); // Do the slide\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.pause && ops.interval) {\n        element[action](mouseHoverEvents[0], pauseHandler, false);\n        element[action](mouseHoverEvents[1], resumeHandler, false);\n        element[action]('touchstart', pauseHandler, passiveHandler);\n        element[action]('touchend', resumeHandler, passiveHandler);\n      }\n\n      if (ops.touch && slides.length > 1) { element[action]('touchstart', touchDownHandler, passiveHandler); }\n\n      if (rightArrow) { rightArrow[action]('click', controlsHandler, false); }\n      if (leftArrow) { leftArrow[action]('click', controlsHandler, false); }\n\n      if (indicator) { indicator[action]('click', indicatorHandler, false); }\n      if (ops.keyboard) { window[action]('keydown', keyHandler, false); }\n    }\n    // touch events\n    function toggleTouchEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('touchmove', touchMoveHandler, passiveHandler);\n      element[action]('touchend', touchEndHandler, passiveHandler);\n    }\n    function touchDownHandler(e) {\n      if (vars.isTouch) { return; }\n\n      vars.touchPosition.startX = e.changedTouches[0].pageX;\n\n      if (element.contains(e.target)) {\n        vars.isTouch = true;\n        toggleTouchEvents(1);\n      }\n    }\n    function touchMoveHandler(e) {\n      if (!vars.isTouch) { e.preventDefault(); return; }\n\n      vars.touchPosition.currentX = e.changedTouches[0].pageX;\n\n      // cancel touch if more than one changedTouches detected\n      if (e.type === 'touchmove' && e.changedTouches.length > 1) {\n        e.preventDefault();\n      }\n    }\n    function touchEndHandler(e) {\n      if (!vars.isTouch || vars.isSliding) { return; }\n\n      vars.touchPosition.endX = vars.touchPosition.currentX || e.changedTouches[0].pageX;\n\n      if (vars.isTouch) {\n        if ((!element.contains(e.target) || !element.contains(e.relatedTarget))\n            && Math.abs(vars.touchPosition.startX - vars.touchPosition.endX) < 75) {\n          return;\n        }\n        if (vars.touchPosition.currentX < vars.touchPosition.startX) {\n          vars.index += 1;\n        } else if (vars.touchPosition.currentX > vars.touchPosition.startX) {\n          vars.index -= 1;\n        }\n        vars.isTouch = false;\n        self.slideTo(vars.index);\n\n        toggleTouchEvents(); // remove\n      }\n    }\n    // private methods\n    function setActivePage(pageIndex) { // indicators\n      Array.from(indicators).forEach(function (x) { return x.classList.remove('active'); });\n      if (indicators[pageIndex]) { indicators[pageIndex].classList.add('active'); }\n    }\n    function transitionEndHandler(e) {\n      if (vars.touchPosition) {\n        var next = vars.index;\n        var timeout = e && e.target !== slides[next] ? e.elapsedTime * 1000 + 100 : 20;\n        var activeItem = self.getActiveIndex();\n        var orientation = vars.direction === 'left' ? 'next' : 'prev';\n\n        if (vars.isSliding) {\n          setTimeout(function () {\n            if (vars.touchPosition) {\n              vars.isSliding = false;\n\n              slides[next].classList.add('active');\n              slides[activeItem].classList.remove('active');\n\n              slides[next].classList.remove((\"carousel-item-\" + orientation));\n              slides[next].classList.remove((\"carousel-item-\" + (vars.direction)));\n              slides[activeItem].classList.remove((\"carousel-item-\" + (vars.direction)));\n\n              dispatchCustomEvent.call(element, slidCustomEvent);\n              // check for element, might have been disposed\n              if (!document.hidden && ops.interval && !element.classList.contains('paused')) {\n                self.cycle();\n              }\n            }\n          }, timeout);\n        }\n      }\n    }\n\n    // public methods\n    self.cycle = function () {\n      if (vars.timer) {\n        clearInterval(vars.timer);\n        vars.timer = null;\n      }\n\n      vars.timer = setInterval(function () {\n        var idx = vars.index || self.getActiveIndex();\n        if (isElementInScrollRange(element)) {\n          idx += 1;\n          self.slideTo(idx);\n        }\n      }, ops.interval);\n    };\n    self.slideTo = function (idx) {\n      if (vars.isSliding) { return; } // when controled via methods, make sure to check again\n\n      // the current active, orientation, event eventProperties\n      var activeItem = self.getActiveIndex();\n      var next = idx;\n\n      // first return if we're on the same item #227\n      if (activeItem === next) {\n        return;\n      // or determine slide direction\n      } if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n        vars.direction = 'left'; // next\n      } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n        vars.direction = 'right'; // prev\n      }\n\n      // find the right next index\n      if (next < 0) { next = slides.length - 1; }\n      else if (next >= slides.length) { next = 0; }\n\n      var orientation = vars.direction === 'left' ? 'next' : 'prev'; // determine type\n\n      var eventProperties = {\n        relatedTarget: slides[next], direction: vars.direction, from: activeItem, to: next,\n      };\n      slideCustomEvent = bootstrapCustomEvent('slide', 'carousel', eventProperties);\n      slidCustomEvent = bootstrapCustomEvent('slid', 'carousel', eventProperties);\n      dispatchCustomEvent.call(element, slideCustomEvent); // here we go with the slide\n      if (slideCustomEvent.defaultPrevented) { return; } // discontinue when prevented\n\n      // update index\n      vars.index = next;\n\n      vars.isSliding = true;\n      clearInterval(vars.timer);\n      vars.timer = null;\n      setActivePage(next);\n\n      if (getElementTransitionDuration(slides[next]) && element.classList.contains('slide')) {\n        slides[next].classList.add((\"carousel-item-\" + orientation));\n        reflow(slides[next]);\n        slides[next].classList.add((\"carousel-item-\" + (vars.direction)));\n        slides[activeItem].classList.add((\"carousel-item-\" + (vars.direction)));\n\n        emulateTransitionEnd(slides[next], transitionEndHandler);\n      } else {\n        slides[next].classList.add('active');\n        reflow(slides[next]);\n        slides[activeItem].classList.remove('active');\n        setTimeout(function () {\n          vars.isSliding = false;\n          // check for element, might have been disposed\n          if (ops.interval && element && !element.classList.contains('paused')) {\n            self.cycle();\n          }\n          dispatchCustomEvent.call(element, slidCustomEvent);\n        }, 100);\n      }\n    };\n\n    self.getActiveIndex = function () { return Array.from(slides).indexOf(element.getElementsByClassName('carousel-item active')[0]) || 0; };\n\n    self.dispose = function () {\n      var itemClasses = ['left', 'right', 'prev', 'next'];\n\n      Array.from(slides).forEach(function (slide, idx) {\n        if (slide.classList.contains('active')) { setActivePage(idx); }\n        itemClasses.forEach(function (cls) { return slide.classList.remove((\"carousel-item-\" + cls)); });\n      });\n      clearInterval(vars.timer);\n\n      toggleEvents();\n      vars = {};\n      ops = {};\n      delete element.Carousel;\n    };\n\n    // init\n\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Carousel) { element.Carousel.dispose(); }\n\n    // carousel elements\n    slides = element.getElementsByClassName('carousel-item');\n    (assign = element.getElementsByClassName('carousel-control-prev'), leftArrow = assign[0]);\n    (assign$1 = element.getElementsByClassName('carousel-control-next'), rightArrow = assign$1[0]);\n    (assign$2 = element.getElementsByClassName('carousel-indicators'), indicator = assign$2[0]);\n    indicators = (indicator && indicator.getElementsByTagName('LI')) || [];\n\n    // invalidate when not enough items\n    if (slides.length < 2) { return; }\n\n    // check options\n    // DATA API\n    var intervalAttribute = element.getAttribute('data-interval');\n    var intervalData = intervalAttribute === 'false' ? 0 : +(intervalAttribute);\n    var touchData = element.getAttribute('data-touch') === 'false' ? 0 : 1;\n    var pauseData = element.getAttribute('data-pause') === 'hover' || false;\n    var keyboardData = element.getAttribute('data-keyboard') === 'true' || false;\n\n    // JS options\n    var intervalOption = options.interval;\n    var touchOption = options.touch;\n\n    // set instance options\n    ops = {};\n    ops.keyboard = options.keyboard === true || keyboardData;\n    ops.pause = (options.pause === 'hover' || pauseData) ? 'hover' : false; // false / hover\n    ops.touch = touchOption || touchData;\n\n    ops.interval = 5000; // bootstrap carousel default interval\n\n    if (typeof intervalOption === 'number') { ops.interval = intervalOption; }\n    else if (intervalOption === false || intervalData === 0 || intervalData === false) {\n      ops.interval = 0;\n    } else if (!Number.isNaN(intervalData)) { ops.interval = intervalData; }\n\n    // set first slide active if none\n    if (self.getActiveIndex() < 0) {\n      if (slides.length) { slides[0].classList.add('active'); }\n      if (indicators.length) { setActivePage(0); }\n    }\n\n    // set initial state\n    vars = {};\n    vars.direction = 'left';\n    vars.index = 0;\n    vars.timer = null;\n    vars.isSliding = false;\n    vars.isTouch = false;\n    vars.touchPosition = {\n      startX: 0,\n      currentX: 0,\n      endX: 0,\n    };\n\n    // attach event handlers\n    toggleEvents(1);\n\n    // start to cycle if interval is set\n    if (ops.interval) { self.cycle(); }\n\n    // associate init object to target\n    element.Carousel = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Collapse\n  ----------------------------------------------- */\n\n  // COLLAPSE DEFINITION\n  // ===================\n\n  function Collapse(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // target practice\n    var accordion = null;\n    var collapse = null;\n    var activeCollapse;\n    var activeElement;\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // private methods\n    function openAction(collapseElement, toggle) {\n      dispatchCustomEvent.call(collapseElement, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n      collapseElement.isAnimating = true;\n      collapseElement.classList.add('collapsing');\n      collapseElement.classList.remove('collapse');\n      collapseElement.style.height = (collapseElement.scrollHeight) + \"px\";\n\n      emulateTransitionEnd(collapseElement, function () {\n        collapseElement.isAnimating = false;\n        collapseElement.setAttribute('aria-expanded', 'true');\n        toggle.setAttribute('aria-expanded', 'true');\n        collapseElement.classList.remove('collapsing');\n        collapseElement.classList.add('collapse');\n        collapseElement.classList.add('show');\n        collapseElement.style.height = '';\n        dispatchCustomEvent.call(collapseElement, shownCustomEvent);\n      });\n    }\n    function closeAction(collapseElement, toggle) {\n      dispatchCustomEvent.call(collapseElement, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n      collapseElement.isAnimating = true;\n      collapseElement.style.height = (collapseElement.scrollHeight) + \"px\"; // set height first\n      collapseElement.classList.remove('collapse');\n      collapseElement.classList.remove('show');\n      collapseElement.classList.add('collapsing');\n      reflow(collapseElement); // force reflow to enable transition\n      collapseElement.style.height = '0px';\n\n      emulateTransitionEnd(collapseElement, function () {\n        collapseElement.isAnimating = false;\n        collapseElement.setAttribute('aria-expanded', 'false');\n        toggle.setAttribute('aria-expanded', 'false');\n        collapseElement.classList.remove('collapsing');\n        collapseElement.classList.add('collapse');\n        collapseElement.style.height = '';\n        dispatchCustomEvent.call(collapseElement, hiddenCustomEvent);\n      });\n    }\n\n    // public methods\n    self.toggle = function (e) {\n      if ((e && e.target.tagName === 'A') || element.tagName === 'A') { e.preventDefault(); }\n      if (element.contains(e.target) || e.target === element) {\n        if (!collapse.classList.contains('show')) { self.show(); }\n        else { self.hide(); }\n      }\n    };\n    self.hide = function () {\n      if (collapse.isAnimating) { return; }\n      closeAction(collapse, element);\n      element.classList.add('collapsed');\n    };\n    self.show = function () {\n      var assign;\n\n      if (accordion) {\n        (assign = accordion.getElementsByClassName('collapse show'), activeCollapse = assign[0]);\n        activeElement = activeCollapse && (querySelector((\"[data-target=\\\"#\" + (activeCollapse.id) + \"\\\"]\"), accordion)\n                      || querySelector((\"[href=\\\"#\" + (activeCollapse.id) + \"\\\"]\"), accordion));\n      }\n\n      if (!collapse.isAnimating) {\n        if (activeElement && activeCollapse !== collapse) {\n          closeAction(activeCollapse, activeElement);\n          activeElement.classList.add('collapsed');\n        }\n        openAction(collapse, element);\n        element.classList.remove('collapsed');\n      }\n    };\n    self.dispose = function () {\n      element.removeEventListener('click', self.toggle, false);\n      delete element.Collapse;\n    };\n\n    // init\n\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Collapse) { element.Collapse.dispose(); }\n\n    // DATA API\n    var accordionData = element.getAttribute('data-parent');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'collapse');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'collapse');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'collapse');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'collapse');\n\n    // determine targets\n    collapse = querySelector(options.target || element.getAttribute('data-target') || element.getAttribute('href'));\n\n    if (collapse !== null) { collapse.isAnimating = false; }\n    var accordionSelector = options.parent || accordionData;\n    if (accordionSelector) {\n      accordion = element.closest(accordionSelector);\n    } else {\n      accordion = null;\n    }\n\n    // prevent adding event handlers twice\n    if (!element.Collapse) {\n      element.addEventListener('click', self.toggle, false);\n    }\n\n    // associate target to init object\n    element.Collapse = self;\n  }\n\n  /**\n   * Points the focus to a specific element.\n   * @param {HTMLElement} element target\n   */\n  var setFocus = function (element) { return element.focus(); };\n\n  /* Native JavaScript for Bootstrap 4 | Dropdown\n  ----------------------------------------------- */\n\n  // DROPDOWN DEFINITION\n  // ===================\n\n  function Dropdown(elem, option) {\n    var element;\n\n    // bind\n    var self = this;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n    // targets\n    var relatedTarget = null;\n    var parent; var menu; var menuItems = [];\n    // option\n    var persist;\n\n    // preventDefault on empty anchor links\n    function preventEmptyAnchor(anchor) {\n      if ((anchor.hasAttribute('href') && anchor.href.slice(-1) === '#') || (anchor.parentNode\n        && anchor.parentNode.hasAttribute('href')\n        && anchor.parentNode.href.slice(-1) === '#')) { this.preventDefault(); }\n    }\n    // toggle dismissible events\n    function toggleDismiss() {\n      var action = element.open ? 'addEventListener' : 'removeEventListener';\n      document[action]('click', dismissHandler, false);\n      document[action]('keydown', preventScroll, false);\n      document[action]('keyup', keyHandler, false);\n      document[action]('focus', dismissHandler, false);\n    }\n    // handlers\n    function dismissHandler(e) {\n      var eventTarget = e.target;\n      if (!eventTarget.getAttribute) { return; } // some weird FF bug #409\n      var hasData = ((eventTarget && (eventTarget.getAttribute('data-toggle')))\n                                  || (eventTarget.parentNode && eventTarget.parentNode.getAttribute\n                                  && eventTarget.parentNode.getAttribute('data-toggle')));\n      if (e.type === 'focus' && (eventTarget === element || eventTarget === menu || menu.contains(eventTarget))) {\n        return;\n      }\n      if ((eventTarget === menu || menu.contains(eventTarget)) && (persist || hasData)) { return; }\n\n      relatedTarget = eventTarget === element || element.contains(eventTarget) ? element : null;\n      self.hide();\n\n      preventEmptyAnchor.call(e, eventTarget);\n    }\n    function clickHandler(e) {\n      relatedTarget = element;\n      self.show();\n      preventEmptyAnchor.call(e, e.target);\n    }\n    function preventScroll(e) {\n      var key = e.which || e.keyCode;\n      if (key === 38 || key === 40) { e.preventDefault(); }\n    }\n    function keyHandler(e) {\n      var key = e.which || e.keyCode;\n      var activeItem = document.activeElement;\n      var isSameElement = activeItem === element;\n      var isInsideMenu = menu.contains(activeItem);\n      var isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu;\n      var idx = menuItems.indexOf(activeItem);\n\n      if (isMenuItem) { // navigate up | down\n        if (isSameElement) {\n          idx = 0;\n        } else if (key === 38) {\n          idx = idx > 1 ? idx - 1 : 0;\n        } else if (key === 40) {\n          idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n        }\n\n        if (menuItems[idx]) { setFocus(menuItems[idx]); }\n      }\n      if (((menuItems.length && isMenuItem) // menu has items\n            || (!menuItems.length && (isInsideMenu || isSameElement)) // menu might be a form\n            || !isInsideMenu) // or the focused element is not in the menu at all\n            && element.open && key === 27 // menu must be open\n      ) {\n        self.toggle();\n        relatedTarget = null;\n      }\n    }\n\n    // public methods\n    self.show = function () {\n      showCustomEvent = bootstrapCustomEvent('show', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      menu.classList.add('show');\n      parent.classList.add('show');\n      element.setAttribute('aria-expanded', true);\n      element.open = true;\n      element.removeEventListener('click', clickHandler, false);\n      setTimeout(function () {\n        setFocus(menu.getElementsByTagName('INPUT')[0] || element); // focus the first input item | element\n        toggleDismiss();\n        shownCustomEvent = bootstrapCustomEvent('shown', 'dropdown', { relatedTarget: relatedTarget });\n        dispatchCustomEvent.call(parent, shownCustomEvent);\n      }, 1);\n    };\n    self.hide = function () {\n      hideCustomEvent = bootstrapCustomEvent('hide', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n\n      menu.classList.remove('show');\n      parent.classList.remove('show');\n      element.setAttribute('aria-expanded', false);\n      element.open = false;\n      toggleDismiss();\n      setFocus(element);\n      setTimeout(function () {\n        // only re-attach handler if the init is not disposed\n        if (element.Dropdown) { element.addEventListener('click', clickHandler, false); }\n      }, 1);\n\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, hiddenCustomEvent);\n    };\n    self.toggle = function () {\n      if (parent.classList.contains('show') && element.open) { self.hide(); } else { self.show(); }\n    };\n    self.dispose = function () {\n      if (parent.classList.contains('show') && element.open) { self.hide(); }\n      element.removeEventListener('click', clickHandler, false);\n      delete element.Dropdown;\n    };\n\n    // init\n\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Dropdown) { element.Dropdown.dispose(); }\n\n    // set  targets\n    parent = element.parentNode;\n    menu = querySelector('.dropdown-menu', parent);\n\n    Array.from(menu.children).forEach(function (child) {\n      if (child.children.length && child.children[0].tagName === 'A') {\n        menuItems.push(child.children[0]);\n      }\n      if (child.tagName === 'A') { menuItems.push(child); }\n    });\n\n    // prevent adding event handlers twice\n    if (!element.Dropdown) {\n      if (!('tabindex' in menu)) { menu.setAttribute('tabindex', '0'); } // Fix onblur on Chrome | Safari\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    // set option\n    persist = option === true || element.getAttribute('data-persist') === 'true' || false;\n\n    // set initial state to closed\n    element.open = false;\n\n    // associate element with init object\n    element.Dropdown = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Modal\n  -------------------------------------------- */\n\n  // MODAL DEFINITION\n  // ================\n\n  function Modal(elem, opsInput) { // element can be the modal/triggering button\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind, modal\n    var self = this;\n    var modal;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n    // event targets and other\n    var relatedTarget = null;\n    var scrollBarWidth;\n    var overlay;\n    var overlayDelay;\n\n    // also find fixed-top / fixed-bottom items\n    var fixedItems;\n    var ops = {};\n\n    // private methods\n    function setScrollbar() {\n      var bodyClassList = document.body.classList;\n      var openModal = bodyClassList.contains('modal-open');\n      var bodyPad = parseInt(getComputedStyle(document.body).paddingRight, 10);\n      var docClientHeight = document.documentElement.clientHeight;\n      var docScrollHeight = document.documentElement.scrollHeight;\n      var bodyClientHeight = document.body.clientHeight;\n      var bodyScrollHeight = document.body.scrollHeight;\n      var bodyOverflow = docClientHeight !== docScrollHeight\n                      || bodyClientHeight !== bodyScrollHeight;\n      var modalOverflow = modal.clientHeight !== modal.scrollHeight;\n\n      scrollBarWidth = measureScrollbar();\n\n      modal.style.paddingRight = !modalOverflow && scrollBarWidth ? (scrollBarWidth + \"px\") : '';\n      document.body.style.paddingRight = modalOverflow || bodyOverflow\n        ? ((bodyPad + (openModal ? 0 : scrollBarWidth)) + \"px\") : '';\n\n      if (fixedItems.length) {\n        fixedItems.forEach(function (fixed) {\n          var itemPad = getComputedStyle(fixed).paddingRight;\n          fixed.style.paddingRight = modalOverflow || bodyOverflow\n            ? ((parseInt(itemPad, 10) + (openModal ? 0 : scrollBarWidth)) + \"px\")\n            : ((parseInt(itemPad, 10)) + \"px\");\n        });\n      }\n    }\n    function resetScrollbar() {\n      document.body.style.paddingRight = '';\n      modal.style.paddingRight = '';\n      if (fixedItems.length) {\n        fixedItems.forEach(function (fixed) {\n          fixed.style.paddingRight = '';\n        });\n      }\n    }\n    function measureScrollbar() {\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = 'modal-scrollbar-measure'; // this is here to stay\n      document.body.appendChild(scrollDiv);\n      var widthValue = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return widthValue;\n    }\n    function createOverlay() {\n      var newOverlay = document.createElement('div');\n      overlay = querySelector('.modal-backdrop');\n\n      if (overlay === null) {\n        newOverlay.setAttribute('class', (\"modal-backdrop\" + (ops.animation ? ' fade' : '')));\n        overlay = newOverlay;\n        document.body.appendChild(overlay);\n      }\n      return overlay;\n    }\n    function removeOverlay() {\n      overlay = querySelector('.modal-backdrop');\n      if (overlay && !document.getElementsByClassName('modal show')[0]) {\n        document.body.removeChild(overlay); overlay = null;\n      }\n      if (overlay === null) {\n        document.body.classList.remove('modal-open');\n        resetScrollbar();\n      }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      window[action]('resize', self.update, passiveHandler);\n      modal[action]('click', dismissHandler, false);\n      document[action]('keydown', keyHandler, false);\n    }\n    // triggers\n    function beforeShow() {\n      modal.style.display = 'block';\n\n      setScrollbar();\n      if (!document.getElementsByClassName('modal show')[0]) { document.body.classList.add('modal-open'); }\n\n      modal.classList.add('show');\n      modal.setAttribute('aria-hidden', false);\n\n      if (modal.classList.contains('fade')) { emulateTransitionEnd(modal, triggerShow); }\n      else { triggerShow(); }\n    }\n    function triggerShow() {\n      setFocus(modal);\n      modal.isAnimating = false;\n\n      toggleEvents(1);\n\n      shownCustomEvent = bootstrapCustomEvent('shown', 'modal', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(modal, shownCustomEvent);\n    }\n    function triggerHide(force) {\n      modal.style.display = '';\n      if (element) { setFocus(element); }\n\n      overlay = querySelector('.modal-backdrop');\n\n      // force can also be the transitionEvent object, we wanna make sure it's not\n      if (force !== 1 && overlay && overlay.classList.contains('show') && !document.getElementsByClassName('modal show')[0]) {\n        overlay.classList.remove('show');\n        emulateTransitionEnd(overlay, removeOverlay);\n      } else {\n        removeOverlay();\n      }\n\n      toggleEvents();\n\n      modal.isAnimating = false;\n\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'modal');\n      dispatchCustomEvent.call(modal, hiddenCustomEvent);\n    }\n    // handlers\n    function clickHandler(e) {\n      if (modal.isAnimating) { return; }\n      var clickTarget = e.target;\n      var modalID = \"#\" + (modal.getAttribute('id'));\n      var targetAttrValue = clickTarget.getAttribute('data-target') || clickTarget.getAttribute('href');\n      var elemAttrValue = element.getAttribute('data-target') || element.getAttribute('href');\n\n      if (!modal.classList.contains('show')\n          && ((clickTarget === element && targetAttrValue === modalID)\n          || (element.contains(clickTarget) && elemAttrValue === modalID))) {\n        modal.modalTrigger = element;\n        relatedTarget = element;\n        self.show();\n        e.preventDefault();\n      }\n    }\n    function keyHandler(ref) {\n      var which = ref.which;\n\n      if (!modal.isAnimating && ops.keyboard && which === 27 && modal.classList.contains('show')) {\n        self.hide();\n      }\n    }\n    function dismissHandler(e) {\n      if (modal.isAnimating) { return; }\n      var clickTarget = e.target;\n      var hasData = clickTarget.getAttribute('data-dismiss') === 'modal';\n      var parentWithData = clickTarget.closest('[data-dismiss=\"modal\"]');\n\n      if (modal.classList.contains('show') && (parentWithData || hasData\n          || (clickTarget === modal && ops.backdrop !== 'static'))) {\n        self.hide(); relatedTarget = null;\n        e.preventDefault();\n      }\n    }\n\n    // public methods\n    self.toggle = function () {\n      if (modal.classList.contains('show')) { self.hide(); } else { self.show(); }\n    };\n    self.show = function () {\n      if (modal.classList.contains('show') && !!modal.isAnimating) { return; }\n\n      showCustomEvent = bootstrapCustomEvent('show', 'modal', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(modal, showCustomEvent);\n\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      modal.isAnimating = true;\n\n      // we elegantly hide any opened modal\n      var currentOpen = document.getElementsByClassName('modal show')[0];\n      if (currentOpen && currentOpen !== modal) {\n        if (currentOpen.modalTrigger) { currentOpen.modalTrigger.Modal.hide(); }\n        if (currentOpen.Modal) { currentOpen.Modal.hide(); }\n      }\n\n      if (ops.backdrop) { overlay = createOverlay(); }\n\n      if (overlay && !currentOpen && !overlay.classList.contains('show')) {\n        reflow(overlay);\n        overlayDelay = getElementTransitionDuration(overlay);\n        overlay.classList.add('show');\n      }\n\n      if (!currentOpen) { setTimeout(beforeShow, overlay && overlayDelay ? overlayDelay : 0); }\n      else { beforeShow(); }\n    };\n    self.hide = function (force) {\n      if (!modal.classList.contains('show')) { return; }\n\n      hideCustomEvent = bootstrapCustomEvent('hide', 'modal');\n      dispatchCustomEvent.call(modal, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n\n      modal.isAnimating = true;\n\n      modal.classList.remove('show');\n      modal.setAttribute('aria-hidden', true);\n\n      if (modal.classList.contains('fade') && force !== 1) { emulateTransitionEnd(modal, triggerHide); }\n      else { triggerHide(); }\n    };\n    self.setContent = function (content) {\n      querySelector('.modal-content', modal).innerHTML = content;\n    };\n    self.update = function () {\n      if (modal.classList.contains('show')) {\n        setScrollbar();\n      }\n    };\n    self.dispose = function () {\n      self.hide(1);\n      if (element) { element.removeEventListener('click', clickHandler, false); delete element.Modal; } else { delete modal.Modal; }\n    };\n\n    // init\n\n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = querySelector(elem);\n\n    // determine modal, triggering element\n    var checkModal = querySelector(element.getAttribute('data-target') || element.getAttribute('href'));\n    modal = element.classList.contains('modal') ? element : checkModal;\n\n    // set fixed items\n    fixedItems = Array.from(document.getElementsByClassName('fixed-top'))\n      .concat(Array.from(document.getElementsByClassName('fixed-bottom')));\n\n    if (element.classList.contains('modal')) { element = null; } // modal is now independent of it's triggering element\n\n    // reset on re-init\n    if (element && element.Modal) { element.Modal.dispose(); }\n    if (modal && modal.Modal) { modal.Modal.dispose(); }\n\n    // set options\n    ops.keyboard = !(options.keyboard === false || modal.getAttribute('data-keyboard') === 'false');\n    ops.backdrop = options.backdrop === 'static' || modal.getAttribute('data-backdrop') === 'static' ? 'static' : true;\n    ops.backdrop = options.backdrop === false || modal.getAttribute('data-backdrop') === 'false' ? false : ops.backdrop;\n    ops.animation = !!modal.classList.contains('fade');\n    ops.content = options.content; // JavaScript only\n\n    // set an initial state of the modal\n    modal.isAnimating = false;\n\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n    if (element && !element.Modal) {\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    if (ops.content) {\n      self.setContent(ops.content.trim());\n    }\n\n    // set associations\n    if (element) {\n      modal.modalTrigger = element;\n      element.Modal = self;\n    } else {\n      modal.Modal = self;\n    }\n  }\n\n  /**\n   * A global namespace for mouse click events.\n   * @type {Record<string, string>}\n   */\n  var mouseClickEvents = { down: 'mousedown', up: 'mouseup' };\n\n  /**\n   * Returns the `Window` / `HTML` scroll position.\n   * Popover, Tooltip & ScrollSpy need it.\n   *\n   * @returns {{x: number, y: number}} the scroll `{x,y}` values\n   */\n  function getScroll() {\n    return {\n      y: window.pageYOffset || document.documentElement.scrollTop,\n      x: window.pageXOffset || document.documentElement.scrollLeft,\n    };\n  }\n\n  // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n  function styleTip(link, element, originalPosition, parent) {\n    var tipPositions = /\\b(top|bottom|left|right)+/;\n    var elementDimensions = { w: element.offsetWidth, h: element.offsetHeight };\n    var windowWidth = (document.documentElement.clientWidth || document.body.clientWidth);\n    var windowHeight = (document.documentElement.clientHeight || document.body.clientHeight);\n    var rect = link.getBoundingClientRect();\n    var scroll = parent === document.body\n      ? getScroll()\n      : { x: parent.offsetLeft + parent.scrollLeft, y: parent.offsetTop + parent.scrollTop };\n    var linkDimensions = { w: rect.right - rect.left, h: rect.bottom - rect.top };\n    var isPopover = element.classList.contains('popover');\n    var arrow = element.getElementsByClassName('arrow')[0];\n    var halfTopExceed = rect.top + linkDimensions.h / 2 - elementDimensions.h / 2 < 0;\n    var halfLeftExceed = rect.left + linkDimensions.w / 2 - elementDimensions.w / 2 < 0;\n    var halfRightExceed = rect.left + elementDimensions.w / 2\n      + linkDimensions.w / 2 >= windowWidth;\n    var halfBottomExceed = rect.top + elementDimensions.h / 2\n      + linkDimensions.h / 2 >= windowHeight;\n    var topExceed = rect.top - elementDimensions.h < 0;\n    var leftExceed = rect.left - elementDimensions.w < 0;\n    var bottomExceed = rect.top + elementDimensions.h + linkDimensions.h >= windowHeight;\n    var rightExceed = rect.left + elementDimensions.w + linkDimensions.w >= windowWidth;\n    var position = originalPosition;\n\n    // recompute position\n    // first, when both left and right limits are exceeded, we fall back to top|bottom\n    position = (position === 'left' || position === 'right') && leftExceed && rightExceed ? 'top' : position;\n    position = position === 'top' && topExceed ? 'bottom' : position;\n    position = position === 'bottom' && bottomExceed ? 'top' : position;\n    position = position === 'left' && leftExceed ? 'right' : position;\n    position = position === 'right' && rightExceed ? 'left' : position;\n\n    var topPosition;\n    var leftPosition;\n    var arrowTop;\n    var arrowLeft;\n\n    // update tooltip/popover class\n    if (element.className.indexOf(position) === -1) {\n      element.className = element.className.replace(tipPositions, position);\n    }\n\n    // we check the computed width & height and update here\n    var arrowWidth = arrow.offsetWidth;\n    var arrowHeight = arrow.offsetHeight;\n\n    // apply styling to tooltip or popover\n    // secondary|side positions\n    if (position === 'left' || position === 'right') {\n      if (position === 'left') { // LEFT\n        leftPosition = rect.left + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);\n      } else { // RIGHT\n        leftPosition = rect.left + scroll.x + linkDimensions.w;\n      }\n\n      // adjust top and arrow\n      if (halfTopExceed) {\n        topPosition = rect.top + scroll.y;\n        arrowTop = linkDimensions.h / 2 - arrowWidth;\n      } else if (halfBottomExceed) {\n        topPosition = rect.top + scroll.y - elementDimensions.h + linkDimensions.h;\n        arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;\n      } else {\n        topPosition = rect.top + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;\n        arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);\n      }\n    // primary|vertical positions\n    } else if (position === 'top' || position === 'bottom') {\n      if (position === 'top') { // TOP\n        topPosition = rect.top + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = rect.top + scroll.y + linkDimensions.h;\n      }\n      // adjust left | right and also the arrow\n      if (halfLeftExceed) {\n        leftPosition = 0;\n        arrowLeft = rect.left + linkDimensions.w / 2 - arrowWidth;\n      } else if (halfRightExceed) {\n        leftPosition = windowWidth - elementDimensions.w * 1.01;\n        arrowLeft = elementDimensions.w - (windowWidth - rect.left)\n          + linkDimensions.w / 2 - arrowWidth / 2;\n      } else {\n        leftPosition = rect.left + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;\n        arrowLeft = elementDimensions.w / 2 - (isPopover ? arrowWidth : arrowWidth / 2);\n      }\n    }\n\n    // apply style to tooltip/popover and its arrow\n    element.style.top = topPosition + \"px\";\n    element.style.left = leftPosition + \"px\";\n\n    if (arrowTop) { arrow.style.top = arrowTop + \"px\"; }\n    if (arrowLeft) { arrow.style.left = arrowLeft + \"px\"; }\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Popover\n  ---------------------------------------------- */\n\n  // POPOVER DEFINITION\n  // ==================\n\n  function Popover(elem, opsInput) {\n    var element;\n    // set instance options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // popover and timer\n    var popover = null;\n    var timer = 0;\n    var isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent);\n    // title and content\n    var titleString;\n    var contentString;\n    var placementClass;\n\n    // options\n    var ops = {};\n\n    // close btn for dissmissible popover\n    var closeBtn;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // handlers\n    function dismissibleHandler(e) {\n      if (popover !== null && e.target === querySelector('.close', popover)) {\n        self.hide();\n      }\n    }\n    // private methods\n    function getAttr(att) {\n      return options[att] || element.dataset[att] || null;\n    }\n    function getTitle() {\n      return getAttr('title');\n    }\n    function getContent() {\n      return getAttr('content');\n    }\n    function removePopover() {\n      ops.container.removeChild(popover);\n      timer = null; popover = null;\n    }\n\n    function createPopover() {\n      titleString = getTitle();\n      contentString = getContent();\n      // fixing https://github.com/thednp/bootstrap.native/issues/233\n      contentString = contentString ? contentString.trim() : null;\n\n      popover = document.createElement('div');\n\n      // popover arrow\n      var popoverArrow = document.createElement('div');\n      popoverArrow.classList.add('arrow');\n      popover.appendChild(popoverArrow);\n\n      // create the popover from data attributes\n      if (contentString !== null && ops.template === null) {\n        popover.setAttribute('role', 'tooltip');\n\n        if (titleString !== null) {\n          var popoverTitle = document.createElement('h3');\n          popoverTitle.classList.add('popover-header');\n          popoverTitle.innerHTML = ops.dismissible ? titleString + closeBtn : titleString;\n          popover.appendChild(popoverTitle);\n        }\n\n        // set popover content\n        var popoverBodyMarkup = document.createElement('div');\n        popoverBodyMarkup.classList.add('popover-body');\n        popoverBodyMarkup.innerHTML = ops.dismissible && titleString === null\n          ? contentString + closeBtn\n          : contentString;\n        popover.appendChild(popoverBodyMarkup);\n      } else { // or create the popover from template\n        var popoverTemplate = document.createElement('div');\n        popoverTemplate.innerHTML = ops.template.trim();\n        popover.className = popoverTemplate.firstChild.className;\n        popover.innerHTML = popoverTemplate.firstChild.innerHTML;\n\n        var popoverHeader = querySelector('.popover-header', popover);\n        var popoverBody = querySelector('.popover-body', popover);\n\n        // fill the template with content from data attributes\n        if (titleString && popoverHeader) { popoverHeader.innerHTML = titleString.trim(); }\n        if (contentString && popoverBody) { popoverBody.innerHTML = contentString.trim(); }\n      }\n\n      // append to the container\n      ops.container.appendChild(popover);\n      popover.style.display = 'block';\n      if (!popover.classList.contains('popover')) { popover.classList.add('popover'); }\n      if (!popover.classList.contains(ops.animation)) { popover.classList.add(ops.animation); }\n      if (!popover.classList.contains(placementClass)) { popover.classList.add(placementClass); }\n    }\n    function showPopover() {\n      if (!popover.classList.contains('show')) { popover.classList.add('show'); }\n    }\n    function updatePopover() {\n      styleTip(element, popover, ops.placement, ops.container);\n    }\n    function forceFocus() {\n      if (popover === null) { element.focus(); }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.trigger === 'hover') {\n        element[action](mouseClickEvents.down, self.show);\n        element[action](mouseHoverEvents[0], self.show);\n        // mouseHover = ('onmouseleave' in document)\n        //   ? [ 'mouseenter', 'mouseleave']\n        //   : [ 'mouseover', 'mouseout' ]\n        if (!ops.dismissible) { element[action](mouseHoverEvents[1], self.hide); }\n      } else if (ops.trigger === 'click') {\n        element[action](ops.trigger, self.toggle);\n      } else if (ops.trigger === 'focus') {\n        if (isIphone) { element[action]('click', forceFocus, false); }\n        element[action](ops.trigger, self.toggle);\n      }\n    }\n    function touchHandler(e) {\n      if ((popover && popover.contains(e.target))\n        || e.target === element || element.contains(e.target)) ; else {\n        self.hide();\n      }\n    }\n    // event toggle\n    function dismissHandlerToggle(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.dismissible) {\n        document[action]('click', dismissibleHandler, false);\n      } else {\n        if (ops.trigger === 'focus') { element[action]('blur', self.hide); }\n        if (ops.trigger === 'hover') { document[action]('touchstart', touchHandler, passiveHandler); }\n      }\n      window[action]('resize', self.hide, passiveHandler);\n    }\n    // triggers\n    function showTrigger() {\n      dismissHandlerToggle(1);\n      dispatchCustomEvent.call(element, shownCustomEvent);\n    }\n    function hideTrigger() {\n      dismissHandlerToggle();\n      removePopover();\n      dispatchCustomEvent.call(element, hiddenCustomEvent);\n    }\n\n    // public methods / handlers\n    self.toggle = function () {\n      if (popover === null) { self.show(); }\n      else { self.hide(); }\n    };\n    self.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover === null) {\n          dispatchCustomEvent.call(element, showCustomEvent);\n          if (showCustomEvent.defaultPrevented) { return; }\n\n          createPopover();\n          updatePopover();\n          showPopover();\n          if (ops.animation) { emulateTransitionEnd(popover, showTrigger); }\n          else { showTrigger(); }\n        }\n      }, 20);\n    };\n    self.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover && popover !== null && popover.classList.contains('show')) {\n          dispatchCustomEvent.call(element, hideCustomEvent);\n          if (hideCustomEvent.defaultPrevented) { return; }\n          popover.classList.remove('show');\n          if (ops.animation) { emulateTransitionEnd(popover, hideTrigger); }\n          else { hideTrigger(); }\n        }\n      }, ops.delay);\n    };\n    self.dispose = function () {\n      self.hide();\n      toggleEvents();\n      delete element.Popover;\n    };\n\n    // INIT\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Popover) { element.Popover.dispose(); }\n\n    // DATA API\n    var triggerData = element.getAttribute('data-trigger'); // click / hover / focus\n    var animationData = element.getAttribute('data-animation'); // true / false\n\n    var placementData = element.getAttribute('data-placement');\n    var dismissibleData = element.getAttribute('data-dismissible');\n    var delayData = element.getAttribute('data-delay');\n    var containerData = element.getAttribute('data-container');\n\n    // close btn for dissmissible popover\n    closeBtn = '<button type=\"button\" class=\"close\"></button>';\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'popover');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'popover');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'popover');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'popover');\n\n    // check container\n    var containerElement = querySelector(options.container);\n    var containerDataElement = querySelector(containerData);\n\n    // maybe the element is inside a modal\n    var modal = element.closest('.modal');\n\n    // maybe the element is inside a fixed navbar\n    var navbarFixedTop = element.closest('.fixed-top');\n    var navbarFixedBottom = element.closest('.fixed-bottom');\n\n    // set instance options\n    ops.template = options.template ? options.template : null; // JavaScript only\n    ops.trigger = options.trigger ? options.trigger : triggerData || 'hover';\n    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';\n    ops.placement = options.placement ? options.placement : placementData || 'top';\n    ops.delay = parseInt((options.delay || delayData), 10) || 200;\n    ops.dismissible = !!(options.dismissible || dismissibleData === 'true');\n    ops.container = containerElement\n      || (containerDataElement\n        || (navbarFixedTop || (navbarFixedBottom || (modal || document.body))));\n\n    placementClass = \"bs-popover-\" + (ops.placement);\n\n    // invalidate\n    titleString = getTitle();\n    contentString = getContent();\n\n    if (!contentString && !ops.template) { return; }\n\n    // init\n    if (!element.Popover) { // prevent adding event handlers twice\n      toggleEvents(1);\n    }\n\n    // associate target to init object\n    element.Popover = self;\n  }\n\n  /* Native JavaScript for Bootstrap 5 | ScrollSpy\n  ------------------------------------------------ */\n\n  // SCROLLSPY DEFINITION\n  // ====================\n\n  function ScrollSpy(elem, opsInput) {\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // GC internals\n    var vars;\n    var links;\n\n    // targets\n    var spyTarget;\n    // determine which is the real scrollTarget\n    var scrollTarget;\n    // options\n    var ops = {};\n\n    // private methods\n    // populate items and targets\n    function updateTargets() {\n      links = spyTarget.getElementsByTagName('A');\n\n      vars.scrollTop = vars.isWindow ? getScroll().y : element.scrollTop;\n\n      // only update vars once or with each mutation\n      if (vars.length !== links.length || getScrollHeight() !== vars.scrollHeight) {\n        var href;\n        var targetItem;\n        var rect;\n\n        // reset arrays & update\n        vars.items = [];\n        vars.offsets = [];\n        vars.scrollHeight = getScrollHeight();\n        vars.maxScroll = vars.scrollHeight - getOffsetHeight();\n\n        Array.from(links).forEach(function (link) {\n          href = link.getAttribute('href');\n          targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && querySelector(href);\n\n          if (targetItem) {\n            vars.items.push(link);\n            rect = targetItem.getBoundingClientRect();\n            vars.offsets.push((vars.isWindow\n              ? rect.top + vars.scrollTop\n              : targetItem.offsetTop) - ops.offset);\n          }\n        });\n        vars.length = vars.items.length;\n      }\n    }\n    // item update\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      scrollTarget[action]('scroll', self.refresh, passiveHandler);\n      window[action]('resize', self.refresh, passiveHandler);\n    }\n    function getScrollHeight() {\n      return scrollTarget.scrollHeight || Math.max(\n        document.body.scrollHeight,\n        document.documentElement.scrollHeight\n      );\n    }\n    function getOffsetHeight() {\n      return !vars.isWindow ? element.getBoundingClientRect().height : window.innerHeight;\n    }\n    function clear() {\n      Array.from(links).map(function (item) { return item.classList.contains('active') && item.classList.remove('active'); });\n    }\n    function activate(input) {\n      var item = input;\n      var itemClassList;\n      clear();\n      vars.activeItem = item;\n      item.classList.add('active');\n\n      // activate all parents\n      var parents = [];\n      while (item.parentNode !== document.body) {\n        item = item.parentNode;\n        itemClassList = item.classList;\n\n        if (itemClassList.contains('dropdown-menu') || itemClassList.contains('nav')) { parents.push(item); }\n      }\n\n      parents.forEach(function (menuItem) {\n        var parentLink = menuItem.previousElementSibling;\n\n        if (parentLink && !parentLink.classList.contains('active')) {\n          parentLink.classList.add('active');\n        }\n      });\n\n      dispatchCustomEvent.call(element, bootstrapCustomEvent('activate', 'scrollspy', { relatedTarget: vars.activeItem }));\n    }\n\n    // public method\n    self.refresh = function () {\n      updateTargets();\n\n      if (vars.scrollTop >= vars.maxScroll) {\n        var newActiveItem = vars.items[vars.length - 1];\n\n        if (vars.activeItem !== newActiveItem) {\n          activate(newActiveItem);\n        }\n\n        return;\n      }\n\n      if (vars.activeItem && vars.scrollTop < vars.offsets[0] && vars.offsets[0] > 0) {\n        vars.activeItem = null;\n        clear();\n        return;\n      }\n\n      var i = vars.length;\n      while (i > -1) {\n        if (vars.activeItem !== vars.items[i] && vars.scrollTop >= vars.offsets[i]\n          && (typeof vars.offsets[i + 1] === 'undefined' || vars.scrollTop < vars.offsets[i + 1])) {\n          activate(vars.items[i]);\n        }\n        i -= 1;\n      }\n    };\n    self.dispose = function () {\n      toggleEvents();\n      delete element.ScrollSpy;\n    };\n\n    // init\n    // initialization element, the element we spy on\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.ScrollSpy) { element.ScrollSpy.dispose(); }\n\n    // event targets, constants\n    // DATA API\n    var targetData = element.getAttribute('data-target');\n    var offsetData = element.getAttribute('data-offset');\n\n    // targets\n    spyTarget = querySelector(options.target || targetData);\n\n    // determine which is the real scrollTarget\n    scrollTarget = element.clientHeight < element.scrollHeight ? element : window;\n\n    if (!spyTarget) { return; }\n\n    // set instance option\n    ops.offset = +(options.offset || offsetData) || 10;\n\n    // set instance priority variables\n    vars = {};\n    vars.length = 0;\n    vars.items = [];\n    vars.offsets = [];\n    vars.isWindow = scrollTarget === window;\n    vars.activeItem = null;\n    vars.scrollHeight = 0;\n    vars.maxScroll = 0;\n\n    // prevent adding event handlers twice\n    if (!element.ScrollSpy) { toggleEvents(1); }\n\n    self.refresh();\n\n    // associate target with init object\n    element.ScrollSpy = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Tab\n  ------------------------------------------ */\n\n  // TAB DEFINITION\n  // ==============\n\n  function Tab(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // event targets\n    var tabs;\n    var dropdown;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // more GC material\n    var next;\n    var tabsContentContainer = false;\n    var activeTab;\n    var activeContent;\n    var nextContent;\n    var containerHeight;\n    var equalContents;\n    var nextHeight;\n\n    // triggers\n    function triggerEnd() {\n      tabsContentContainer.style.height = '';\n      tabsContentContainer.classList.remove('collapsing');\n      tabs.isAnimating = false;\n    }\n    function triggerShow() {\n      if (tabsContentContainer) { // height animation\n        if (equalContents) {\n          triggerEnd();\n        } else {\n          setTimeout(function () { // enables height animation\n            tabsContentContainer.style.height = nextHeight + \"px\"; // height animation\n            reflow(tabsContentContainer);\n            emulateTransitionEnd(tabsContentContainer, triggerEnd);\n          }, 50);\n        }\n      } else {\n        tabs.isAnimating = false;\n      }\n      shownCustomEvent = bootstrapCustomEvent('shown', 'tab', { relatedTarget: activeTab });\n      dispatchCustomEvent.call(next, shownCustomEvent);\n    }\n    function triggerHide() {\n      if (tabsContentContainer) {\n        activeContent.style.float = 'left';\n        nextContent.style.float = 'left';\n        containerHeight = activeContent.scrollHeight;\n      }\n\n      showCustomEvent = bootstrapCustomEvent('show', 'tab', { relatedTarget: activeTab });\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tab', { relatedTarget: next });\n\n      dispatchCustomEvent.call(next, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      nextContent.classList.add('active');\n\n      activeContent.classList.remove('active');\n\n      if (tabsContentContainer) {\n        nextHeight = nextContent.scrollHeight;\n        equalContents = nextHeight === containerHeight;\n        tabsContentContainer.classList.add('collapsing');\n        tabsContentContainer.style.height = containerHeight + \"px\"; // height animation\n        reflow(tabsContentContainer);\n        activeContent.style.float = '';\n        nextContent.style.float = '';\n      }\n\n      if (nextContent.classList.contains('fade')) {\n        setTimeout(function () {\n          nextContent.classList.add('show');\n          emulateTransitionEnd(nextContent, triggerShow);\n        }, 20);\n      } else { triggerShow(); }\n\n      dispatchCustomEvent.call(activeTab, hiddenCustomEvent);\n    }\n    // private methods\n    function getActiveTab() {\n      var assign;\n\n      var activeTabs = tabs.getElementsByClassName('active');\n\n      if (activeTabs.length === 1 && !activeTabs[0].parentNode.classList.contains('dropdown')) {\n        (assign = activeTabs, activeTab = assign[0]);\n      } else if (activeTabs.length > 1) {\n        activeTab = activeTabs[activeTabs.length - 1];\n      }\n      return activeTab;\n    }\n    function getActiveContent() { return querySelector(getActiveTab().getAttribute('href')); }\n    // handler\n    function clickHandler(e) {\n      e.preventDefault();\n      next = e.currentTarget;\n      if (!tabs.isAnimating) { self.show(); }\n    }\n\n    // public method\n    self.show = function () { // the tab we clicked is now the next tab\n      next = next || element;\n\n      if (!next.classList.contains('active')) {\n        nextContent = querySelector(next.getAttribute('href')); // this is the actual object, the next tab content to activate\n        activeTab = getActiveTab();\n        activeContent = getActiveContent();\n\n        hideCustomEvent = bootstrapCustomEvent('hide', 'tab', { relatedTarget: next });\n        dispatchCustomEvent.call(activeTab, hideCustomEvent);\n        if (hideCustomEvent.defaultPrevented) { return; }\n\n        tabs.isAnimating = true;\n        activeTab.classList.remove('active');\n        activeTab.setAttribute('aria-selected', 'false');\n        next.classList.add('active');\n        next.setAttribute('aria-selected', 'true');\n\n        if (dropdown) {\n          if (!element.parentNode.classList.contains('dropdown-menu')) {\n            if (dropdown.classList.contains('active')) { dropdown.classList.remove('active'); }\n          } else if (!dropdown.classList.contains('active')) { dropdown.classList.add('active'); }\n        }\n\n        if (activeContent.classList.contains('fade')) {\n          activeContent.classList.remove('show');\n          emulateTransitionEnd(activeContent, triggerHide);\n        } else { triggerHide(); }\n      }\n    };\n    self.dispose = function () {\n      element.removeEventListener('click', clickHandler, false);\n      delete element.Tab;\n    };\n\n    // INIT\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Tab) { element.Tab.dispose(); }\n\n    // DATA API\n    var heightData = element.getAttribute('data-height');\n    // event targets\n    tabs = element.closest('.nav');\n    dropdown = tabs && querySelector('.dropdown-toggle', tabs);\n\n    // instance options\n    var animateHeight = !(!supportTransition || (options.height === false || heightData === 'false'));\n\n    // set default animation state\n    tabs.isAnimating = false;\n\n    // init\n    if (!element.Tab) { // prevent adding event handlers twice\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    if (animateHeight) { tabsContentContainer = getActiveContent().parentNode; }\n\n    // associate target with init object\n    element.Tab = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Toast\n  -------------------------------------------- */\n\n  // TOAST DEFINITION\n  // ==================\n\n  function Toast(elem, opsInput) {\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // toast, timer\n    var toast;\n    var timer = 0;\n\n    // custom events\n    var showCustomEvent;\n    var hideCustomEvent;\n    var shownCustomEvent;\n    var hiddenCustomEvent;\n    var ops = {};\n\n    // private methods\n    function showComplete() {\n      toast.classList.remove('showing');\n      toast.classList.add('show');\n      dispatchCustomEvent.call(toast, shownCustomEvent);\n      if (ops.autohide) { self.hide(); }\n    }\n    function hideComplete() {\n      toast.classList.add('hide');\n      dispatchCustomEvent.call(toast, hiddenCustomEvent);\n    }\n    function close() {\n      toast.classList.remove('show');\n      if (ops.animation) { emulateTransitionEnd(toast, hideComplete); }\n      else { hideComplete(); }\n    }\n    function disposeComplete() {\n      clearTimeout(timer);\n      element.removeEventListener('click', self.hide, false);\n\n      delete element.Toast;\n    }\n\n    // public methods\n    self.show = function () {\n      if (toast && !toast.classList.contains('show')) {\n        dispatchCustomEvent.call(toast, showCustomEvent);\n        if (showCustomEvent.defaultPrevented) { return; }\n        if (ops.animation) { toast.classList.add('fade'); }\n        toast.classList.remove('hide');\n        reflow(toast); // force reflow\n        toast.classList.add('showing');\n\n        if (ops.animation) { emulateTransitionEnd(toast, showComplete); }\n        else { showComplete(); }\n      }\n    };\n    self.hide = function (noTimer) {\n      if (toast && toast.classList.contains('show')) {\n        dispatchCustomEvent.call(toast, hideCustomEvent);\n        if (hideCustomEvent.defaultPrevented) { return; }\n\n        if (noTimer) { close(); }\n        else { timer = setTimeout(close, ops.delay); }\n      }\n    };\n    self.dispose = function () {\n      if (ops.animation) { emulateTransitionEnd(toast, disposeComplete); }\n      else { disposeComplete(); }\n    };\n\n    // init\n\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Toast) { element.Toast.dispose(); }\n\n    // toast, timer\n    toast = element.closest('.toast');\n\n    // DATA API\n    var animationData = element.getAttribute('data-animation');\n    var autohideData = element.getAttribute('data-autohide');\n    var delayData = element.getAttribute('data-delay');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'toast');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'toast');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'toast');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'toast');\n\n    // set instance options\n    ops.animation = options.animation === false || animationData === 'false' ? 0 : 1; // true by default\n    ops.autohide = options.autohide === false || autohideData === 'false' ? 0 : 1; // true by default\n    ops.delay = parseInt((options.delay || delayData), 10) || 500; // 500ms default\n\n    if (!element.Toast) { // prevent adding event handlers twice\n      element.addEventListener('click', self.hide, false);\n    }\n\n    // associate targets to init object\n    element.Toast = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Tooltip\n  ---------------------------------------------- */\n\n  // TOOLTIP DEFINITION\n  // ==================\n\n  function Tooltip(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // tooltip, timer, and title\n    var tooltip = null;\n    var timer = 0;\n    var titleString;\n    var placementClass;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    var ops = {};\n\n    // private methods\n    function getTitle() {\n      return element.getAttribute('title')\n          || element.getAttribute('data-title')\n          || element.getAttribute('data-original-title');\n    }\n    function removeToolTip() {\n      ops.container.removeChild(tooltip);\n      tooltip = null; timer = null;\n    }\n    function createToolTip() {\n      titleString = getTitle(); // read the title again\n      if (titleString) { // invalidate, maybe markup changed\n        // create tooltip\n        tooltip = document.createElement('div');\n\n        // set markup\n        if (ops.template) {\n          var tooltipMarkup = document.createElement('div');\n          tooltipMarkup.innerHTML = ops.template.trim();\n\n          tooltip.className = tooltipMarkup.firstChild.className;\n          tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;\n\n          querySelector('.tooltip-inner', tooltip).innerHTML = titleString.trim();\n        } else {\n          // tooltip arrow\n          var tooltipArrow = document.createElement('div');\n          tooltipArrow.classList.add('arrow');\n          tooltip.appendChild(tooltipArrow);\n          // tooltip inner\n          var tooltipInner = document.createElement('div');\n          tooltipInner.classList.add('tooltip-inner');\n          tooltip.appendChild(tooltipInner);\n          tooltipInner.innerHTML = titleString;\n        }\n        // reset position\n        tooltip.style.left = '0';\n        tooltip.style.top = '0';\n        // set class and role attribute\n        tooltip.setAttribute('role', 'tooltip');\n        if (!tooltip.classList.contains('tooltip')) { tooltip.classList.add('tooltip'); }\n        if (!tooltip.classList.contains(ops.animation)) { tooltip.classList.add(ops.animation); }\n        if (!tooltip.classList.contains(placementClass)) { tooltip.classList.add(placementClass); }\n        // append to container\n        ops.container.appendChild(tooltip);\n      }\n    }\n    function updateTooltip() {\n      styleTip(element, tooltip, ops.placement, ops.container);\n    }\n    function showTooltip() {\n      if (!tooltip.classList.contains('show')) { tooltip.classList.add('show'); }\n    }\n    function touchHandler(e) {\n      if ((tooltip && tooltip.contains(e.target))\n        || e.target === element || element.contains(e.target)) ; else {\n        self.hide();\n      }\n    }\n    // triggers\n    function toggleAction(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      document[action]('touchstart', touchHandler, passiveHandler);\n      window[action]('resize', self.hide, passiveHandler);\n    }\n    function showAction() {\n      toggleAction(1);\n      dispatchCustomEvent.call(element, shownCustomEvent);\n    }\n    function hideAction() {\n      toggleAction();\n      removeToolTip();\n      dispatchCustomEvent.call(element, hiddenCustomEvent);\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action](mouseClickEvents.down, self.show, false);\n      element[action](mouseHoverEvents[0], self.show, false);\n      element[action](mouseHoverEvents[1], self.hide, false);\n    }\n\n    // public methods\n    self.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip === null) {\n          dispatchCustomEvent.call(element, showCustomEvent);\n          if (showCustomEvent.defaultPrevented) { return; }\n          // if(createToolTip() == false) return;\n          if (createToolTip() !== false) {\n            updateTooltip();\n            showTooltip();\n            if (ops.animation) { emulateTransitionEnd(tooltip, showAction); }\n            else { showAction(); }\n          }\n        }\n      }, 20);\n    };\n    self.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip && tooltip.classList.contains('show')) {\n          dispatchCustomEvent.call(element, hideCustomEvent);\n          if (hideCustomEvent.defaultPrevented) { return; }\n          tooltip.classList.remove('show');\n          if (ops.animation) { emulateTransitionEnd(tooltip, hideAction); }\n          else { hideAction(); }\n        }\n      }, ops.delay);\n    };\n    self.toggle = function () {\n      if (!tooltip) { self.show(); }\n      else { self.hide(); }\n    };\n    self.dispose = function () {\n      toggleEvents();\n      self.hide();\n      element.setAttribute('title', element.getAttribute('data-original-title'));\n      element.removeAttribute('data-original-title');\n      delete element.Tooltip;\n    };\n\n    // init\n    // initialization element\n    element = querySelector(elem);\n\n    // reset on re-init\n    if (element.Tooltip) { element.Tooltip.dispose(); }\n\n    // DATA API\n    var animationData = element.getAttribute('data-animation');\n    var placementData = element.getAttribute('data-placement');\n    var delayData = element.getAttribute('data-delay');\n    var containerData = element.getAttribute('data-container');\n\n    // check container\n    var containerElement = querySelector(options.container);\n    var containerDataElement = querySelector(containerData);\n\n    // maybe the element is inside a modal\n    var modal = element.closest('.modal');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'tooltip');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'tooltip');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'tooltip');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tooltip');\n\n    // maybe the element is inside a fixed navbar\n    var navbarFixedTop = element.closest('.fixed-top');\n    var navbarFixedBottom = element.closest('.fixed-bottom');\n\n    // set instance options\n    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';\n    ops.placement = options.placement ? options.placement : placementData || 'top';\n    ops.template = options.template ? options.template : null; // JavaScript only\n    ops.delay = parseInt((options.delay || delayData), 10) || 200;\n    ops.container = containerElement\n      || (containerDataElement\n        || (navbarFixedTop || (navbarFixedBottom || (modal || document.body))));\n\n    // set placement class\n    placementClass = \"bs-tooltip-\" + (ops.placement);\n\n    // set tooltip content\n    titleString = getTitle();\n\n    // invalidate\n    if (!titleString) { return; }\n\n    // prevent adding event handlers twice\n    if (!element.Tooltip) {\n      element.setAttribute('data-original-title', titleString);\n      element.removeAttribute('title');\n      toggleEvents(1);\n    }\n\n    // associate target to init object\n    element.Tooltip = self;\n  }\n\n  /** BSN v4 componentsInit */\n  var componentsInit = {};\n\n  /* Native JavaScript for Bootstrap v4 | Initialize Data API\n  -------------------------------------------------------- */\n  function initializeDataAPI(Constructor, collection) {\n    Array.from(collection).map(function (x) { return new Constructor(x); });\n  }\n  function initCallback(context) {\n    var lookUp = context instanceof Element ? context : document;\n    Object.keys(componentsInit).forEach(function (component) {\n      initializeDataAPI(componentsInit[component][0],\n        lookUp.querySelectorAll(componentsInit[component][1]));\n    });\n  }\n\n  componentsInit.Alert = [Alert, '[data-dismiss=\"alert\"]'];\n  componentsInit.Button = [Button, '[data-toggle=\"buttons\"]'];\n  componentsInit.Carousel = [Carousel, '[data-ride=\"carousel\"]'];\n  componentsInit.Collapse = [Collapse, '[data-toggle=\"collapse\"]'];\n  componentsInit.Dropdown = [Dropdown, '[data-toggle=\"dropdown\"]'];\n  componentsInit.Modal = [Modal, '[data-toggle=\"modal\"]'];\n  componentsInit.Popover = [Popover, '[data-toggle=\"popover\"],[data-tip=\"popover\"]'];\n  componentsInit.ScrollSpy = [ScrollSpy, '[data-spy=\"scroll\"]'];\n  componentsInit.Tab = [Tab, '[data-toggle=\"tab\"]'];\n  componentsInit.Toast = [Toast, '[data-dismiss=\"toast\"]'];\n  componentsInit.Tooltip = [Tooltip, '[data-toggle=\"tooltip\"],[data-tip=\"tooltip\"]'];\n\n  // bulk initialize all components\n  if (document.body) { initCallback(); }\n  else {\n    document.addEventListener('DOMContentLoaded', function initWrapper() {\n      initCallback();\n      document.removeEventListener('DOMContentLoaded', initWrapper, false);\n    }, false);\n  }\n\n  /* Native JavaScript for Bootstrap v4 | Remove Data API\n  ---------------------------------------------------- */\n  function removeElementDataAPI(ConstructorName, collection) {\n    Array.from(collection).map(function (x) { return x[ConstructorName].dispose(); });\n  }\n  function removeDataAPI(context) {\n    var lookUp = context instanceof Element ? context : document;\n    Object.keys(componentsInit).forEach(function (component) {\n      removeElementDataAPI(component, lookUp.querySelectorAll(componentsInit[component][1]));\n    });\n  }\n\n  var version = \"4.1.0\";\n\n  var Version = version;\n\n  var BSN = {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip,\n\n    initCallback: initCallback,\n    removeDataAPI: removeDataAPI,\n    componentsInit: componentsInit,\n    Version: Version,\n  };\n\n  return BSN;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ2tHO0FBQ3BHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEscUNBQXFDO0FBQ2xELGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFOztBQUVBO0FBQ0EsNENBQTRDLCtCQUErQjtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixrQkFBa0I7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEIsMERBQTBEO0FBQzFELDREQUE0RDs7QUFFNUQ7QUFDQSx1Q0FBdUM7QUFDdkMsa0RBQWtELFVBQVU7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLFVBQVU7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsUUFBUSxPQUFPOztBQUVmLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUMsd0JBQXdCO0FBQ3hCLHVCQUF1Qjs7QUFFdkIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9COztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsb0RBQW9ELHNDQUFzQztBQUMxRixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQztBQUNqQyxRQUFRO0FBQ1Isa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLHdDQUF3Qzs7QUFFeEMscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELCtDQUErQyxVQUFVOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQsNkNBQTZDLDBEQUEwRDtBQUN2RyxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7O0FBRUEseUJBQXlCOztBQUV6Qiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLE1BQU0sd0NBQXdDOztBQUU5QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSxvREFBb0Q7QUFDcEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSw4QkFBOEI7QUFDakc7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLHVFQUF1RSw4QkFBOEI7QUFDckc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1FQUFtRSw4QkFBOEI7QUFDakc7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsT0FBTzs7QUFFUCx1RUFBdUUsOEJBQThCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxlQUFlLE9BQU87QUFDckY7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrRUFBa0UsOEJBQThCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGVBQWUsT0FBTztBQUNwRTtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRSxnRUFBZ0UsOEJBQThCO0FBQzlGOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGlDQUFpQztBQUNqQzs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBMkQsd0JBQXdCLE9BQU87QUFDL0c7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxrQkFBa0I7O0FBRWpFO0FBQ0Esb0NBQW9DO0FBQ3BDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCLGFBQWEsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnQ0FBZ0M7QUFDaEM7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCx3REFBd0Q7QUFDeEQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsK0JBQStCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhFQUE4RTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsd0ZBQXdGLGdDQUFnQztBQUN4SDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVU7QUFDVixtQ0FBbUM7QUFDbkMsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdFQUFnRSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsMEJBQTBCO0FBQ3hGLGtFQUFrRSxxQkFBcUI7O0FBRXZGO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUEsZ0VBQWdFLHFCQUFxQjtBQUNyRjtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELFlBQVksbURBQW1EO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsNkJBQTZCO0FBQzdCO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBLDZCQUE2QjtBQUM3QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQsdUJBQXVCO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RixtRkFBbUY7QUFDbkYsbUVBQW1FOztBQUVuRSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCwwREFBMEQ7QUFDMUQsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsK0JBQStCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS12NC5qcz9jOWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICAqIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgdjQuMS4wIChodHRwczovL3RoZWRucC5naXRodWIuaW8vYm9vdHN0cmFwLm5hdGl2ZS8pXG4gICogQ29weXJpZ2h0IDIwMTUtMjAyMiDCqSBkbnBfdGhlbWVcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90aGVkbnAvYm9vdHN0cmFwLm5hdGl2ZS9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQlNOID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQSBnbG9iYWwgbmFtZXNwYWNlIGZvciBgZG9jdW1lbnQuaGVhZGAuXG4gICAqL1xuICB2YXIgZG9jdW1lbnRIZWFkID0gZG9jdW1lbnQuaGVhZDtcblxuICAvKipcbiAgICogQSBnbG9iYWwgYGJvb2xlYW5gIGZvciBDU1MzIHRyYW5zaXRpb24gc3VwcG9ydC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgc3VwcG9ydFRyYW5zaXRpb24gPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnRIZWFkLnN0eWxlIHx8ICd0cmFuc2l0aW9uJyBpbiBkb2N1bWVudEhlYWQuc3R5bGU7XG5cbiAgLyoqXG4gICAqIEEgZ2xvYmFsIG5hbWVzcGFjZSBmb3IgJ3RyYW5zaXRpb25lbmQnIHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnRIZWFkLnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xuXG4gIC8qKlxuICAgKiBBIGdsb2JhbCBuYW1lc3BhY2UgZm9yICd0cmFuc2l0aW9uRGVsYXknIHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHZhciB0cmFuc2l0aW9uRGVsYXkgPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnRIZWFkLnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25EZWxheScgOiAndHJhbnNpdGlvbkRlbGF5JztcblxuICAvKipcbiAgICogQSBnbG9iYWwgbmFtZXNwYWNlIGZvcjpcbiAgICogKiBgdHJhbnNpdGlvblByb3BlcnR5YCBzdHJpbmcgZm9yIG1vZGVybiBicm9zZXJzLFxuICAgKiAqIGB3ZWJraXRUcmFuc2l0aW9uYCBmb3IgbGVnYWN5IENocm9tZSAvIFNhZmFyaSBicm93c2Vyc1xuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudEhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvblByb3BlcnR5JyA6ICd0cmFuc2l0aW9uUHJvcGVydHknO1xuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCBmb3IgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnByb3BlcnR5TmFtZWBcbiAgICogc3RhdGljIG1ldGhvZC5cbiAgICpcbiAgICogKiBJZiBgZWxlbWVudGAgcGFyYW1ldGVyIGlzIG5vdCBhbiBgSFRNTEVsZW1lbnRgLCBgZ2V0Q29tcHV0ZWRTdHlsZWBcbiAgICogdGhyb3dzIGEgYFJlZmVyZW5jZUVycm9yYC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEVsZW1lbnR9IGVsZW1lbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSB0aGUgY3NzIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNzcyBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgLy8gQHRzLWlnbm9yZSAtLSBtdXN0IHVzZSBjYW1lbGNhc2Ugc3RyaW5ncyxcbiAgICAvLyBvciBub24tY2FtZWxjYXNlIHN0cmluZ3Mgd2l0aCBgZ2V0UHJvcGVydHlWYWx1ZWBcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gY29tcHV0ZWRTdHlsZSA/IGNvbXB1dGVkU3R5bGVbcHJvcGVydHldIDogJyc7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSB0byBnZXQgdGhlIGNvbXB1dGVkIGB0cmFuc2l0aW9uRGVsYXlgXG4gICAqIGZyb20gRWxlbWVudCBpbiBtaWxpc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEVsZW1lbnR9IGVsZW1lbnQgdGFyZ2V0XG4gICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHZhbHVlIGluIG1pbGlzZWNvbmRzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNpdGlvbkRlbGF5KGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCB0cmFuc2l0aW9uUHJvcGVydHkpO1xuICAgIHZhciBkZWxheVZhbHVlID0gZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIHRyYW5zaXRpb25EZWxheSk7XG4gICAgdmFyIGRlbGF5U2NhbGUgPSBkZWxheVZhbHVlLmluY2x1ZGVzKCdtcycpID8gMSA6IDEwMDA7XG4gICAgdmFyIGR1cmF0aW9uID0gc3VwcG9ydFRyYW5zaXRpb24gJiYgcHJvcGVydHlWYWx1ZSAmJiBwcm9wZXJ0eVZhbHVlICE9PSAnbm9uZSdcbiAgICAgID8gcGFyc2VGbG9hdChkZWxheVZhbHVlKSAqIGRlbGF5U2NhbGUgOiAwO1xuXG4gICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZHVyYXRpb24pID8gZHVyYXRpb24gOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2xvYmFsIG5hbWVzcGFjZSBmb3IgJ3RyYW5zaXRpb25EdXJhdGlvbicgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudEhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJyA6ICd0cmFuc2l0aW9uRHVyYXRpb24nO1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IHRvIGdldCB0aGUgY29tcHV0ZWQgYHRyYW5zaXRpb25EdXJhdGlvbmBcbiAgICogZnJvbSBFbGVtZW50IGluIG1pbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgRWxlbWVudH0gZWxlbWVudCB0YXJnZXRcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgdmFsdWUgaW4gbWlsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCkge1xuICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIHRyYW5zaXRpb25Qcm9wZXJ0eSk7XG4gICAgdmFyIGR1cmF0aW9uVmFsdWUgPSBnZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB2YXIgZHVyYXRpb25TY2FsZSA9IGR1cmF0aW9uVmFsdWUuaW5jbHVkZXMoJ21zJykgPyAxIDogMTAwMDtcbiAgICB2YXIgZHVyYXRpb24gPSBzdXBwb3J0VHJhbnNpdGlvbiAmJiBwcm9wZXJ0eVZhbHVlICYmIHByb3BlcnR5VmFsdWUgIT09ICdub25lJ1xuICAgICAgPyBwYXJzZUZsb2F0KGR1cmF0aW9uVmFsdWUpICogZHVyYXRpb25TY2FsZSA6IDA7XG5cbiAgICByZXR1cm4gIU51bWJlci5pc05hTihkdXJhdGlvbikgPyBkdXJhdGlvbiA6IDA7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSB0byBtYWtlIHN1cmUgY2FsbGJhY2tzIGFyZSBjb25zaXN0ZW50bHlcbiAgICogY2FsbGVkIHdoZW4gdHJhbnNpdGlvbiBlbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgRWxlbWVudH0gZWxlbWVudCB0YXJnZXRcbiAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBoYW5kbGVyIGB0cmFuc2l0aW9uZW5kYCBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgaGFuZGxlcikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBlbmRFdmVudCA9IG5ldyBFdmVudCh0cmFuc2l0aW9uRW5kRXZlbnQpO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCk7XG4gICAgdmFyIGRlbGF5ID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EZWxheShlbGVtZW50KTtcblxuICAgIGlmIChzdXBwb3J0VHJhbnNpdGlvbiAmJiBkdXJhdGlvbikge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIHRoZSBoYW5kbGVyIGluIG9uIC0+IG9mZiBjYWxsYmFja1xuICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgdmFyIHRyYW5zaXRpb25FbmRXcmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgaGFuZGxlci5hcHBseShlbGVtZW50LCBbZV0pO1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIHRyYW5zaXRpb25FbmRXcmFwcGVyKTtcbiAgICAgICAgICBjYWxsZWQgPSAxO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdHJhbnNpdGlvbkVuZFdyYXBwZXIpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7IGVsZW1lbnQuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7IH1cbiAgICAgIH0sIGR1cmF0aW9uICsgZGVsYXkgKyAxNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIuYXBwbHkoZWxlbWVudCwgW2VuZEV2ZW50XSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBkb2N1bWVudGAgb3IgdGhlIGAjZG9jdW1lbnRgIGVsZW1lbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpXG4gICAqIEBwYXJhbSB7KE5vZGUgfCBIVE1MRWxlbWVudCB8IEVsZW1lbnQgfCBnbG9iYWxUaGlzKT19IG5vZGVcbiAgICogQHJldHVybnMge0RvY3VtZW50fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDsgfVxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgV2luZG93KSB7IHJldHVybiBub2RlLmRvY3VtZW50OyB9XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdsb2JhbCBhcnJheSBvZiBwb3NzaWJsZSBgUGFyZW50Tm9kZWAuXG4gICAqL1xuICB2YXIgcGFyZW50Tm9kZXMgPSBbRG9jdW1lbnQsIEVsZW1lbnQsIEhUTUxFbGVtZW50XTtcblxuICAvKipcbiAgICogQSBnbG9iYWwgYXJyYXkgd2l0aCBgRWxlbWVudGAgfCBgSFRNTEVsZW1lbnRgLlxuICAgKi9cbiAgdmFyIGVsZW1lbnROb2RlcyA9IFtFbGVtZW50LCBIVE1MRWxlbWVudF07XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgdG8gY2hlY2sgaWYgdGFyZ2V0IGlzIHR5cGVvZiBgSFRNTEVsZW1lbnRgLCBgRWxlbWVudGAsIGBOb2RlYFxuICAgKiBvciBmaW5kIG9uZSB0aGF0IG1hdGNoZXMgYSBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEVsZW1lbnQgfCBzdHJpbmd9IHNlbGVjdG9yIHRoZSBpbnB1dCBzZWxlY3RvciBvciB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0geyhIVE1MRWxlbWVudCB8IEVsZW1lbnQgfCBEb2N1bWVudCk9fSBwYXJlbnQgb3B0aW9uYWwgbm9kZSB0byBsb29rIGludG9cbiAgICogQHJldHVybiB7KEhUTUxFbGVtZW50IHwgRWxlbWVudCk/fSB0aGUgYEhUTUxFbGVtZW50YCBvciBgcXVlcnlTZWxlY3RvcmAgcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgICB2YXIgbG9va1VwID0gcGFyZW50Tm9kZXMuc29tZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyZW50IGluc3RhbmNlb2YgeDsgfSlcbiAgICAgID8gcGFyZW50IDogZ2V0RG9jdW1lbnQoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZWxlbWVudE5vZGVzLnNvbWUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHNlbGVjdG9yIGluc3RhbmNlb2YgeDsgfSlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgID8gc2VsZWN0b3IgOiBsb29rVXAucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cblxuICAvKiogQlNOIHY0IGN1c3RvbSBldmVudCAqL1xuICBmdW5jdGlvbiBib290c3RyYXBDdXN0b21FdmVudChldmVudFR5cGUsIGNvbXBvbmVudE5hbWUsIGV2ZW50UHJvcGVydGllcykge1xuICAgIHZhciBPcmlnaW5hbEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KChldmVudFR5cGUgKyBcIi5icy5cIiArIGNvbXBvbmVudE5hbWUpLCB7IGNhbmNlbGFibGU6IHRydWUgfSk7XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50UHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV2ZW50UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmlnaW5hbEN1c3RvbUV2ZW50LCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnRQcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPcmlnaW5hbEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcXVpY2sgc2hvcnRjdXQgZm9yIGBkaXNwYXRjaEV2ZW50YCB2NC5cbiAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgdGhlIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2hDdXN0b21FdmVudChjdXN0b21FdmVudCkge1xuICAgIGlmICh0aGlzKSB7IHRoaXMuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7IH1cbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEFsZXJ0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gQUxFUlQgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gQWxlcnQoZWxlbSkge1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHRoZSB0YXJnZXQgYWxlcnRcbiAgICB2YXIgYWxlcnQ7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIGNsb3NlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2xvc2UnLCAnYWxlcnQnKTtcbiAgICB2YXIgY2xvc2VkQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2xvc2VkJywgJ2FsZXJ0Jyk7XG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcigpIHtcbiAgICAgIGlmIChhbGVydC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSkgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZChhbGVydCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpOyB9XG4gICAgICBlbHNlIHsgdHJhbnNpdGlvbkVuZEhhbmRsZXIoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIGFsZXJ0ID0gZSAmJiBlLnRhcmdldC5jbG9zZXN0KCcuYWxlcnQnKTtcbiAgICAgIGVsZW1lbnQgPSBxdWVyeVNlbGVjdG9yKCdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nLCBhbGVydCk7XG4gICAgICBpZiAoZWxlbWVudCAmJiBhbGVydCAmJiAoZWxlbWVudCA9PT0gZS50YXJnZXQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpKSB7IHNlbGYuY2xvc2UoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcigpIHtcbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgICAgYWxlcnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhbGVydCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlZEN1c3RvbUV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBQVUJMSUMgTUVUSE9EU1xuICAgIHNlbGYuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWxlcnQgJiYgZWxlbWVudCAmJiBhbGVydC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoY2xvc2VDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgICBzZWxmLmRpc3Bvc2UoKTtcbiAgICAgICAgYWxlcnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICB0cmlnZ2VySGFuZGxlcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LkFsZXJ0O1xuICAgIH07XG5cbiAgICAvLyBJTklUXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeVNlbGVjdG9yKGVsZW0pO1xuXG4gICAgLy8gZmluZCB0aGUgdGFyZ2V0IGFsZXJ0XG4gICAgYWxlcnQgPSBlbGVtZW50LmNsb3Nlc3QoJy5hbGVydCcpO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LkFsZXJ0KSB7IGVsZW1lbnQuQWxlcnQuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgIGlmICghZWxlbWVudC5BbGVydCkgeyB0b2dnbGVFdmVudHMoMSk7IH1cblxuICAgIC8vIHN0b3JlIGluaXQgb2JqZWN0IHdpdGhpbiB0YXJnZXQgZWxlbWVudFxuICAgIHNlbGYuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudC5BbGVydCA9IHNlbGY7XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBCdXR0b25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBCVVRUT04gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIEJ1dHRvbihlbGVtKSB7XG4gICAgdmFyIGVsZW1lbnQ7XG5cbiAgICAvLyBiaW5kIGFuZCBsYWJlbHNcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhYmVscztcblxuICAgIC8vIGNoYW5nZUV2ZW50XG4gICAgdmFyIGNoYW5nZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2NoYW5nZScsICdidXR0b24nKTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgICB2YXIgZVRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIHBhcmVudExhYmVsID0gZVRhcmdldC5jbG9zZXN0KCdMQUJFTCcpOyAvLyB0aGUgLmJ0biBsYWJlbFxuICAgICAgdmFyIGxhYmVsID0gbnVsbDtcblxuICAgICAgaWYgKGVUYXJnZXQudGFnTmFtZSA9PT0gJ0xBQkVMJykge1xuICAgICAgICBsYWJlbCA9IGVUYXJnZXQ7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudExhYmVsKSB7XG4gICAgICAgIGxhYmVsID0gcGFyZW50TGFiZWw7XG4gICAgICB9XG5cbiAgICAgIC8vIGN1cnJlbnQgaW5wdXRcbiAgICAgIHZhciBpbnB1dCA9IGxhYmVsICYmIGxhYmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdO1xuXG4gICAgICAvLyBpbnZhbGlkYXRlIGlmIG5vIGlucHV0XG4gICAgICBpZiAoIWlucHV0KSB7IHJldHVybjsgfVxuXG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoaW5wdXQsIGNoYW5nZUN1c3RvbUV2ZW50KTsgLy8gdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgaW5wdXRcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBjaGFuZ2VDdXN0b21FdmVudCk7IC8vIHRyaWdnZXIgdGhlIGNoYW5nZSBmb3IgdGhlIGJ0bi1ncm91cFxuXG4gICAgICAvLyBtYW5hZ2UgdGhlIGRvbSBtYW5pcHVsYXRpb25cbiAgICAgIGlmIChpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7IC8vIGNoZWNrYm94ZXNcbiAgICAgICAgaWYgKGNoYW5nZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9IC8vIGRpc2NvbnRpbnVlIHdoZW4gZGVmYXVsdFByZXZlbnRlZCBpcyB0cnVlXG5cbiAgICAgICAgaWYgKCFpbnB1dC5jaGVja2VkKSB7XG4gICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgaW5wdXQuZ2V0QXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVsZW1lbnQudG9nZ2xlZCkgeyAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIGV2ZW50IHR3aWNlXG4gICAgICAgICAgZWxlbWVudC50b2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJyAmJiAhZWxlbWVudC50b2dnbGVkKSB7IC8vIHJhZGlvIGJ1dHRvbnNcbiAgICAgICAgaWYgKGNoYW5nZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgYWxyZWFkeSBhY3RpdmVcbiAgICAgICAgLy8gKHRoZSBPUiBjb25kaXRpb24gaXMgYSBoYWNrIHRvIGNoZWNrIGlmIHRoZSBidXR0b25zIHdlcmUgc2VsZWN0ZWRcbiAgICAgICAgLy8gd2l0aCBrZXkgcHJlc3MgYW5kIE5PVCBtb3VzZSBjbGljaylcbiAgICAgICAgaWYgKCFpbnB1dC5jaGVja2VkIHx8IChlLnNjcmVlblggPT09IDAgJiYgZS5zY3JlZW5ZID09PSAwKSkge1xuICAgICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzJyk7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGVsZW1lbnQudG9nZ2xlZCA9IHRydWU7XG4gICAgICAgICAgQXJyYXkuZnJvbShsYWJlbHMpLmZvckVhY2goZnVuY3Rpb24gKG90aGVyTGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBvdGhlcklucHV0ID0gb3RoZXJMYWJlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU5QVVQnKVswXTtcbiAgICAgICAgICAgIGlmIChvdGhlckxhYmVsICE9PSBsYWJlbCAmJiBvdGhlckxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG90aGVySW5wdXQsIGNoYW5nZUN1c3RvbUV2ZW50KTsgLy8gdHJpZ2dlciB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgIG90aGVyTGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgIG90aGVySW5wdXQucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgICAgICAgIG90aGVySW5wdXQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZWxlbWVudC50b2dnbGVkID0gZmFsc2U7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgaWYgKGtleSA9PT0gMzIgJiYgZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHsgdG9nZ2xlKGUpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGwoZSkge1xuICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgaWYgKGtleSA9PT0gMzIpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvY3VzVG9nZ2xlKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBlLnR5cGUgPT09ICdmb2N1c2luJyA/ICdhZGQnIDogJ3JlbW92ZSc7XG4gICAgICAgIGUudGFyZ2V0LmNsb3Nlc3QoJy5idG4nKS5jbGFzc0xpc3RbYWN0aW9uXSgnZm9jdXMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFkZCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLCB0b2dnbGUsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgna2V5dXAnLCBrZXlIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oJ2tleWRvd24nLCBwcmV2ZW50U2Nyb2xsLCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oJ2ZvY3VzaW4nLCBmb2N1c1RvZ2dsZSwgZmFsc2UpO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCdmb2N1c291dCcsIGZvY3VzVG9nZ2xlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuQnV0dG9uO1xuICAgIH07XG5cbiAgICAvLyBpbml0XG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeVNlbGVjdG9yKGVsZW0pO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LkJ1dHRvbikgeyBlbGVtZW50LkJ1dHRvbi5kaXNwb3NlKCk7IH1cblxuICAgIGxhYmVscyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYnRuJyk7XG5cbiAgICAvLyBpbnZhbGlkYXRlXG4gICAgaWYgKCFsYWJlbHMubGVuZ3RoKSB7IHJldHVybjsgfVxuXG4gICAgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICBpZiAoIWVsZW1lbnQuQnV0dG9uKSB7IHRvZ2dsZUV2ZW50cygxKTsgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdG9nZ2xlZCBzdGF0ZVxuICAgIC8vIHRvZ2dsZWQgbWFrZXMgc3VyZSB0byBwcmV2ZW50IHRyaWdnZXJpbmcgdHdpY2UgdGhlIGNoYW5nZS5icy5idXR0b24gZXZlbnRzXG4gICAgZWxlbWVudC50b2dnbGVkID0gZmFsc2U7XG5cbiAgICAvLyBhc3NvY2lhdGUgdGFyZ2V0IHdpdGggaW5pdCBvYmplY3RcbiAgICBlbGVtZW50LkJ1dHRvbiA9IHNlbGY7XG5cbiAgICAvLyBhY3RpdmF0ZSBpdGVtcyBvbiBsb2FkXG4gICAgQXJyYXkuZnJvbShsYWJlbHMpLmZvckVhY2goZnVuY3Rpb24gKGJ0bikge1xuICAgICAgdmFyIGhhc0NoZWNrZWQgPSBxdWVyeVNlbGVjdG9yKCdpbnB1dDpjaGVja2VkJywgYnRuKTtcbiAgICAgIGlmICghYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgaGFzQ2hlY2tlZCkge1xuICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgIWhhc0NoZWNrZWQpIHtcbiAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2xvYmFsIG5hbWVzcGFjZSBmb3IgbW91c2UgaG92ZXIgZXZlbnRzLlxuICAgKiBAdHlwZSB7W3N0cmluZywgc3RyaW5nXX1cbiAgICovXG4gIHZhciBtb3VzZUhvdmVyRXZlbnRzID0gKCdvbm1vdXNlbGVhdmUnIGluIGRvY3VtZW50KSA/IFsnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10gOiBbJ21vdXNlb3ZlcicsICdtb3VzZW91dCddO1xuXG4gIC8qKlxuICAgKiBBIGdsb2JhbCBuYW1lc3BhY2UgZm9yIG1vc3Qgc2Nyb2xsIGV2ZW50IGxpc3RlbmVycy5cbiAgICogQHR5cGUge1BhcnRpYWw8QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnM+fVxuICAgKi9cbiAgdmFyIHBhc3NpdmVIYW5kbGVyID0geyBwYXNzaXZlOiB0cnVlIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGEgdGFyZ2V0IGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBFbGVtZW50fSBlbGVtZW50IGV2ZW50LnRhcmdldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlU2NhbGUgd2hlbiAqdHJ1ZSosIHRoZSB0YXJnZXQgc2NhbGUgaXMgYWxzbyBjb21wdXRlZFxuICAgKiBAcmV0dXJucyB7U0hPUlRFUi5Cb3VuZGluZ0NsaWVudFJlY3R9IHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUpIHtcbiAgICB2YXIgcmVmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIHRvcCA9IHJlZi50b3A7XG4gICAgdmFyIHJpZ2h0ID0gcmVmLnJpZ2h0O1xuICAgIHZhciBib3R0b20gPSByZWYuYm90dG9tO1xuICAgIHZhciBsZWZ0ID0gcmVmLmxlZnQ7XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAoaW5jbHVkZVNjYWxlICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdmFyIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIHNjYWxlWCA9IG9mZnNldFdpZHRoID4gMCA/IE1hdGgucm91bmQod2lkdGgpIC8gb2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgICBzY2FsZVkgPSBvZmZzZXRIZWlnaHQgPiAwID8gTWF0aC5yb3VuZChoZWlnaHQpIC8gb2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGggLyBzY2FsZVgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCAvIHNjYWxlWSxcbiAgICAgIHRvcDogdG9wIC8gc2NhbGVZLFxuICAgICAgcmlnaHQ6IHJpZ2h0IC8gc2NhbGVYLFxuICAgICAgYm90dG9tOiBib3R0b20gLyBzY2FsZVksXG4gICAgICBsZWZ0OiBsZWZ0IC8gc2NhbGVYLFxuICAgICAgeDogbGVmdCAvIHNjYWxlWCxcbiAgICAgIHk6IHRvcCAvIHNjYWxlWSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIG9yIHRoZSBgPGh0bWw+YCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyhOb2RlIHwgSFRNTEVsZW1lbnQgfCBFbGVtZW50IHwgZ2xvYmFsVGhpcyk9fSBub2RlXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IEhUTUxIdG1sRWxlbWVudH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIGdldERvY3VtZW50KG5vZGUpLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IHRvIGRldGVybWluZSBpZiBhbiBgSFRNTEVsZW1lbnRgXG4gICAqIGlzIHBhcnRpYWxseSB2aXNpYmxlIGluIHZpZXdwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgRWxlbWVudH0gZWxlbWVudCB0YXJnZXRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHF1ZXJ5IHJlc3VsdFxuICAgKi9cbiAgdmFyIGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciByZWYgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgdmFyIHRvcCA9IHJlZi50b3A7XG4gICAgdmFyIGJvdHRvbSA9IHJlZi5ib3R0b207XG4gICAgdmFyIHJlZiQxID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgIHZhciBjbGllbnRIZWlnaHQgPSByZWYkMS5jbGllbnRIZWlnaHQ7XG4gICAgLy8gY2hlY2tzIGJvdHRvbSAmJiB0b3BcbiAgICByZXR1cm4gdG9wIDw9IGNsaWVudEhlaWdodCAmJiBib3R0b20gPj0gMDtcbiAgfTtcblxuICAvKipcbiAgICogVXRpbGl0eSB0byBmb3JjZSByZS1wYWludCBvZiBhbiBgSFRNTEVsZW1lbnRgIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEVsZW1lbnR9IGVsZW1lbnQgaXMgdGhlIHRhcmdldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBgRWxlbWVudC5vZmZzZXRIZWlnaHRgIHZhbHVlXG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIHZhciByZWZsb3cgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7IH07XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgQ2Fyb3VzZWxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBDQVJPVVNFTCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtLCBvcHNJbnB1dCkge1xuICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMjtcblxuICAgIHZhciBlbGVtZW50O1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGludGVybmFsIHZhcmlhYmxlc1xuICAgIHZhciB2YXJzO1xuICAgIHZhciBvcHM7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNsaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIHNsaWRDdXN0b21FdmVudDtcblxuICAgIC8vIGNhcm91c2VsIGVsZW1lbnRzXG4gICAgdmFyIHNsaWRlcztcbiAgICB2YXIgbGVmdEFycm93O1xuICAgIHZhciByaWdodEFycm93O1xuICAgIHZhciBpbmRpY2F0b3I7XG4gICAgdmFyIGluZGljYXRvcnM7XG5cbiAgICAvLyBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIHBhdXNlSGFuZGxlcigpIHtcbiAgICAgIGlmIChvcHMuaW50ZXJ2YWwgIT09IGZhbHNlICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYXVzZWQnKTtcbiAgICAgICAgaWYgKCF2YXJzLmlzU2xpZGluZykge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG4gICAgICAgICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdW1lSGFuZGxlcigpIHtcbiAgICAgIGlmIChvcHMuaW50ZXJ2YWwgIT09IGZhbHNlICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BhdXNlZCcpO1xuICAgICAgICBpZiAoIXZhcnMuaXNTbGlkaW5nKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgICAgICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kaWNhdG9ySGFuZGxlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBldmVudFRhcmdldCA9IGUudGFyZ2V0OyAvLyBldmVudCB0YXJnZXQgfCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuXG4gICAgICBpZiAoZXZlbnRUYXJnZXQgJiYgIWV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykpIHtcbiAgICAgICAgdmFycy5pbmRleCA9ICsoZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykpO1xuICAgICAgfSBlbHNlIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuc2xpZGVUbyh2YXJzLmluZGV4KTsgLy8gRG8gdGhlIHNsaWRlXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRyb2xzSGFuZGxlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBldmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgIGlmIChldmVudFRhcmdldCA9PT0gcmlnaHRBcnJvdykge1xuICAgICAgICB2YXJzLmluZGV4ICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VGFyZ2V0ID09PSBsZWZ0QXJyb3cpIHtcbiAgICAgICAgdmFycy5pbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnNsaWRlVG8odmFycy5pbmRleCk7IC8vIERvIHRoZSBzbGlkZVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlIYW5kbGVyKHJlZikge1xuICAgICAgdmFyIHdoaWNoID0gcmVmLndoaWNoO1xuXG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgICBzd2l0Y2ggKHdoaWNoKSB7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgdmFycy5pbmRleCArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIHZhcnMuaW5kZXggLT0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZi5zbGlkZVRvKHZhcnMuaW5kZXgpOyAvLyBEbyB0aGUgc2xpZGVcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFkZCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGlmIChvcHMucGF1c2UgJiYgb3BzLmludGVydmFsKSB7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzBdLCBwYXVzZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMV0sIHJlc3VtZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKCd0b3VjaHN0YXJ0JywgcGF1c2VIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXSgndG91Y2hlbmQnLCByZXN1bWVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHMudG91Y2ggJiYgc2xpZGVzLmxlbmd0aCA+IDEpIHsgZWxlbWVudFthY3Rpb25dKCd0b3VjaHN0YXJ0JywgdG91Y2hEb3duSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpOyB9XG5cbiAgICAgIGlmIChyaWdodEFycm93KSB7IHJpZ2h0QXJyb3dbYWN0aW9uXSgnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsIGZhbHNlKTsgfVxuICAgICAgaWYgKGxlZnRBcnJvdykgeyBsZWZ0QXJyb3dbYWN0aW9uXSgnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsIGZhbHNlKTsgfVxuXG4gICAgICBpZiAoaW5kaWNhdG9yKSB7IGluZGljYXRvclthY3Rpb25dKCdjbGljaycsIGluZGljYXRvckhhbmRsZXIsIGZhbHNlKTsgfVxuICAgICAgaWYgKG9wcy5rZXlib2FyZCkgeyB3aW5kb3dbYWN0aW9uXSgna2V5ZG93bicsIGtleUhhbmRsZXIsIGZhbHNlKTsgfVxuICAgIH1cbiAgICAvLyB0b3VjaCBldmVudHNcbiAgICBmdW5jdGlvbiB0b2dnbGVUb3VjaEV2ZW50cyhhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oJ3RvdWNobW92ZScsIHRvdWNoTW92ZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgndG91Y2hlbmQnLCB0b3VjaEVuZEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hEb3duSGFuZGxlcihlKSB7XG4gICAgICBpZiAodmFycy5pc1RvdWNoKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblxuICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgIHZhcnMuaXNUb3VjaCA9IHRydWU7XG4gICAgICAgIHRvZ2dsZVRvdWNoRXZlbnRzKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaE1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIGlmICghdmFycy5pc1RvdWNoKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuOyB9XG5cbiAgICAgIHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cbiAgICAgIC8vIGNhbmNlbCB0b3VjaCBpZiBtb3JlIHRoYW4gb25lIGNoYW5nZWRUb3VjaGVzIGRldGVjdGVkXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaEVuZEhhbmRsZXIoZSkge1xuICAgICAgaWYgKCF2YXJzLmlzVG91Y2ggfHwgdmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhcnMudG91Y2hQb3NpdGlvbi5lbmRYID0gdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cbiAgICAgIGlmICh2YXJzLmlzVG91Y2gpIHtcbiAgICAgICAgaWYgKCghZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgIWVsZW1lbnQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICYmIE1hdGguYWJzKHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggLSB2YXJzLnRvdWNoUG9zaXRpb24uZW5kWCkgPCA3NSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIDwgdmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCkge1xuICAgICAgICAgIHZhcnMuaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggPiB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYKSB7XG4gICAgICAgICAgdmFycy5pbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMuaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNsaWRlVG8odmFycy5pbmRleCk7XG5cbiAgICAgICAgdG9nZ2xlVG91Y2hFdmVudHMoKTsgLy8gcmVtb3ZlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIHNldEFjdGl2ZVBhZ2UocGFnZUluZGV4KSB7IC8vIGluZGljYXRvcnNcbiAgICAgIEFycmF5LmZyb20oaW5kaWNhdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgfSk7XG4gICAgICBpZiAoaW5kaWNhdG9yc1twYWdlSW5kZXhdKSB7IGluZGljYXRvcnNbcGFnZUluZGV4XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcihlKSB7XG4gICAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdmFycy5pbmRleDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBlICYmIGUudGFyZ2V0ICE9PSBzbGlkZXNbbmV4dF0gPyBlLmVsYXBzZWRUaW1lICogMTAwMCArIDEwMCA6IDIwO1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcblxuICAgICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh2YXJzLnRvdWNoUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgdmFycy5pc1NsaWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgICAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgICAgICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgICAgICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcblxuICAgICAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZEN1c3RvbUV2ZW50KTtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVsZW1lbnQsIG1pZ2h0IGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBvcHMuaW50ZXJ2YWwgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBzZWxmLmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZhcnMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhcnMudGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB2YXJzLmluZGV4IHx8IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UoZWxlbWVudCkpIHtcbiAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICBzZWxmLnNsaWRlVG8oaWR4KTtcbiAgICAgICAgfVxuICAgICAgfSwgb3BzLmludGVydmFsKTtcbiAgICB9O1xuICAgIHNlbGYuc2xpZGVUbyA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH0gLy8gd2hlbiBjb250cm9sZWQgdmlhIG1ldGhvZHMsIG1ha2Ugc3VyZSB0byBjaGVjayBhZ2FpblxuXG4gICAgICAvLyB0aGUgY3VycmVudCBhY3RpdmUsIG9yaWVudGF0aW9uLCBldmVudCBldmVudFByb3BlcnRpZXNcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gc2VsZi5nZXRBY3RpdmVJbmRleCgpO1xuICAgICAgdmFyIG5leHQgPSBpZHg7XG5cbiAgICAgIC8vIGZpcnN0IHJldHVybiBpZiB3ZSdyZSBvbiB0aGUgc2FtZSBpdGVtICMyMjdcbiAgICAgIGlmIChhY3RpdmVJdGVtID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIC8vIG9yIGRldGVybWluZSBzbGlkZSBkaXJlY3Rpb25cbiAgICAgIH0gaWYgKChhY3RpdmVJdGVtIDwgbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IDAgJiYgbmV4dCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ2xlZnQnOyAvLyBuZXh0XG4gICAgICB9IGVsc2UgaWYgKChhY3RpdmVJdGVtID4gbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IHNsaWRlcy5sZW5ndGggLSAxICYmIG5leHQgPT09IDApKSB7XG4gICAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ3JpZ2h0JzsgLy8gcHJldlxuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIHRoZSByaWdodCBuZXh0IGluZGV4XG4gICAgICBpZiAobmV4dCA8IDApIHsgbmV4dCA9IHNsaWRlcy5sZW5ndGggLSAxOyB9XG4gICAgICBlbHNlIGlmIChuZXh0ID49IHNsaWRlcy5sZW5ndGgpIHsgbmV4dCA9IDA7IH1cblxuICAgICAgdmFyIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JzsgLy8gZGV0ZXJtaW5lIHR5cGVcblxuICAgICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogc2xpZGVzW25leHRdLCBkaXJlY3Rpb246IHZhcnMuZGlyZWN0aW9uLCBmcm9tOiBhY3RpdmVJdGVtLCB0bzogbmV4dCxcbiAgICAgIH07XG4gICAgICBzbGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3NsaWRlJywgJ2Nhcm91c2VsJywgZXZlbnRQcm9wZXJ0aWVzKTtcbiAgICAgIHNsaWRDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzbGlkJywgJ2Nhcm91c2VsJywgZXZlbnRQcm9wZXJ0aWVzKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkZUN1c3RvbUV2ZW50KTsgLy8gaGVyZSB3ZSBnbyB3aXRoIHRoZSBzbGlkZVxuICAgICAgaWYgKHNsaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH0gLy8gZGlzY29udGludWUgd2hlbiBwcmV2ZW50ZWRcblxuICAgICAgLy8gdXBkYXRlIGluZGV4XG4gICAgICB2YXJzLmluZGV4ID0gbmV4dDtcblxuICAgICAgdmFycy5pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgIHZhcnMudGltZXIgPSBudWxsO1xuICAgICAgc2V0QWN0aXZlUGFnZShuZXh0KTtcblxuICAgICAgaWYgKGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oc2xpZGVzW25leHRdKSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2xpZGUnKSkge1xuICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgICAgcmVmbG93KHNsaWRlc1tuZXh0XSk7XG4gICAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG5cbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoc2xpZGVzW25leHRdLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHJlZmxvdyhzbGlkZXNbbmV4dF0pO1xuICAgICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGVsZW1lbnQsIG1pZ2h0IGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgICAgICAgIGlmIChvcHMuaW50ZXJ2YWwgJiYgZWxlbWVudCAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpKSB7XG4gICAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkQ3VzdG9tRXZlbnQpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldEFjdGl2ZUluZGV4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbShzbGlkZXMpLmluZGV4T2YoZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pdGVtIGFjdGl2ZScpWzBdKSB8fCAwOyB9O1xuXG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGl0ZW1DbGFzc2VzID0gWydsZWZ0JywgJ3JpZ2h0JywgJ3ByZXYnLCAnbmV4dCddO1xuXG4gICAgICBBcnJheS5mcm9tKHNsaWRlcykuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUsIGlkeCkge1xuICAgICAgICBpZiAoc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBzZXRBY3RpdmVQYWdlKGlkeCk7IH1cbiAgICAgICAgaXRlbUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJldHVybiBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyBjbHMpKTsgfSk7XG4gICAgICB9KTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG5cbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgICAgdmFycyA9IHt9O1xuICAgICAgb3BzID0ge307XG4gICAgICBkZWxldGUgZWxlbWVudC5DYXJvdXNlbDtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeVNlbGVjdG9yKGVsZW0pO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LkNhcm91c2VsKSB7IGVsZW1lbnQuQ2Fyb3VzZWwuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBjYXJvdXNlbCBlbGVtZW50c1xuICAgIHNsaWRlcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtaXRlbScpO1xuICAgIChhc3NpZ24gPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWNvbnRyb2wtcHJldicpLCBsZWZ0QXJyb3cgPSBhc3NpZ25bMF0pO1xuICAgIChhc3NpZ24kMSA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtY29udHJvbC1uZXh0JyksIHJpZ2h0QXJyb3cgPSBhc3NpZ24kMVswXSk7XG4gICAgKGFzc2lnbiQyID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pbmRpY2F0b3JzJyksIGluZGljYXRvciA9IGFzc2lnbiQyWzBdKTtcbiAgICBpbmRpY2F0b3JzID0gKGluZGljYXRvciAmJiBpbmRpY2F0b3IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0xJJykpIHx8IFtdO1xuXG4gICAgLy8gaW52YWxpZGF0ZSB3aGVuIG5vdCBlbm91Z2ggaXRlbXNcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBjaGVjayBvcHRpb25zXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgaW50ZXJ2YWxBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbnRlcnZhbCcpO1xuICAgIHZhciBpbnRlcnZhbERhdGEgPSBpbnRlcnZhbEF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJyA/IDAgOiArKGludGVydmFsQXR0cmlidXRlKTtcbiAgICB2YXIgdG91Y2hEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG91Y2gnKSA9PT0gJ2ZhbHNlJyA/IDAgOiAxO1xuICAgIHZhciBwYXVzZURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXVzZScpID09PSAnaG92ZXInIHx8IGZhbHNlO1xuICAgIHZhciBrZXlib2FyZERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZCcpID09PSAndHJ1ZScgfHwgZmFsc2U7XG5cbiAgICAvLyBKUyBvcHRpb25zXG4gICAgdmFyIGludGVydmFsT3B0aW9uID0gb3B0aW9ucy5pbnRlcnZhbDtcbiAgICB2YXIgdG91Y2hPcHRpb24gPSBvcHRpb25zLnRvdWNoO1xuXG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICBvcHMgPSB7fTtcbiAgICBvcHMua2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkID09PSB0cnVlIHx8IGtleWJvYXJkRGF0YTtcbiAgICBvcHMucGF1c2UgPSAob3B0aW9ucy5wYXVzZSA9PT0gJ2hvdmVyJyB8fCBwYXVzZURhdGEpID8gJ2hvdmVyJyA6IGZhbHNlOyAvLyBmYWxzZSAvIGhvdmVyXG4gICAgb3BzLnRvdWNoID0gdG91Y2hPcHRpb24gfHwgdG91Y2hEYXRhO1xuXG4gICAgb3BzLmludGVydmFsID0gNTAwMDsgLy8gYm9vdHN0cmFwIGNhcm91c2VsIGRlZmF1bHQgaW50ZXJ2YWxcblxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWxPcHRpb24gPT09ICdudW1iZXInKSB7IG9wcy5pbnRlcnZhbCA9IGludGVydmFsT3B0aW9uOyB9XG4gICAgZWxzZSBpZiAoaW50ZXJ2YWxPcHRpb24gPT09IGZhbHNlIHx8IGludGVydmFsRGF0YSA9PT0gMCB8fCBpbnRlcnZhbERhdGEgPT09IGZhbHNlKSB7XG4gICAgICBvcHMuaW50ZXJ2YWwgPSAwO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc05hTihpbnRlcnZhbERhdGEpKSB7IG9wcy5pbnRlcnZhbCA9IGludGVydmFsRGF0YTsgfVxuXG4gICAgLy8gc2V0IGZpcnN0IHNsaWRlIGFjdGl2ZSBpZiBub25lXG4gICAgaWYgKHNlbGYuZ2V0QWN0aXZlSW5kZXgoKSA8IDApIHtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoKSB7IHNsaWRlc1swXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsgfVxuICAgICAgaWYgKGluZGljYXRvcnMubGVuZ3RoKSB7IHNldEFjdGl2ZVBhZ2UoMCk7IH1cbiAgICB9XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZVxuICAgIHZhcnMgPSB7fTtcbiAgICB2YXJzLmRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICB2YXJzLmluZGV4ID0gMDtcbiAgICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgICB2YXJzLmlzU2xpZGluZyA9IGZhbHNlO1xuICAgIHZhcnMuaXNUb3VjaCA9IGZhbHNlO1xuICAgIHZhcnMudG91Y2hQb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0WDogMCxcbiAgICAgIGN1cnJlbnRYOiAwLFxuICAgICAgZW5kWDogMCxcbiAgICB9O1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGhhbmRsZXJzXG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuXG4gICAgLy8gc3RhcnQgdG8gY3ljbGUgaWYgaW50ZXJ2YWwgaXMgc2V0XG4gICAgaWYgKG9wcy5pbnRlcnZhbCkgeyBzZWxmLmN5Y2xlKCk7IH1cblxuICAgIC8vIGFzc29jaWF0ZSBpbml0IG9iamVjdCB0byB0YXJnZXRcbiAgICBlbGVtZW50LkNhcm91c2VsID0gc2VsZjtcbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IENvbGxhcHNlXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gQ09MTEFQU0UgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gQ29sbGFwc2UoZWxlbSwgb3BzSW5wdXQpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gb3BzSW5wdXQgfHwge307XG5cbiAgICAvLyBiaW5kXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gdGFyZ2V0IHByYWN0aWNlXG4gICAgdmFyIGFjY29yZGlvbiA9IG51bGw7XG4gICAgdmFyIGNvbGxhcHNlID0gbnVsbDtcbiAgICB2YXIgYWN0aXZlQ29sbGFwc2U7XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQ7XG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHZhciBzaG93Q3VzdG9tRXZlbnQ7XG4gICAgdmFyIHNob3duQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGVDdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZGVuQ3VzdG9tRXZlbnQ7XG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBvcGVuQWN0aW9uKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29sbGFwc2VFbGVtZW50LnNjcm9sbEhlaWdodCkgKyBcInB4XCI7XG5cbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGNvbGxhcHNlRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIHRvZ2dsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2luZycpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUFjdGlvbihjb2xsYXBzZUVsZW1lbnQsIHRvZ2dsZSkge1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGNvbGxhcHNlRWxlbWVudC5zY3JvbGxIZWlnaHQpICsgXCJweFwiOyAvLyBzZXQgaGVpZ2h0IGZpcnN0XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuICAgICAgcmVmbG93KGNvbGxhcHNlRWxlbWVudCk7IC8vIGZvcmNlIHJlZmxvdyB0byBlbmFibGUgdHJhbnNpdGlvblxuICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuXG4gICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgdG9nZ2xlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2luZycpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgoZSAmJiBlLnRhcmdldC50YWdOYW1lID09PSAnQScpIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0EnKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICAgIGlmICghY29sbGFwc2UuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgc2VsZi5zaG93KCk7IH1cbiAgICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29sbGFwc2UuaXNBbmltYXRpbmcpIHsgcmV0dXJuOyB9XG4gICAgICBjbG9zZUFjdGlvbihjb2xsYXBzZSwgZWxlbWVudCk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICAgIH07XG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFzc2lnbjtcblxuICAgICAgaWYgKGFjY29yZGlvbikge1xuICAgICAgICAoYXNzaWduID0gYWNjb3JkaW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvbGxhcHNlIHNob3cnKSwgYWN0aXZlQ29sbGFwc2UgPSBhc3NpZ25bMF0pO1xuICAgICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlQ29sbGFwc2UgJiYgKHF1ZXJ5U2VsZWN0b3IoKFwiW2RhdGEtdGFyZ2V0PVxcXCIjXCIgKyAoYWN0aXZlQ29sbGFwc2UuaWQpICsgXCJcXFwiXVwiKSwgYWNjb3JkaW9uKVxuICAgICAgICAgICAgICAgICAgICAgIHx8IHF1ZXJ5U2VsZWN0b3IoKFwiW2hyZWY9XFxcIiNcIiArIChhY3RpdmVDb2xsYXBzZS5pZCkgKyBcIlxcXCJdXCIpLCBhY2NvcmRpb24pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb2xsYXBzZS5pc0FuaW1hdGluZykge1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVDb2xsYXBzZSAhPT0gY29sbGFwc2UpIHtcbiAgICAgICAgICBjbG9zZUFjdGlvbihhY3RpdmVDb2xsYXBzZSwgYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuQWN0aW9uKGNvbGxhcHNlLCBlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLnRvZ2dsZSwgZmFsc2UpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuQ29sbGFwc2U7XG4gICAgfTtcblxuICAgIC8vIGluaXRcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlTZWxlY3RvcihlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5Db2xsYXBzZSkgeyBlbGVtZW50LkNvbGxhcHNlLmRpc3Bvc2UoKTsgfVxuXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgYWNjb3JkaW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudCcpO1xuXG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ2NvbGxhcHNlJyk7XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICdjb2xsYXBzZScpO1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ2NvbGxhcHNlJyk7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ2NvbGxhcHNlJyk7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGFyZ2V0c1xuICAgIGNvbGxhcHNlID0gcXVlcnlTZWxlY3RvcihvcHRpb25zLnRhcmdldCB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcblxuICAgIGlmIChjb2xsYXBzZSAhPT0gbnVsbCkgeyBjb2xsYXBzZS5pc0FuaW1hdGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGFjY29yZGlvblNlbGVjdG9yID0gb3B0aW9ucy5wYXJlbnQgfHwgYWNjb3JkaW9uRGF0YTtcbiAgICBpZiAoYWNjb3JkaW9uU2VsZWN0b3IpIHtcbiAgICAgIGFjY29yZGlvbiA9IGVsZW1lbnQuY2xvc2VzdChhY2NvcmRpb25TZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY29yZGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICBpZiAoIWVsZW1lbnQuQ29sbGFwc2UpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLnRvZ2dsZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIGFzc29jaWF0ZSB0YXJnZXQgdG8gaW5pdCBvYmplY3RcbiAgICBlbGVtZW50LkNvbGxhcHNlID0gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2ludHMgdGhlIGZvY3VzIHRvIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCB0YXJnZXRcbiAgICovXG4gIHZhciBzZXRGb2N1cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LmZvY3VzKCk7IH07XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgRHJvcGRvd25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBEUk9QRE9XTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBEcm9wZG93bihlbGVtLCBvcHRpb24pIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcbiAgICAvLyB0YXJnZXRzXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHZhciBwYXJlbnQ7IHZhciBtZW51OyB2YXIgbWVudUl0ZW1zID0gW107XG4gICAgLy8gb3B0aW9uXG4gICAgdmFyIHBlcnNpc3Q7XG5cbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbiBlbXB0eSBhbmNob3IgbGlua3NcbiAgICBmdW5jdGlvbiBwcmV2ZW50RW1wdHlBbmNob3IoYW5jaG9yKSB7XG4gICAgICBpZiAoKGFuY2hvci5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSAmJiBhbmNob3IuaHJlZi5zbGljZSgtMSkgPT09ICcjJykgfHwgKGFuY2hvci5wYXJlbnROb2RlXG4gICAgICAgICYmIGFuY2hvci5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgICYmIGFuY2hvci5wYXJlbnROb2RlLmhyZWYuc2xpY2UoLTEpID09PSAnIycpKSB7IHRoaXMucHJldmVudERlZmF1bHQoKTsgfVxuICAgIH1cbiAgICAvLyB0b2dnbGUgZGlzbWlzc2libGUgZXZlbnRzXG4gICAgZnVuY3Rpb24gdG9nZ2xlRGlzbWlzcygpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBlbGVtZW50Lm9wZW4gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdjbGljaycsIGRpc21pc3NIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdrZXlkb3duJywgcHJldmVudFNjcm9sbCwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgna2V5dXAnLCBrZXlIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdmb2N1cycsIGRpc21pc3NIYW5kbGVyLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIGhhbmRsZXJzXG4gICAgZnVuY3Rpb24gZGlzbWlzc0hhbmRsZXIoZSkge1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICBpZiAoIWV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkgeyByZXR1cm47IH0gLy8gc29tZSB3ZWlyZCBGRiBidWcgIzQwOVxuICAgICAgdmFyIGhhc0RhdGEgPSAoKGV2ZW50VGFyZ2V0ICYmIChldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChldmVudFRhcmdldC5wYXJlbnROb2RlICYmIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnRUYXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJykpKTtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1cycgJiYgKGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnUuY29udGFpbnMoZXZlbnRUYXJnZXQpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnUuY29udGFpbnMoZXZlbnRUYXJnZXQpKSAmJiAocGVyc2lzdCB8fCBoYXNEYXRhKSkgeyByZXR1cm47IH1cblxuICAgICAgcmVsYXRlZFRhcmdldCA9IGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgICBzZWxmLmhpZGUoKTtcblxuICAgICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSwgZXZlbnRUYXJnZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICBzZWxmLnNob3coKTtcbiAgICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsIGUudGFyZ2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJldmVudFNjcm9sbChlKSB7XG4gICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICBpZiAoa2V5ID09PSAzOCB8fCBrZXkgPT09IDQwKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIHZhciBpc1NhbWVFbGVtZW50ID0gYWN0aXZlSXRlbSA9PT0gZWxlbWVudDtcbiAgICAgIHZhciBpc0luc2lkZU1lbnUgPSBtZW51LmNvbnRhaW5zKGFjdGl2ZUl0ZW0pO1xuICAgICAgdmFyIGlzTWVudUl0ZW0gPSBhY3RpdmVJdGVtLnBhcmVudE5vZGUgPT09IG1lbnUgfHwgYWN0aXZlSXRlbS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT09IG1lbnU7XG4gICAgICB2YXIgaWR4ID0gbWVudUl0ZW1zLmluZGV4T2YoYWN0aXZlSXRlbSk7XG5cbiAgICAgIGlmIChpc01lbnVJdGVtKSB7IC8vIG5hdmlnYXRlIHVwIHwgZG93blxuICAgICAgICBpZiAoaXNTYW1lRWxlbWVudCkge1xuICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAzOCkge1xuICAgICAgICAgIGlkeCA9IGlkeCA+IDEgPyBpZHggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IDQwKSB7XG4gICAgICAgICAgaWR4ID0gaWR4IDwgbWVudUl0ZW1zLmxlbmd0aCAtIDEgPyBpZHggKyAxIDogaWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lbnVJdGVtc1tpZHhdKSB7IHNldEZvY3VzKG1lbnVJdGVtc1tpZHhdKTsgfVxuICAgICAgfVxuICAgICAgaWYgKCgobWVudUl0ZW1zLmxlbmd0aCAmJiBpc01lbnVJdGVtKSAvLyBtZW51IGhhcyBpdGVtc1xuICAgICAgICAgICAgfHwgKCFtZW51SXRlbXMubGVuZ3RoICYmIChpc0luc2lkZU1lbnUgfHwgaXNTYW1lRWxlbWVudCkpIC8vIG1lbnUgbWlnaHQgYmUgYSBmb3JtXG4gICAgICAgICAgICB8fCAhaXNJbnNpZGVNZW51KSAvLyBvciB0aGUgZm9jdXNlZCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgbWVudSBhdCBhbGxcbiAgICAgICAgICAgICYmIGVsZW1lbnQub3BlbiAmJiBrZXkgPT09IDI3IC8vIG1lbnUgbXVzdCBiZSBvcGVuXG4gICAgICApIHtcbiAgICAgICAgc2VsZi50b2dnbGUoKTtcbiAgICAgICAgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdkcm9wZG93bicsIHsgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCB9KTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIG1lbnUuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICBlbGVtZW50Lm9wZW4gPSB0cnVlO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEZvY3VzKG1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF0gfHwgZWxlbWVudCk7IC8vIGZvY3VzIHRoZSBmaXJzdCBpbnB1dCBpdGVtIHwgZWxlbWVudFxuICAgICAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAnZHJvcGRvd24nLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgICAgfSwgMSk7XG4gICAgfTtcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICdkcm9wZG93bicsIHsgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCB9KTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgZWxlbWVudC5vcGVuID0gZmFsc2U7XG4gICAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgICBzZXRGb2N1cyhlbGVtZW50KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbmx5IHJlLWF0dGFjaCBoYW5kbGVyIGlmIHRoZSBpbml0IGlzIG5vdCBkaXNwb3NlZFxuICAgICAgICBpZiAoZWxlbWVudC5Ecm9wZG93bikgeyBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBmYWxzZSk7IH1cbiAgICAgIH0sIDEpO1xuXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnZHJvcGRvd24nLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgfTtcbiAgICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgZWxlbWVudC5vcGVuKSB7IHNlbGYuaGlkZSgpOyB9IGVsc2UgeyBzZWxmLnNob3coKTsgfVxuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiBlbGVtZW50Lm9wZW4pIHsgc2VsZi5oaWRlKCk7IH1cbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LkRyb3Bkb3duO1xuICAgIH07XG5cbiAgICAvLyBpbml0XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3IoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuRHJvcGRvd24pIHsgZWxlbWVudC5Ecm9wZG93bi5kaXNwb3NlKCk7IH1cblxuICAgIC8vIHNldCAgdGFyZ2V0c1xuICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBtZW51ID0gcXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLW1lbnUnLCBwYXJlbnQpO1xuXG4gICAgQXJyYXkuZnJvbShtZW51LmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgbWVudUl0ZW1zLnB1c2goY2hpbGQuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdBJykgeyBtZW51SXRlbXMucHVzaChjaGlsZCk7IH1cbiAgICB9KTtcblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LkRyb3Bkb3duKSB7XG4gICAgICBpZiAoISgndGFiaW5kZXgnIGluIG1lbnUpKSB7IG1lbnUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7IH0gLy8gRml4IG9uYmx1ciBvbiBDaHJvbWUgfCBTYWZhcmlcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgb3B0aW9uXG4gICAgcGVyc2lzdCA9IG9wdGlvbiA9PT0gdHJ1ZSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wZXJzaXN0JykgPT09ICd0cnVlJyB8fCBmYWxzZTtcblxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlIHRvIGNsb3NlZFxuICAgIGVsZW1lbnQub3BlbiA9IGZhbHNlO1xuXG4gICAgLy8gYXNzb2NpYXRlIGVsZW1lbnQgd2l0aCBpbml0IG9iamVjdFxuICAgIGVsZW1lbnQuRHJvcGRvd24gPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgTW9kYWxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBNT0RBTCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBNb2RhbChlbGVtLCBvcHNJbnB1dCkgeyAvLyBlbGVtZW50IGNhbiBiZSB0aGUgbW9kYWwvdHJpZ2dlcmluZyBidXR0b25cbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBvcHNJbnB1dCB8fCB7fTtcblxuICAgIC8vIGJpbmQsIG1vZGFsXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtb2RhbDtcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICB2YXIgc2hvd0N1c3RvbUV2ZW50O1xuICAgIHZhciBzaG93bkN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGRlbkN1c3RvbUV2ZW50O1xuICAgIC8vIGV2ZW50IHRhcmdldHMgYW5kIG90aGVyXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHZhciBzY3JvbGxCYXJXaWR0aDtcbiAgICB2YXIgb3ZlcmxheTtcbiAgICB2YXIgb3ZlcmxheURlbGF5O1xuXG4gICAgLy8gYWxzbyBmaW5kIGZpeGVkLXRvcCAvIGZpeGVkLWJvdHRvbSBpdGVtc1xuICAgIHZhciBmaXhlZEl0ZW1zO1xuICAgIHZhciBvcHMgPSB7fTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIHNldFNjcm9sbGJhcigpIHtcbiAgICAgIHZhciBib2R5Q2xhc3NMaXN0ID0gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3Q7XG4gICAgICB2YXIgb3Blbk1vZGFsID0gYm9keUNsYXNzTGlzdC5jb250YWlucygnbW9kYWwtb3BlbicpO1xuICAgICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLnBhZGRpbmdSaWdodCwgMTApO1xuICAgICAgdmFyIGRvY0NsaWVudEhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgZG9jU2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIHZhciBib2R5Q2xpZW50SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgYm9keVNjcm9sbEhlaWdodCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdmFyIGJvZHlPdmVyZmxvdyA9IGRvY0NsaWVudEhlaWdodCAhPT0gZG9jU2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgfHwgYm9keUNsaWVudEhlaWdodCAhPT0gYm9keVNjcm9sbEhlaWdodDtcbiAgICAgIHZhciBtb2RhbE92ZXJmbG93ID0gbW9kYWwuY2xpZW50SGVpZ2h0ICE9PSBtb2RhbC5zY3JvbGxIZWlnaHQ7XG5cbiAgICAgIHNjcm9sbEJhcldpZHRoID0gbWVhc3VyZVNjcm9sbGJhcigpO1xuXG4gICAgICBtb2RhbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAhbW9kYWxPdmVyZmxvdyAmJiBzY3JvbGxCYXJXaWR0aCA/IChzY3JvbGxCYXJXaWR0aCArIFwicHhcIikgOiAnJztcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gbW9kYWxPdmVyZmxvdyB8fCBib2R5T3ZlcmZsb3dcbiAgICAgICAgPyAoKGJvZHlQYWQgKyAob3Blbk1vZGFsID8gMCA6IHNjcm9sbEJhcldpZHRoKSkgKyBcInB4XCIpIDogJyc7XG5cbiAgICAgIGlmIChmaXhlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBmaXhlZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGZpeGVkKSB7XG4gICAgICAgICAgdmFyIGl0ZW1QYWQgPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkKS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgZml4ZWQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gbW9kYWxPdmVyZmxvdyB8fCBib2R5T3ZlcmZsb3dcbiAgICAgICAgICAgID8gKChwYXJzZUludChpdGVtUGFkLCAxMCkgKyAob3Blbk1vZGFsID8gMCA6IHNjcm9sbEJhcldpZHRoKSkgKyBcInB4XCIpXG4gICAgICAgICAgICA6ICgocGFyc2VJbnQoaXRlbVBhZCwgMTApKSArIFwicHhcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFNjcm9sbGJhcigpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICBtb2RhbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICAgIGlmIChmaXhlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBmaXhlZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGZpeGVkKSB7XG4gICAgICAgICAgZml4ZWQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZWFzdXJlU2Nyb2xsYmFyKCkge1xuICAgICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSc7IC8vIHRoaXMgaXMgaGVyZSB0byBzdGF5XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgICB2YXIgd2lkdGhWYWx1ZSA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICAgIHJldHVybiB3aWR0aFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVybGF5KCkge1xuICAgICAgdmFyIG5ld092ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG92ZXJsYXkgPSBxdWVyeVNlbGVjdG9yKCcubW9kYWwtYmFja2Ryb3AnKTtcblxuICAgICAgaWYgKG92ZXJsYXkgPT09IG51bGwpIHtcbiAgICAgICAgbmV3T3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKFwibW9kYWwtYmFja2Ryb3BcIiArIChvcHMuYW5pbWF0aW9uID8gJyBmYWRlJyA6ICcnKSkpO1xuICAgICAgICBvdmVybGF5ID0gbmV3T3ZlcmxheTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdmVybGF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVPdmVybGF5KCkge1xuICAgICAgb3ZlcmxheSA9IHF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1iYWNrZHJvcCcpO1xuICAgICAgaWYgKG92ZXJsYXkgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXkpOyBvdmVybGF5ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5ID09PSBudWxsKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbW9kYWwtb3BlbicpO1xuICAgICAgICByZXNldFNjcm9sbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYudXBkYXRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICBtb2RhbFthY3Rpb25dKCdjbGljaycsIGRpc21pc3NIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdrZXlkb3duJywga2V5SGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2Vyc1xuICAgIGZ1bmN0aW9uIGJlZm9yZVNob3coKSB7XG4gICAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkgeyBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW9wZW4nKTsgfVxuXG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuXG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykpIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJTaG93KTsgfVxuICAgICAgZWxzZSB7IHRyaWdnZXJTaG93KCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpZ2dlclNob3coKSB7XG4gICAgICBzZXRGb2N1cyhtb2RhbCk7XG4gICAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICB0b2dnbGVFdmVudHMoMSk7XG5cbiAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAnbW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VySGlkZShmb3JjZSkge1xuICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgaWYgKGVsZW1lbnQpIHsgc2V0Rm9jdXMoZWxlbWVudCk7IH1cblxuICAgICAgb3ZlcmxheSA9IHF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1iYWNrZHJvcCcpO1xuXG4gICAgICAvLyBmb3JjZSBjYW4gYWxzbyBiZSB0aGUgdHJhbnNpdGlvbkV2ZW50IG9iamVjdCwgd2Ugd2FubmEgbWFrZSBzdXJlIGl0J3Mgbm90XG4gICAgICBpZiAoZm9yY2UgIT09IDEgJiYgb3ZlcmxheSAmJiBvdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF0pIHtcbiAgICAgICAgb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG92ZXJsYXksIHJlbW92ZU92ZXJsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlT3ZlcmxheSgpO1xuICAgICAgfVxuXG4gICAgICB0b2dnbGVFdmVudHMoKTtcblxuICAgICAgbW9kYWwuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ21vZGFsJyk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICB9XG4gICAgLy8gaGFuZGxlcnNcbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKG1vZGFsLmlzQW5pbWF0aW5nKSB7IHJldHVybjsgfVxuICAgICAgdmFyIGNsaWNrVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICB2YXIgbW9kYWxJRCA9IFwiI1wiICsgKG1vZGFsLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICB2YXIgdGFyZ2V0QXR0clZhbHVlID0gY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGNsaWNrVGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgdmFyIGVsZW1BdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICBpZiAoIW1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpXG4gICAgICAgICAgJiYgKChjbGlja1RhcmdldCA9PT0gZWxlbWVudCAmJiB0YXJnZXRBdHRyVmFsdWUgPT09IG1vZGFsSUQpXG4gICAgICAgICAgfHwgKGVsZW1lbnQuY29udGFpbnMoY2xpY2tUYXJnZXQpICYmIGVsZW1BdHRyVmFsdWUgPT09IG1vZGFsSUQpKSkge1xuICAgICAgICBtb2RhbC5tb2RhbFRyaWdnZXIgPSBlbGVtZW50O1xuICAgICAgICByZWxhdGVkVGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24ga2V5SGFuZGxlcihyZWYpIHtcbiAgICAgIHZhciB3aGljaCA9IHJlZi53aGljaDtcblxuICAgICAgaWYgKCFtb2RhbC5pc0FuaW1hdGluZyAmJiBvcHMua2V5Ym9hcmQgJiYgd2hpY2ggPT09IDI3ICYmIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlcihlKSB7XG4gICAgICBpZiAobW9kYWwuaXNBbmltYXRpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHZhciBoYXNEYXRhID0gY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3MnKSA9PT0gJ21vZGFsJztcbiAgICAgIHZhciBwYXJlbnRXaXRoRGF0YSA9IGNsaWNrVGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScpO1xuXG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgKHBhcmVudFdpdGhEYXRhIHx8IGhhc0RhdGFcbiAgICAgICAgICB8fCAoY2xpY2tUYXJnZXQgPT09IG1vZGFsICYmIG9wcy5iYWNrZHJvcCAhPT0gJ3N0YXRpYycpKSkge1xuICAgICAgICBzZWxmLmhpZGUoKTsgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7IHNlbGYuaGlkZSgpOyB9IGVsc2UgeyBzZWxmLnNob3coKTsgfVxuICAgIH07XG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICEhbW9kYWwuaXNBbmltYXRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ21vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0IH0pO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBzaG93Q3VzdG9tRXZlbnQpO1xuXG4gICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgLy8gd2UgZWxlZ2FudGx5IGhpZGUgYW55IG9wZW5lZCBtb2RhbFxuICAgICAgdmFyIGN1cnJlbnRPcGVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9kYWwgc2hvdycpWzBdO1xuICAgICAgaWYgKGN1cnJlbnRPcGVuICYmIGN1cnJlbnRPcGVuICE9PSBtb2RhbCkge1xuICAgICAgICBpZiAoY3VycmVudE9wZW4ubW9kYWxUcmlnZ2VyKSB7IGN1cnJlbnRPcGVuLm1vZGFsVHJpZ2dlci5Nb2RhbC5oaWRlKCk7IH1cbiAgICAgICAgaWYgKGN1cnJlbnRPcGVuLk1vZGFsKSB7IGN1cnJlbnRPcGVuLk1vZGFsLmhpZGUoKTsgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3BzLmJhY2tkcm9wKSB7IG92ZXJsYXkgPSBjcmVhdGVPdmVybGF5KCk7IH1cblxuICAgICAgaWYgKG92ZXJsYXkgJiYgIWN1cnJlbnRPcGVuICYmICFvdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIHJlZmxvdyhvdmVybGF5KTtcbiAgICAgICAgb3ZlcmxheURlbGF5ID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihvdmVybGF5KTtcbiAgICAgICAgb3ZlcmxheS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudE9wZW4pIHsgc2V0VGltZW91dChiZWZvcmVTaG93LCBvdmVybGF5ICYmIG92ZXJsYXlEZWxheSA/IG92ZXJsYXlEZWxheSA6IDApOyB9XG4gICAgICBlbHNlIHsgYmVmb3JlU2hvdygpOyB9XG4gICAgfTtcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIGlmICghbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ21vZGFsJyk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgbW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgbW9kYWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgJiYgZm9yY2UgIT09IDEpIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJIaWRlKTsgfVxuICAgICAgZWxzZSB7IHRyaWdnZXJIaWRlKCk7IH1cbiAgICB9O1xuICAgIHNlbGYuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBxdWVyeVNlbGVjdG9yKCcubW9kYWwtY29udGVudCcsIG1vZGFsKS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH07XG4gICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmhpZGUoMSk7XG4gICAgICBpZiAoZWxlbWVudCkgeyBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBmYWxzZSk7IGRlbGV0ZSBlbGVtZW50Lk1vZGFsOyB9IGVsc2UgeyBkZWxldGUgbW9kYWwuTW9kYWw7IH1cbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuXG4gICAgLy8gdGhlIG1vZGFsIChib3RoIEphdmFTY3JpcHQgLyBEQVRBIEFQSSBpbml0KSAvIHRyaWdnZXJpbmcgYnV0dG9uIGVsZW1lbnQgKERBVEEgQVBJKVxuICAgIGVsZW1lbnQgPSBxdWVyeVNlbGVjdG9yKGVsZW0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG1vZGFsLCB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICB2YXIgY2hlY2tNb2RhbCA9IHF1ZXJ5U2VsZWN0b3IoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgbW9kYWwgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwnKSA/IGVsZW1lbnQgOiBjaGVja01vZGFsO1xuXG4gICAgLy8gc2V0IGZpeGVkIGl0ZW1zXG4gICAgZml4ZWRJdGVtcyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZml4ZWQtdG9wJykpXG4gICAgICAuY29uY2F0KEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZml4ZWQtYm90dG9tJykpKTtcblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwnKSkgeyBlbGVtZW50ID0gbnVsbDsgfSAvLyBtb2RhbCBpcyBub3cgaW5kZXBlbmRlbnQgb2YgaXQncyB0cmlnZ2VyaW5nIGVsZW1lbnRcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lk1vZGFsKSB7IGVsZW1lbnQuTW9kYWwuZGlzcG9zZSgpOyB9XG4gICAgaWYgKG1vZGFsICYmIG1vZGFsLk1vZGFsKSB7IG1vZGFsLk1vZGFsLmRpc3Bvc2UoKTsgfVxuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHMua2V5Ym9hcmQgPSAhKG9wdGlvbnMua2V5Ym9hcmQgPT09IGZhbHNlIHx8IG1vZGFsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZCcpID09PSAnZmFsc2UnKTtcbiAgICBvcHMuYmFja2Ryb3AgPSBvcHRpb25zLmJhY2tkcm9wID09PSAnc3RhdGljJyB8fCBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2Ryb3AnKSA9PT0gJ3N0YXRpYycgPyAnc3RhdGljJyA6IHRydWU7XG4gICAgb3BzLmJhY2tkcm9wID0gb3B0aW9ucy5iYWNrZHJvcCA9PT0gZmFsc2UgfHwgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tkcm9wJykgPT09ICdmYWxzZScgPyBmYWxzZSA6IG9wcy5iYWNrZHJvcDtcbiAgICBvcHMuYW5pbWF0aW9uID0gISFtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKTtcbiAgICBvcHMuY29udGVudCA9IG9wdGlvbnMuY29udGVudDsgLy8gSmF2YVNjcmlwdCBvbmx5XG5cbiAgICAvLyBzZXQgYW4gaW5pdGlhbCBzdGF0ZSBvZiB0aGUgbW9kYWxcbiAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgb3ZlciBhbmQgb3ZlclxuICAgIC8vIG1vZGFsIGlzIGluZGVwZW5kZW50IG9mIGEgdHJpZ2dlcmluZyBlbGVtZW50XG4gICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuTW9kYWwpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3BzLmNvbnRlbnQpIHtcbiAgICAgIHNlbGYuc2V0Q29udGVudChvcHMuY29udGVudC50cmltKCkpO1xuICAgIH1cblxuICAgIC8vIHNldCBhc3NvY2lhdGlvbnNcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgbW9kYWwubW9kYWxUcmlnZ2VyID0gZWxlbWVudDtcbiAgICAgIGVsZW1lbnQuTW9kYWwgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RhbC5Nb2RhbCA9IHNlbGY7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2xvYmFsIG5hbWVzcGFjZSBmb3IgbW91c2UgY2xpY2sgZXZlbnRzLlxuICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHZhciBtb3VzZUNsaWNrRXZlbnRzID0geyBkb3duOiAnbW91c2Vkb3duJywgdXA6ICdtb3VzZXVwJyB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgV2luZG93YCAvIGBIVE1MYCBzY3JvbGwgcG9zaXRpb24uXG4gICAqIFBvcG92ZXIsIFRvb2x0aXAgJiBTY3JvbGxTcHkgbmVlZCBpdC5cbiAgICpcbiAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBzY3JvbGwgYHt4LHl9YCB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGJvdGggcG9wb3ZlcnMgYW5kIHRvb2x0aXBzICh0YXJnZXQsdG9vbHRpcCxwbGFjZW1lbnQsZWxlbWVudFRvQXBwZW5kVG8pXG4gIGZ1bmN0aW9uIHN0eWxlVGlwKGxpbmssIGVsZW1lbnQsIG9yaWdpbmFsUG9zaXRpb24sIHBhcmVudCkge1xuICAgIHZhciB0aXBQb3NpdGlvbnMgPSAvXFxiKHRvcHxib3R0b218bGVmdHxyaWdodCkrLztcbiAgICB2YXIgZWxlbWVudERpbWVuc2lvbnMgPSB7IHc6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGg6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IH07XG4gICAgdmFyIHdpbmRvd1dpZHRoID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKTtcbiAgICB2YXIgd2luZG93SGVpZ2h0ID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpO1xuICAgIHZhciByZWN0ID0gbGluay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc2Nyb2xsID0gcGFyZW50ID09PSBkb2N1bWVudC5ib2R5XG4gICAgICA/IGdldFNjcm9sbCgpXG4gICAgICA6IHsgeDogcGFyZW50Lm9mZnNldExlZnQgKyBwYXJlbnQuc2Nyb2xsTGVmdCwgeTogcGFyZW50Lm9mZnNldFRvcCArIHBhcmVudC5zY3JvbGxUb3AgfTtcbiAgICB2YXIgbGlua0RpbWVuc2lvbnMgPSB7IHc6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIGg6IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgfTtcbiAgICB2YXIgaXNQb3BvdmVyID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKTtcbiAgICB2YXIgYXJyb3cgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Fycm93JylbMF07XG4gICAgdmFyIGhhbGZUb3BFeGNlZWQgPSByZWN0LnRvcCArIGxpbmtEaW1lbnNpb25zLmggLyAyIC0gZWxlbWVudERpbWVuc2lvbnMuaCAvIDIgPCAwO1xuICAgIHZhciBoYWxmTGVmdEV4Y2VlZCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncgLyAyIC0gZWxlbWVudERpbWVuc2lvbnMudyAvIDIgPCAwO1xuICAgIHZhciBoYWxmUmlnaHRFeGNlZWQgPSByZWN0LmxlZnQgKyBlbGVtZW50RGltZW5zaW9ucy53IC8gMlxuICAgICAgKyBsaW5rRGltZW5zaW9ucy53IC8gMiA+PSB3aW5kb3dXaWR0aDtcbiAgICB2YXIgaGFsZkJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaCAvIDJcbiAgICAgICsgbGlua0RpbWVuc2lvbnMuaCAvIDIgPj0gd2luZG93SGVpZ2h0O1xuICAgIHZhciB0b3BFeGNlZWQgPSByZWN0LnRvcCAtIGVsZW1lbnREaW1lbnNpb25zLmggPCAwO1xuICAgIHZhciBsZWZ0RXhjZWVkID0gcmVjdC5sZWZ0IC0gZWxlbWVudERpbWVuc2lvbnMudyA8IDA7XG4gICAgdmFyIGJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmggPj0gd2luZG93SGVpZ2h0O1xuICAgIHZhciByaWdodEV4Y2VlZCA9IHJlY3QubGVmdCArIGVsZW1lbnREaW1lbnNpb25zLncgKyBsaW5rRGltZW5zaW9ucy53ID49IHdpbmRvd1dpZHRoO1xuICAgIHZhciBwb3NpdGlvbiA9IG9yaWdpbmFsUG9zaXRpb247XG5cbiAgICAvLyByZWNvbXB1dGUgcG9zaXRpb25cbiAgICAvLyBmaXJzdCwgd2hlbiBib3RoIGxlZnQgYW5kIHJpZ2h0IGxpbWl0cyBhcmUgZXhjZWVkZWQsIHdlIGZhbGwgYmFjayB0byB0b3B8Ym90dG9tXG4gICAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykgJiYgbGVmdEV4Y2VlZCAmJiByaWdodEV4Y2VlZCA/ICd0b3AnIDogcG9zaXRpb247XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdG9wRXhjZWVkID8gJ2JvdHRvbScgOiBwb3NpdGlvbjtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAnYm90dG9tJyAmJiBib3R0b21FeGNlZWQgPyAndG9wJyA6IHBvc2l0aW9uO1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyAmJiBsZWZ0RXhjZWVkID8gJ3JpZ2h0JyA6IHBvc2l0aW9uO1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdyaWdodCcgJiYgcmlnaHRFeGNlZWQgPyAnbGVmdCcgOiBwb3NpdGlvbjtcblxuICAgIHZhciB0b3BQb3NpdGlvbjtcbiAgICB2YXIgbGVmdFBvc2l0aW9uO1xuICAgIHZhciBhcnJvd1RvcDtcbiAgICB2YXIgYXJyb3dMZWZ0O1xuXG4gICAgLy8gdXBkYXRlIHRvb2x0aXAvcG9wb3ZlciBjbGFzc1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh0aXBQb3NpdGlvbnMsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gICAgdmFyIGFycm93V2lkdGggPSBhcnJvdy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgYXJyb3dIZWlnaHQgPSBhcnJvdy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBhcHBseSBzdHlsaW5nIHRvIHRvb2x0aXAgb3IgcG9wb3ZlclxuICAgIC8vIHNlY29uZGFyeXxzaWRlIHBvc2l0aW9uc1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JykgeyAvLyBMRUZUXG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbC54IC0gZWxlbWVudERpbWVuc2lvbnMudyAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogMCk7XG4gICAgICB9IGVsc2UgeyAvLyBSSUdIVFxuICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0LmxlZnQgKyBzY3JvbGwueCArIGxpbmtEaW1lbnNpb25zLnc7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkanVzdCB0b3AgYW5kIGFycm93XG4gICAgICBpZiAoaGFsZlRvcEV4Y2VlZCkge1xuICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnk7XG4gICAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgICAgfSBlbHNlIGlmIChoYWxmQm90dG9tRXhjZWVkKSB7XG4gICAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmggLSBsaW5rRGltZW5zaW9ucy5oIC8gMiAtIGFycm93V2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC8gMiArIGxpbmtEaW1lbnNpb25zLmggLyAyO1xuICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmggLyAyIC0gKGlzUG9wb3ZlciA/IGFycm93SGVpZ2h0ICogMC45IDogYXJyb3dIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAvLyBwcmltYXJ5fHZlcnRpY2FsIHBvc2l0aW9uc1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykgeyAvLyBUT1BcbiAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDApO1xuICAgICAgfSBlbHNlIHsgLy8gQk9UVE9NXG4gICAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVmdCB8IHJpZ2h0IGFuZCBhbHNvIHRoZSBhcnJvd1xuICAgICAgaWYgKGhhbGZMZWZ0RXhjZWVkKSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGFycm93TGVmdCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncgLyAyIC0gYXJyb3dXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoaGFsZlJpZ2h0RXhjZWVkKSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IHdpbmRvd1dpZHRoIC0gZWxlbWVudERpbWVuc2lvbnMudyAqIDEuMDE7XG4gICAgICAgIGFycm93TGVmdCA9IGVsZW1lbnREaW1lbnNpb25zLncgLSAod2luZG93V2lkdGggLSByZWN0LmxlZnQpXG4gICAgICAgICAgKyBsaW5rRGltZW5zaW9ucy53IC8gMiAtIGFycm93V2lkdGggLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53IC8gMiArIGxpbmtEaW1lbnNpb25zLncgLyAyO1xuICAgICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC8gMiAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogYXJyb3dXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHN0eWxlIHRvIHRvb2x0aXAvcG9wb3ZlciBhbmQgaXRzIGFycm93XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSB0b3BQb3NpdGlvbiArIFwicHhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UG9zaXRpb24gKyBcInB4XCI7XG5cbiAgICBpZiAoYXJyb3dUb3ApIHsgYXJyb3cuc3R5bGUudG9wID0gYXJyb3dUb3AgKyBcInB4XCI7IH1cbiAgICBpZiAoYXJyb3dMZWZ0KSB7IGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgKyBcInB4XCI7IH1cbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFBvcG92ZXJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIFBPUE9WRVIgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQb3BvdmVyKGVsZW0sIG9wc0lucHV0KSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHBvcG92ZXIgYW5kIHRpbWVyXG4gICAgdmFyIHBvcG92ZXIgPSBudWxsO1xuICAgIHZhciB0aW1lciA9IDA7XG4gICAgdmFyIGlzSXBob25lID0gLyhpUGhvbmV8aVBvZHxpUGFkKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAvLyB0aXRsZSBhbmQgY29udGVudFxuICAgIHZhciB0aXRsZVN0cmluZztcbiAgICB2YXIgY29udGVudFN0cmluZztcbiAgICB2YXIgcGxhY2VtZW50Q2xhc3M7XG5cbiAgICAvLyBvcHRpb25zXG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gY2xvc2UgYnRuIGZvciBkaXNzbWlzc2libGUgcG9wb3ZlclxuICAgIHZhciBjbG9zZUJ0bjtcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICB2YXIgc2hvd0N1c3RvbUV2ZW50O1xuICAgIHZhciBzaG93bkN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGRlbkN1c3RvbUV2ZW50O1xuXG4gICAgLy8gaGFuZGxlcnNcbiAgICBmdW5jdGlvbiBkaXNtaXNzaWJsZUhhbmRsZXIoZSkge1xuICAgICAgaWYgKHBvcG92ZXIgIT09IG51bGwgJiYgZS50YXJnZXQgPT09IHF1ZXJ5U2VsZWN0b3IoJy5jbG9zZScsIHBvcG92ZXIpKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBnZXRBdHRyKGF0dCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbYXR0XSB8fCBlbGVtZW50LmRhdGFzZXRbYXR0XSB8fCBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiBnZXRBdHRyKCd0aXRsZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuICAgICAgcmV0dXJuIGdldEF0dHIoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlUG9wb3ZlcigpIHtcbiAgICAgIG9wcy5jb250YWluZXIucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgICB0aW1lciA9IG51bGw7IHBvcG92ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgICB0aXRsZVN0cmluZyA9IGdldFRpdGxlKCk7XG4gICAgICBjb250ZW50U3RyaW5nID0gZ2V0Q29udGVudCgpO1xuICAgICAgLy8gZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVkbnAvYm9vdHN0cmFwLm5hdGl2ZS9pc3N1ZXMvMjMzXG4gICAgICBjb250ZW50U3RyaW5nID0gY29udGVudFN0cmluZyA/IGNvbnRlbnRTdHJpbmcudHJpbSgpIDogbnVsbDtcblxuICAgICAgcG9wb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAvLyBwb3BvdmVyIGFycm93XG4gICAgICB2YXIgcG9wb3ZlckFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3BvdmVyQXJyb3cuY2xhc3NMaXN0LmFkZCgnYXJyb3cnKTtcbiAgICAgIHBvcG92ZXIuYXBwZW5kQ2hpbGQocG9wb3ZlckFycm93KTtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBwb3BvdmVyIGZyb20gZGF0YSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoY29udGVudFN0cmluZyAhPT0gbnVsbCAmJiBvcHMudGVtcGxhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuXG4gICAgICAgIGlmICh0aXRsZVN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwb3BvdmVyVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgICAgICAgIHBvcG92ZXJUaXRsZS5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLWhlYWRlcicpO1xuICAgICAgICAgIHBvcG92ZXJUaXRsZS5pbm5lckhUTUwgPSBvcHMuZGlzbWlzc2libGUgPyB0aXRsZVN0cmluZyArIGNsb3NlQnRuIDogdGl0bGVTdHJpbmc7XG4gICAgICAgICAgcG9wb3Zlci5hcHBlbmRDaGlsZChwb3BvdmVyVGl0bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHBvcG92ZXIgY29udGVudFxuICAgICAgICB2YXIgcG9wb3ZlckJvZHlNYXJrdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcG9wb3ZlckJvZHlNYXJrdXAuY2xhc3NMaXN0LmFkZCgncG9wb3Zlci1ib2R5Jyk7XG4gICAgICAgIHBvcG92ZXJCb2R5TWFya3VwLmlubmVySFRNTCA9IG9wcy5kaXNtaXNzaWJsZSAmJiB0aXRsZVN0cmluZyA9PT0gbnVsbFxuICAgICAgICAgID8gY29udGVudFN0cmluZyArIGNsb3NlQnRuXG4gICAgICAgICAgOiBjb250ZW50U3RyaW5nO1xuICAgICAgICBwb3BvdmVyLmFwcGVuZENoaWxkKHBvcG92ZXJCb2R5TWFya3VwKTtcbiAgICAgIH0gZWxzZSB7IC8vIG9yIGNyZWF0ZSB0aGUgcG9wb3ZlciBmcm9tIHRlbXBsYXRlXG4gICAgICAgIHZhciBwb3BvdmVyVGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcG9wb3ZlclRlbXBsYXRlLmlubmVySFRNTCA9IG9wcy50ZW1wbGF0ZS50cmltKCk7XG4gICAgICAgIHBvcG92ZXIuY2xhc3NOYW1lID0gcG9wb3ZlclRlbXBsYXRlLmZpcnN0Q2hpbGQuY2xhc3NOYW1lO1xuICAgICAgICBwb3BvdmVyLmlubmVySFRNTCA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkLmlubmVySFRNTDtcblxuICAgICAgICB2YXIgcG9wb3ZlckhlYWRlciA9IHF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyLWhlYWRlcicsIHBvcG92ZXIpO1xuICAgICAgICB2YXIgcG9wb3ZlckJvZHkgPSBxdWVyeVNlbGVjdG9yKCcucG9wb3Zlci1ib2R5JywgcG9wb3Zlcik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgdGVtcGxhdGUgd2l0aCBjb250ZW50IGZyb20gZGF0YSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICh0aXRsZVN0cmluZyAmJiBwb3BvdmVySGVhZGVyKSB7IHBvcG92ZXJIZWFkZXIuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmcudHJpbSgpOyB9XG4gICAgICAgIGlmIChjb250ZW50U3RyaW5nICYmIHBvcG92ZXJCb2R5KSB7IHBvcG92ZXJCb2R5LmlubmVySFRNTCA9IGNvbnRlbnRTdHJpbmcudHJpbSgpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGVuZCB0byB0aGUgY29udGFpbmVyXG4gICAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuICAgICAgcG9wb3Zlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIGlmICghcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKSkgeyBwb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXInKTsgfVxuICAgICAgaWYgKCFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucyhvcHMuYW5pbWF0aW9uKSkgeyBwb3BvdmVyLmNsYXNzTGlzdC5hZGQob3BzLmFuaW1hdGlvbik7IH1cbiAgICAgIGlmICghcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMocGxhY2VtZW50Q2xhc3MpKSB7IHBvcG92ZXIuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvd1BvcG92ZXIoKSB7XG4gICAgICBpZiAoIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUG9wb3ZlcigpIHtcbiAgICAgIHN0eWxlVGlwKGVsZW1lbnQsIHBvcG92ZXIsIG9wcy5wbGFjZW1lbnQsIG9wcy5jb250YWluZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZUZvY3VzKCkge1xuICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHsgZWxlbWVudC5mb2N1cygpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93KTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMF0sIHNlbGYuc2hvdyk7XG4gICAgICAgIC8vIG1vdXNlSG92ZXIgPSAoJ29ubW91c2VsZWF2ZScgaW4gZG9jdW1lbnQpXG4gICAgICAgIC8vICAgPyBbICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXVxuICAgICAgICAvLyAgIDogWyAnbW91c2VvdmVyJywgJ21vdXNlb3V0JyBdXG4gICAgICAgIGlmICghb3BzLmRpc21pc3NpYmxlKSB7IGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzFdLCBzZWxmLmhpZGUpOyB9XG4gICAgICB9IGVsc2UgaWYgKG9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXShvcHMudHJpZ2dlciwgc2VsZi50b2dnbGUpO1xuICAgICAgfSBlbHNlIGlmIChvcHMudHJpZ2dlciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICBpZiAoaXNJcGhvbmUpIHsgZWxlbWVudFthY3Rpb25dKCdjbGljaycsIGZvcmNlRm9jdXMsIGZhbHNlKTsgfVxuICAgICAgICBlbGVtZW50W2FjdGlvbl0ob3BzLnRyaWdnZXIsIHNlbGYudG9nZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hIYW5kbGVyKGUpIHtcbiAgICAgIGlmICgocG9wb3ZlciAmJiBwb3BvdmVyLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIDsgZWxzZSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBldmVudCB0b2dnbGVcbiAgICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlclRvZ2dsZShhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBpZiAob3BzLmRpc21pc3NpYmxlKSB7XG4gICAgICAgIGRvY3VtZW50W2FjdGlvbl0oJ2NsaWNrJywgZGlzbWlzc2libGVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdmb2N1cycpIHsgZWxlbWVudFthY3Rpb25dKCdibHVyJywgc2VsZi5oaWRlKTsgfVxuICAgICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHsgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpOyB9XG4gICAgICB9XG4gICAgICB3aW5kb3dbYWN0aW9uXSgncmVzaXplJywgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHRyaWdnZXJzXG4gICAgZnVuY3Rpb24gc2hvd1RyaWdnZXIoKSB7XG4gICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgxKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGlkZVRyaWdnZXIoKSB7XG4gICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgpO1xuICAgICAgcmVtb3ZlUG9wb3ZlcigpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kcyAvIGhhbmRsZXJzXG4gICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICBjcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgdXBkYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIHNob3dQb3BvdmVyKCk7XG4gICAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3Zlciwgc2hvd1RyaWdnZXIpOyB9XG4gICAgICAgICAgZWxzZSB7IHNob3dUcmlnZ2VyKCk7IH1cbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH07XG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwb3BvdmVyICYmIHBvcG92ZXIgIT09IG51bGwgJiYgcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBwb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBoaWRlVHJpZ2dlcik7IH1cbiAgICAgICAgICBlbHNlIHsgaGlkZVRyaWdnZXIoKTsgfVxuICAgICAgICB9XG4gICAgICB9LCBvcHMuZGVsYXkpO1xuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LlBvcG92ZXI7XG4gICAgfTtcblxuICAgIC8vIElOSVRcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3IoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuUG9wb3ZlcikgeyBlbGVtZW50LlBvcG92ZXIuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0cmlnZ2VyRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRyaWdnZXInKTsgLy8gY2xpY2sgLyBob3ZlciAvIGZvY3VzXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTsgLy8gdHJ1ZSAvIGZhbHNlXG5cbiAgICB2YXIgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcpO1xuICAgIHZhciBkaXNtaXNzaWJsZURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNtaXNzaWJsZScpO1xuICAgIHZhciBkZWxheURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheScpO1xuICAgIHZhciBjb250YWluZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGFpbmVyJyk7XG5cbiAgICAvLyBjbG9zZSBidG4gZm9yIGRpc3NtaXNzaWJsZSBwb3BvdmVyXG4gICAgY2xvc2VCdG4gPSAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiPsOXPC9idXR0b24+JztcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdwb3BvdmVyJyk7XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICdwb3BvdmVyJyk7XG4gICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAncG9wb3ZlcicpO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICdwb3BvdmVyJyk7XG5cbiAgICAvLyBjaGVjayBjb250YWluZXJcbiAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRGF0YSk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgIHZhciBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgICB2YXIgbmF2YmFyRml4ZWRUb3AgPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC10b3AnKTtcbiAgICB2YXIgbmF2YmFyRml4ZWRCb3R0b20gPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC1ib3R0b20nKTtcblxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgICBvcHMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlciA/IG9wdGlvbnMudHJpZ2dlciA6IHRyaWdnZXJEYXRhIHx8ICdob3Zlcic7XG4gICAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSAnZmFkZScgPyBvcHRpb25zLmFuaW1hdGlvbiA6IGFuaW1hdGlvbkRhdGEgfHwgJ2ZhZGUnO1xuICAgIG9wcy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA/IG9wdGlvbnMucGxhY2VtZW50IDogcGxhY2VtZW50RGF0YSB8fCAndG9wJztcbiAgICBvcHMuZGVsYXkgPSBwYXJzZUludCgob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpLCAxMCkgfHwgMjAwO1xuICAgIG9wcy5kaXNtaXNzaWJsZSA9ICEhKG9wdGlvbnMuZGlzbWlzc2libGUgfHwgZGlzbWlzc2libGVEYXRhID09PSAndHJ1ZScpO1xuICAgIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50XG4gICAgICB8fCAoY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgfHwgKG5hdmJhckZpeGVkVG9wIHx8IChuYXZiYXJGaXhlZEJvdHRvbSB8fCAobW9kYWwgfHwgZG9jdW1lbnQuYm9keSkpKSk7XG5cbiAgICBwbGFjZW1lbnRDbGFzcyA9IFwiYnMtcG9wb3Zlci1cIiArIChvcHMucGxhY2VtZW50KTtcblxuICAgIC8vIGludmFsaWRhdGVcbiAgICB0aXRsZVN0cmluZyA9IGdldFRpdGxlKCk7XG4gICAgY29udGVudFN0cmluZyA9IGdldENvbnRlbnQoKTtcblxuICAgIGlmICghY29udGVudFN0cmluZyAmJiAhb3BzLnRlbXBsYXRlKSB7IHJldHVybjsgfVxuXG4gICAgLy8gaW5pdFxuICAgIGlmICghZWxlbWVudC5Qb3BvdmVyKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICB0b2dnbGVFdmVudHMoMSk7XG4gICAgfVxuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB0byBpbml0IG9iamVjdFxuICAgIGVsZW1lbnQuUG9wb3ZlciA9IHNlbGY7XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDUgfCBTY3JvbGxTcHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gU0NST0xMU1BZIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbSwgb3BzSW5wdXQpIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBvcHNJbnB1dCB8fCB7fTtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBHQyBpbnRlcm5hbHNcbiAgICB2YXIgdmFycztcbiAgICB2YXIgbGlua3M7XG5cbiAgICAvLyB0YXJnZXRzXG4gICAgdmFyIHNweVRhcmdldDtcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggaXMgdGhlIHJlYWwgc2Nyb2xsVGFyZ2V0XG4gICAgdmFyIHNjcm9sbFRhcmdldDtcbiAgICAvLyBvcHRpb25zXG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgLy8gcG9wdWxhdGUgaXRlbXMgYW5kIHRhcmdldHNcbiAgICBmdW5jdGlvbiB1cGRhdGVUYXJnZXRzKCkge1xuICAgICAgbGlua3MgPSBzcHlUYXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0EnKTtcblxuICAgICAgdmFycy5zY3JvbGxUb3AgPSB2YXJzLmlzV2luZG93ID8gZ2V0U2Nyb2xsKCkueSA6IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAvLyBvbmx5IHVwZGF0ZSB2YXJzIG9uY2Ugb3Igd2l0aCBlYWNoIG11dGF0aW9uXG4gICAgICBpZiAodmFycy5sZW5ndGggIT09IGxpbmtzLmxlbmd0aCB8fCBnZXRTY3JvbGxIZWlnaHQoKSAhPT0gdmFycy5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGhyZWY7XG4gICAgICAgIHZhciB0YXJnZXRJdGVtO1xuICAgICAgICB2YXIgcmVjdDtcblxuICAgICAgICAvLyByZXNldCBhcnJheXMgJiB1cGRhdGVcbiAgICAgICAgdmFycy5pdGVtcyA9IFtdO1xuICAgICAgICB2YXJzLm9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFycy5zY3JvbGxIZWlnaHQgPSBnZXRTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgdmFycy5tYXhTY3JvbGwgPSB2YXJzLnNjcm9sbEhlaWdodCAtIGdldE9mZnNldEhlaWdodCgpO1xuXG4gICAgICAgIEFycmF5LmZyb20obGlua3MpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICB0YXJnZXRJdGVtID0gaHJlZiAmJiBocmVmLmNoYXJBdCgwKSA9PT0gJyMnICYmIGhyZWYuc2xpY2UoLTEpICE9PSAnIycgJiYgcXVlcnlTZWxlY3RvcihocmVmKTtcblxuICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7XG4gICAgICAgICAgICB2YXJzLml0ZW1zLnB1c2gobGluayk7XG4gICAgICAgICAgICByZWN0ID0gdGFyZ2V0SXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhcnMub2Zmc2V0cy5wdXNoKCh2YXJzLmlzV2luZG93XG4gICAgICAgICAgICAgID8gcmVjdC50b3AgKyB2YXJzLnNjcm9sbFRvcFxuICAgICAgICAgICAgICA6IHRhcmdldEl0ZW0ub2Zmc2V0VG9wKSAtIG9wcy5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhcnMubGVuZ3RoID0gdmFycy5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGl0ZW0gdXBkYXRlXG4gICAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFkZCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIHNjcm9sbFRhcmdldFthY3Rpb25dKCdzY3JvbGwnLCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICAgIHdpbmRvd1thY3Rpb25dKCdyZXNpemUnLCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHNjcm9sbFRhcmdldC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gIXZhcnMuaXNXaW5kb3cgPyBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBBcnJheS5mcm9tKGxpbmtzKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSAmJiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aXZhdGUoaW5wdXQpIHtcbiAgICAgIHZhciBpdGVtID0gaW5wdXQ7XG4gICAgICB2YXIgaXRlbUNsYXNzTGlzdDtcbiAgICAgIGNsZWFyKCk7XG4gICAgICB2YXJzLmFjdGl2ZUl0ZW0gPSBpdGVtO1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgICAgLy8gYWN0aXZhdGUgYWxsIHBhcmVudHNcbiAgICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgICB3aGlsZSAoaXRlbS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudE5vZGU7XG4gICAgICAgIGl0ZW1DbGFzc0xpc3QgPSBpdGVtLmNsYXNzTGlzdDtcblxuICAgICAgICBpZiAoaXRlbUNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24tbWVudScpIHx8IGl0ZW1DbGFzc0xpc3QuY29udGFpbnMoJ25hdicpKSB7IHBhcmVudHMucHVzaChpdGVtKTsgfVxuICAgICAgfVxuXG4gICAgICBwYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKG1lbnVJdGVtKSB7XG4gICAgICAgIHZhciBwYXJlbnRMaW5rID0gbWVudUl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcblxuICAgICAgICBpZiAocGFyZW50TGluayAmJiAhcGFyZW50TGluay5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgcGFyZW50TGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBib290c3RyYXBDdXN0b21FdmVudCgnYWN0aXZhdGUnLCAnc2Nyb2xsc3B5JywgeyByZWxhdGVkVGFyZ2V0OiB2YXJzLmFjdGl2ZUl0ZW0gfSkpO1xuICAgIH1cblxuICAgIC8vIHB1YmxpYyBtZXRob2RcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVUYXJnZXRzKCk7XG5cbiAgICAgIGlmICh2YXJzLnNjcm9sbFRvcCA+PSB2YXJzLm1heFNjcm9sbCkge1xuICAgICAgICB2YXIgbmV3QWN0aXZlSXRlbSA9IHZhcnMuaXRlbXNbdmFycy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodmFycy5hY3RpdmVJdGVtICE9PSBuZXdBY3RpdmVJdGVtKSB7XG4gICAgICAgICAgYWN0aXZhdGUobmV3QWN0aXZlSXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2YXJzLmFjdGl2ZUl0ZW0gJiYgdmFycy5zY3JvbGxUb3AgPCB2YXJzLm9mZnNldHNbMF0gJiYgdmFycy5vZmZzZXRzWzBdID4gMCkge1xuICAgICAgICB2YXJzLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICAgICAgICBjbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gdmFycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA+IC0xKSB7XG4gICAgICAgIGlmICh2YXJzLmFjdGl2ZUl0ZW0gIT09IHZhcnMuaXRlbXNbaV0gJiYgdmFycy5zY3JvbGxUb3AgPj0gdmFycy5vZmZzZXRzW2ldXG4gICAgICAgICAgJiYgKHR5cGVvZiB2YXJzLm9mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fCB2YXJzLnNjcm9sbFRvcCA8IHZhcnMub2Zmc2V0c1tpICsgMV0pKSB7XG4gICAgICAgICAgYWN0aXZhdGUodmFycy5pdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaSAtPSAxO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgICBkZWxldGUgZWxlbWVudC5TY3JvbGxTcHk7XG4gICAgfTtcblxuICAgIC8vIGluaXRcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50LCB0aGUgZWxlbWVudCB3ZSBzcHkgb25cbiAgICBlbGVtZW50ID0gcXVlcnlTZWxlY3RvcihlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5TY3JvbGxTcHkpIHsgZWxlbWVudC5TY3JvbGxTcHkuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBldmVudCB0YXJnZXRzLCBjb25zdGFudHNcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0YXJnZXREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0Jyk7XG4gICAgdmFyIG9mZnNldERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vZmZzZXQnKTtcblxuICAgIC8vIHRhcmdldHNcbiAgICBzcHlUYXJnZXQgPSBxdWVyeVNlbGVjdG9yKG9wdGlvbnMudGFyZ2V0IHx8IHRhcmdldERhdGEpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSByZWFsIHNjcm9sbFRhcmdldFxuICAgIHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgPyBlbGVtZW50IDogd2luZG93O1xuXG4gICAgaWYgKCFzcHlUYXJnZXQpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uXG4gICAgb3BzLm9mZnNldCA9ICsob3B0aW9ucy5vZmZzZXQgfHwgb2Zmc2V0RGF0YSkgfHwgMTA7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2UgcHJpb3JpdHkgdmFyaWFibGVzXG4gICAgdmFycyA9IHt9O1xuICAgIHZhcnMubGVuZ3RoID0gMDtcbiAgICB2YXJzLml0ZW1zID0gW107XG4gICAgdmFycy5vZmZzZXRzID0gW107XG4gICAgdmFycy5pc1dpbmRvdyA9IHNjcm9sbFRhcmdldCA9PT0gd2luZG93O1xuICAgIHZhcnMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgdmFycy5zY3JvbGxIZWlnaHQgPSAwO1xuICAgIHZhcnMubWF4U2Nyb2xsID0gMDtcblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LlNjcm9sbFNweSkgeyB0b2dnbGVFdmVudHMoMSk7IH1cblxuICAgIHNlbGYucmVmcmVzaCgpO1xuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB3aXRoIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5TY3JvbGxTcHkgPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVGFiXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIFRBQiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gVGFiKGVsZW0sIG9wc0lucHV0KSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGV2ZW50IHRhcmdldHNcbiAgICB2YXIgdGFicztcbiAgICB2YXIgZHJvcGRvd247XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcblxuICAgIC8vIG1vcmUgR0MgbWF0ZXJpYWxcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgdGFic0NvbnRlbnRDb250YWluZXIgPSBmYWxzZTtcbiAgICB2YXIgYWN0aXZlVGFiO1xuICAgIHZhciBhY3RpdmVDb250ZW50O1xuICAgIHZhciBuZXh0Q29udGVudDtcbiAgICB2YXIgY29udGFpbmVySGVpZ2h0O1xuICAgIHZhciBlcXVhbENvbnRlbnRzO1xuICAgIHZhciBuZXh0SGVpZ2h0O1xuXG4gICAgLy8gdHJpZ2dlcnNcbiAgICBmdW5jdGlvbiB0cmlnZ2VyRW5kKCkge1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaWdnZXJTaG93KCkge1xuICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgaWYgKGVxdWFsQ29udGVudHMpIHtcbiAgICAgICAgICB0cmlnZ2VyRW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IC8vIGVuYWJsZXMgaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodCArIFwicHhcIjsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgICAgcmVmbG93KHRhYnNDb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRhYnNDb250ZW50Q29udGFpbmVyLCB0cmlnZ2VyRW5kKTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVUYWIgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd25DdXN0b21FdmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaWdnZXJIaWRlKCkge1xuICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICAgIGFjdGl2ZUNvbnRlbnQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gICAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBhY3RpdmVDb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVUYWIgfSk7XG4gICAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBuZXh0IH0pO1xuXG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cblxuICAgICAgbmV4dENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICAgIGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICBuZXh0SGVpZ2h0ID0gbmV4dENvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBlcXVhbENvbnRlbnRzID0gbmV4dEhlaWdodCA9PT0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lckhlaWdodCArIFwicHhcIjsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICByZWZsb3codGFic0NvbnRlbnRDb250YWluZXIpO1xuICAgICAgICBhY3RpdmVDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q29udGVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBuZXh0Q29udGVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQobmV4dENvbnRlbnQsIHRyaWdnZXJTaG93KTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfSBlbHNlIHsgdHJpZ2dlclNob3coKTsgfVxuXG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgfVxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZVRhYigpIHtcbiAgICAgIHZhciBhc3NpZ247XG5cbiAgICAgIHZhciBhY3RpdmVUYWJzID0gdGFicy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKTtcblxuICAgICAgaWYgKGFjdGl2ZVRhYnMubGVuZ3RoID09PSAxICYmICFhY3RpdmVUYWJzWzBdLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bicpKSB7XG4gICAgICAgIChhc3NpZ24gPSBhY3RpdmVUYWJzLCBhY3RpdmVUYWIgPSBhc3NpZ25bMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmVUYWJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1thY3RpdmVUYWJzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZVRhYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGVudCgpIHsgcmV0dXJuIHF1ZXJ5U2VsZWN0b3IoZ2V0QWN0aXZlVGFiKCkuZ2V0QXR0cmlidXRlKCdocmVmJykpOyB9XG4gICAgLy8gaGFuZGxlclxuICAgIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBuZXh0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgaWYgKCF0YWJzLmlzQW5pbWF0aW5nKSB7IHNlbGYuc2hvdygpOyB9XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHsgLy8gdGhlIHRhYiB3ZSBjbGlja2VkIGlzIG5vdyB0aGUgbmV4dCB0YWJcbiAgICAgIG5leHQgPSBuZXh0IHx8IGVsZW1lbnQ7XG5cbiAgICAgIGlmICghbmV4dC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgIG5leHRDb250ZW50ID0gcXVlcnlTZWxlY3RvcihuZXh0LmdldEF0dHJpYnV0ZSgnaHJlZicpKTsgLy8gdGhpcyBpcyB0aGUgYWN0dWFsIG9iamVjdCwgdGhlIG5leHQgdGFiIGNvbnRlbnQgdG8gYWN0aXZhdGVcbiAgICAgICAgYWN0aXZlVGFiID0gZ2V0QWN0aXZlVGFiKCk7XG4gICAgICAgIGFjdGl2ZUNvbnRlbnQgPSBnZXRBY3RpdmVDb250ZW50KCk7XG5cbiAgICAgICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBuZXh0IH0pO1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdGFicy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIGFjdGl2ZVRhYi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgYWN0aXZlVGFiLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICBuZXh0LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICBuZXh0LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG5cbiAgICAgICAgaWYgKGRyb3Bkb3duKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1tZW51JykpIHtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7IGRyb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpOyB9XG4gICAgICAgICAgfSBlbHNlIGlmICghZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBkcm9wZG93bi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykpIHtcbiAgICAgICAgICBhY3RpdmVDb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChhY3RpdmVDb250ZW50LCB0cmlnZ2VySGlkZSk7XG4gICAgICAgIH0gZWxzZSB7IHRyaWdnZXJIaWRlKCk7IH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LlRhYjtcbiAgICB9O1xuXG4gICAgLy8gSU5JVFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlTZWxlY3RvcihlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5UYWIpIHsgZWxlbWVudC5UYWIuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBoZWlnaHREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGVpZ2h0Jyk7XG4gICAgLy8gZXZlbnQgdGFyZ2V0c1xuICAgIHRhYnMgPSBlbGVtZW50LmNsb3Nlc3QoJy5uYXYnKTtcbiAgICBkcm9wZG93biA9IHRhYnMgJiYgcXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLXRvZ2dsZScsIHRhYnMpO1xuXG4gICAgLy8gaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHZhciBhbmltYXRlSGVpZ2h0ID0gISghc3VwcG9ydFRyYW5zaXRpb24gfHwgKG9wdGlvbnMuaGVpZ2h0ID09PSBmYWxzZSB8fCBoZWlnaHREYXRhID09PSAnZmFsc2UnKSk7XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBhbmltYXRpb24gc3RhdGVcbiAgICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBpbml0XG4gICAgaWYgKCFlbGVtZW50LlRhYikgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlSGVpZ2h0KSB7IHRhYnNDb250ZW50Q29udGFpbmVyID0gZ2V0QWN0aXZlQ29udGVudCgpLnBhcmVudE5vZGU7IH1cblxuICAgIC8vIGFzc29jaWF0ZSB0YXJnZXQgd2l0aCBpbml0IG9iamVjdFxuICAgIGVsZW1lbnQuVGFiID0gc2VsZjtcbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFRvYXN0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gVE9BU1QgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBUb2FzdChlbGVtLCBvcHNJbnB1dCkge1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHRvYXN0LCB0aW1lclxuICAgIHZhciB0b2FzdDtcbiAgICB2YXIgdGltZXIgPSAwO1xuXG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHZhciBzaG93Q3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGVDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZGVuQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgZnVuY3Rpb24gc2hvd0NvbXBsZXRlKCkge1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgnc2hvd2luZycpO1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChvcHMuYXV0b2hpZGUpIHsgc2VsZi5oaWRlKCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGlkZUNvbXBsZXRlKCkge1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGhpZGVDb21wbGV0ZSk7IH1cbiAgICAgIGVsc2UgeyBoaWRlQ29tcGxldGUoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlQ29tcGxldGUoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuaGlkZSwgZmFsc2UpO1xuXG4gICAgICBkZWxldGUgZWxlbWVudC5Ub2FzdDtcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0b2FzdCAmJiAhdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChvcHMuYW5pbWF0aW9uKSB7IHRvYXN0LmNsYXNzTGlzdC5hZGQoJ2ZhZGUnKTsgfVxuICAgICAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJyk7XG4gICAgICAgIHJlZmxvdyh0b2FzdCk7IC8vIGZvcmNlIHJlZmxvd1xuICAgICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCdzaG93aW5nJyk7XG5cbiAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIHNob3dDb21wbGV0ZSk7IH1cbiAgICAgICAgZWxzZSB7IHNob3dDb21wbGV0ZSgpOyB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAobm9UaW1lcikge1xuICAgICAgaWYgKHRvYXN0ICYmIHRvYXN0LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChub1RpbWVyKSB7IGNsb3NlKCk7IH1cbiAgICAgICAgZWxzZSB7IHRpbWVyID0gc2V0VGltZW91dChjbG9zZSwgb3BzLmRlbGF5KTsgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGRpc3Bvc2VDb21wbGV0ZSk7IH1cbiAgICAgIGVsc2UgeyBkaXNwb3NlQ29tcGxldGUoKTsgfVxuICAgIH07XG5cbiAgICAvLyBpbml0XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3IoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuVG9hc3QpIHsgZWxlbWVudC5Ub2FzdC5kaXNwb3NlKCk7IH1cblxuICAgIC8vIHRvYXN0LCB0aW1lclxuICAgIHRvYXN0ID0gZWxlbWVudC5jbG9zZXN0KCcudG9hc3QnKTtcblxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB2YXIgYXV0b2hpZGVEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXV0b2hpZGUnKTtcbiAgICB2YXIgZGVsYXlEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXknKTtcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICd0b2FzdCcpO1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3RvYXN0Jyk7XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICd0b2FzdCcpO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICd0b2FzdCcpO1xuXG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICBvcHMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gPT09IGZhbHNlIHx8IGFuaW1hdGlvbkRhdGEgPT09ICdmYWxzZScgPyAwIDogMTsgLy8gdHJ1ZSBieSBkZWZhdWx0XG4gICAgb3BzLmF1dG9oaWRlID0gb3B0aW9ucy5hdXRvaGlkZSA9PT0gZmFsc2UgfHwgYXV0b2hpZGVEYXRhID09PSAnZmFsc2UnID8gMCA6IDE7IC8vIHRydWUgYnkgZGVmYXVsdFxuICAgIG9wcy5kZWxheSA9IHBhcnNlSW50KChvcHRpb25zLmRlbGF5IHx8IGRlbGF5RGF0YSksIDEwKSB8fCA1MDA7IC8vIDUwMG1zIGRlZmF1bHRcblxuICAgIGlmICghZWxlbWVudC5Ub2FzdCkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuaGlkZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIGFzc29jaWF0ZSB0YXJnZXRzIHRvIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5Ub2FzdCA9IHNlbGY7XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBUb29sdGlwXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBUT09MVElQIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gVG9vbHRpcChlbGVtLCBvcHNJbnB1dCkge1xuICAgIHZhciBlbGVtZW50O1xuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBvcHNJbnB1dCB8fCB7fTtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyB0b29sdGlwLCB0aW1lciwgYW5kIHRpdGxlXG4gICAgdmFyIHRvb2x0aXAgPSBudWxsO1xuICAgIHZhciB0aW1lciA9IDA7XG4gICAgdmFyIHRpdGxlU3RyaW5nO1xuICAgIHZhciBwbGFjZW1lbnRDbGFzcztcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICB2YXIgc2hvd0N1c3RvbUV2ZW50O1xuICAgIHZhciBzaG93bkN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGRlbkN1c3RvbUV2ZW50O1xuXG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICAgICAgICB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpXG4gICAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVG9vbFRpcCgpIHtcbiAgICAgIG9wcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodG9vbHRpcCk7XG4gICAgICB0b29sdGlwID0gbnVsbDsgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUb29sVGlwKCkge1xuICAgICAgdGl0bGVTdHJpbmcgPSBnZXRUaXRsZSgpOyAvLyByZWFkIHRoZSB0aXRsZSBhZ2FpblxuICAgICAgaWYgKHRpdGxlU3RyaW5nKSB7IC8vIGludmFsaWRhdGUsIG1heWJlIG1hcmt1cCBjaGFuZ2VkXG4gICAgICAgIC8vIGNyZWF0ZSB0b29sdGlwXG4gICAgICAgIHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAvLyBzZXQgbWFya3VwXG4gICAgICAgIGlmIChvcHMudGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcE1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRvb2x0aXBNYXJrdXAuaW5uZXJIVE1MID0gb3BzLnRlbXBsYXRlLnRyaW0oKTtcblxuICAgICAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gdG9vbHRpcE1hcmt1cC5maXJzdENoaWxkLmNsYXNzTmFtZTtcbiAgICAgICAgICB0b29sdGlwLmlubmVySFRNTCA9IHRvb2x0aXBNYXJrdXAuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG5cbiAgICAgICAgICBxdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1pbm5lcicsIHRvb2x0aXApLmlubmVySFRNTCA9IHRpdGxlU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0b29sdGlwIGFycm93XG4gICAgICAgICAgdmFyIHRvb2x0aXBBcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRvb2x0aXBBcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpO1xuICAgICAgICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQodG9vbHRpcEFycm93KTtcbiAgICAgICAgICAvLyB0b29sdGlwIGlubmVyXG4gICAgICAgICAgdmFyIHRvb2x0aXBJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lci5jbGFzc0xpc3QuYWRkKCd0b29sdGlwLWlubmVyJyk7XG4gICAgICAgICAgdG9vbHRpcC5hcHBlbmRDaGlsZCh0b29sdGlwSW5uZXIpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lci5pbm5lckhUTUwgPSB0aXRsZVN0cmluZztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCBwb3NpdGlvblxuICAgICAgICB0b29sdGlwLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRvb2x0aXAuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICAvLyBzZXQgY2xhc3MgYW5kIHJvbGUgYXR0cmlidXRlXG4gICAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcbiAgICAgICAgaWYgKCF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygndG9vbHRpcCcpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgndG9vbHRpcCcpOyB9XG4gICAgICAgIGlmICghdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMob3BzLmFuaW1hdGlvbikpIHsgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKG9wcy5hbmltYXRpb24pOyB9XG4gICAgICAgIGlmICghdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMocGxhY2VtZW50Q2xhc3MpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7IH1cbiAgICAgICAgLy8gYXBwZW5kIHRvIGNvbnRhaW5lclxuICAgICAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUb29sdGlwKCkge1xuICAgICAgc3R5bGVUaXAoZWxlbWVudCwgdG9vbHRpcCwgb3BzLnBsYWNlbWVudCwgb3BzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICAgaWYgKCF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnc2hvdycpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvdWNoSGFuZGxlcihlKSB7XG4gICAgICBpZiAoKHRvb2x0aXAgJiYgdG9vbHRpcC5jb250YWlucyhlLnRhcmdldCkpXG4gICAgICAgIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSA7IGVsc2Uge1xuICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdHJpZ2dlcnNcbiAgICBmdW5jdGlvbiB0b2dnbGVBY3Rpb24oYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYuaGlkZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG93QWN0aW9uKCkge1xuICAgICAgdG9nZ2xlQWN0aW9uKDEpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlQWN0aW9uKCkge1xuICAgICAgdG9nZ2xlQWN0aW9uKCk7XG4gICAgICByZW1vdmVUb29sVGlwKCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93LCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1swXSwgc2VsZi5zaG93LCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1sxXSwgc2VsZi5oaWRlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgLy8gaWYoY3JlYXRlVG9vbFRpcCgpID09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYgKGNyZWF0ZVRvb2xUaXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBzaG93QWN0aW9uKTsgfVxuICAgICAgICAgICAgZWxzZSB7IHNob3dBY3Rpb24oKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH07XG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgaGlkZUFjdGlvbik7IH1cbiAgICAgICAgICBlbHNlIHsgaGlkZUFjdGlvbigpOyB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9wcy5kZWxheSk7XG4gICAgfTtcbiAgICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdG9vbHRpcCkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSk7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuVG9vbHRpcDtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlTZWxlY3RvcihlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5Ub29sdGlwKSB7IGVsZW1lbnQuVG9vbHRpcC5kaXNwb3NlKCk7IH1cblxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB2YXIgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcpO1xuICAgIHZhciBkZWxheURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheScpO1xuICAgIHZhciBjb250YWluZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGFpbmVyJyk7XG5cbiAgICAvLyBjaGVjayBjb250YWluZXJcbiAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRGF0YSk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgIHZhciBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndG9vbHRpcCcpO1xuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndG9vbHRpcCcpO1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3Rvb2x0aXAnKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndG9vbHRpcCcpO1xuXG4gICAgLy8gbWF5YmUgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGEgZml4ZWQgbmF2YmFyXG4gICAgdmFyIG5hdmJhckZpeGVkVG9wID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtdG9wJyk7XG4gICAgdmFyIG5hdmJhckZpeGVkQm90dG9tID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtYm90dG9tJyk7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIG9wcy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gJ2ZhZGUnID8gb3B0aW9ucy5hbmltYXRpb24gOiBhbmltYXRpb25EYXRhIHx8ICdmYWRlJztcbiAgICBvcHMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPyBvcHRpb25zLnBsYWNlbWVudCA6IHBsYWNlbWVudERhdGEgfHwgJ3RvcCc7XG4gICAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgICBvcHMuZGVsYXkgPSBwYXJzZUludCgob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpLCAxMCkgfHwgMjAwO1xuICAgIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50XG4gICAgICB8fCAoY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgfHwgKG5hdmJhckZpeGVkVG9wIHx8IChuYXZiYXJGaXhlZEJvdHRvbSB8fCAobW9kYWwgfHwgZG9jdW1lbnQuYm9keSkpKSk7XG5cbiAgICAvLyBzZXQgcGxhY2VtZW50IGNsYXNzXG4gICAgcGxhY2VtZW50Q2xhc3MgPSBcImJzLXRvb2x0aXAtXCIgKyAob3BzLnBsYWNlbWVudCk7XG5cbiAgICAvLyBzZXQgdG9vbHRpcCBjb250ZW50XG4gICAgdGl0bGVTdHJpbmcgPSBnZXRUaXRsZSgpO1xuXG4gICAgLy8gaW52YWxpZGF0ZVxuICAgIGlmICghdGl0bGVTdHJpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgIGlmICghZWxlbWVudC5Ub29sdGlwKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRpdGxlU3RyaW5nKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgdG9nZ2xlRXZlbnRzKDEpO1xuICAgIH1cblxuICAgIC8vIGFzc29jaWF0ZSB0YXJnZXQgdG8gaW5pdCBvYmplY3RcbiAgICBlbGVtZW50LlRvb2x0aXAgPSBzZWxmO1xuICB9XG5cbiAgLyoqIEJTTiB2NCBjb21wb25lbnRzSW5pdCAqL1xuICB2YXIgY29tcG9uZW50c0luaXQgPSB7fTtcblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIHY0IHwgSW5pdGlhbGl6ZSBEYXRhIEFQSVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBmdW5jdGlvbiBpbml0aWFsaXplRGF0YUFQSShDb25zdHJ1Y3RvciwgY29sbGVjdGlvbikge1xuICAgIEFycmF5LmZyb20oY29sbGVjdGlvbikubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IoeCk7IH0pO1xuICB9XG4gIGZ1bmN0aW9uIGluaXRDYWxsYmFjayhjb250ZXh0KSB7XG4gICAgdmFyIGxvb2tVcCA9IGNvbnRleHQgaW5zdGFuY2VvZiBFbGVtZW50ID8gY29udGV4dCA6IGRvY3VtZW50O1xuICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudHNJbml0KS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIGluaXRpYWxpemVEYXRhQVBJKGNvbXBvbmVudHNJbml0W2NvbXBvbmVudF1bMF0sXG4gICAgICAgIGxvb2tVcC5xdWVyeVNlbGVjdG9yQWxsKGNvbXBvbmVudHNJbml0W2NvbXBvbmVudF1bMV0pKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudHNJbml0LkFsZXJ0ID0gW0FsZXJ0LCAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ107XG4gIGNvbXBvbmVudHNJbml0LkJ1dHRvbiA9IFtCdXR0b24sICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LkNhcm91c2VsID0gW0Nhcm91c2VsLCAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LkNvbGxhcHNlID0gW0NvbGxhcHNlLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXTtcbiAgY29tcG9uZW50c0luaXQuRHJvcGRvd24gPSBbRHJvcGRvd24sICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSddO1xuICBjb21wb25lbnRzSW5pdC5Nb2RhbCA9IFtNb2RhbCwgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LlBvcG92ZXIgPSBbUG9wb3ZlciwgJ1tkYXRhLXRvZ2dsZT1cInBvcG92ZXJcIl0sW2RhdGEtdGlwPVwicG9wb3ZlclwiXSddO1xuICBjb21wb25lbnRzSW5pdC5TY3JvbGxTcHkgPSBbU2Nyb2xsU3B5LCAnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LlRhYiA9IFtUYWIsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nXTtcbiAgY29tcG9uZW50c0luaXQuVG9hc3QgPSBbVG9hc3QsICdbZGF0YS1kaXNtaXNzPVwidG9hc3RcIl0nXTtcbiAgY29tcG9uZW50c0luaXQuVG9vbHRpcCA9IFtUb29sdGlwLCAnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXSxbZGF0YS10aXA9XCJ0b29sdGlwXCJdJ107XG5cbiAgLy8gYnVsayBpbml0aWFsaXplIGFsbCBjb21wb25lbnRzXG4gIGlmIChkb2N1bWVudC5ib2R5KSB7IGluaXRDYWxsYmFjaygpOyB9XG4gIGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiBpbml0V3JhcHBlcigpIHtcbiAgICAgIGluaXRDYWxsYmFjaygpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRXcmFwcGVyLCBmYWxzZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCB2NCB8IFJlbW92ZSBEYXRhIEFQSVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnREYXRhQVBJKENvbnN0cnVjdG9yTmFtZSwgY29sbGVjdGlvbikge1xuICAgIEFycmF5LmZyb20oY29sbGVjdGlvbikubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4W0NvbnN0cnVjdG9yTmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVEYXRhQVBJKGNvbnRleHQpIHtcbiAgICB2YXIgbG9va1VwID0gY29udGV4dCBpbnN0YW5jZW9mIEVsZW1lbnQgPyBjb250ZXh0IDogZG9jdW1lbnQ7XG4gICAgT2JqZWN0LmtleXMoY29tcG9uZW50c0luaXQpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmVtb3ZlRWxlbWVudERhdGFBUEkoY29tcG9uZW50LCBsb29rVXAucXVlcnlTZWxlY3RvckFsbChjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzFdKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IFwiNC4xLjBcIjtcblxuICB2YXIgVmVyc2lvbiA9IHZlcnNpb247XG5cbiAgdmFyIEJTTiA9IHtcbiAgICBBbGVydDogQWxlcnQsXG4gICAgQnV0dG9uOiBCdXR0b24sXG4gICAgQ2Fyb3VzZWw6IENhcm91c2VsLFxuICAgIENvbGxhcHNlOiBDb2xsYXBzZSxcbiAgICBEcm9wZG93bjogRHJvcGRvd24sXG4gICAgTW9kYWw6IE1vZGFsLFxuICAgIFBvcG92ZXI6IFBvcG92ZXIsXG4gICAgU2Nyb2xsU3B5OiBTY3JvbGxTcHksXG4gICAgVGFiOiBUYWIsXG4gICAgVG9hc3Q6IFRvYXN0LFxuICAgIFRvb2x0aXA6IFRvb2x0aXAsXG5cbiAgICBpbml0Q2FsbGJhY2s6IGluaXRDYWxsYmFjayxcbiAgICByZW1vdmVEYXRhQVBJOiByZW1vdmVEYXRhQVBJLFxuICAgIGNvbXBvbmVudHNJbml0OiBjb21wb25lbnRzSW5pdCxcbiAgICBWZXJzaW9uOiBWZXJzaW9uLFxuICB9O1xuXG4gIHJldHVybiBCU047XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\n");

/***/ }),

/***/ "./node_modules/htmx.org/dist/htmx.min.js":
/*!************************************************!*\
  !*** ./node_modules/htmx.org/dist/htmx.min.js ***!
  \************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e,t){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else{}})(typeof self!==\"undefined\"?self:this,function(){return function(){\"use strict\";var z={onLoad:t,process:mt,on:D,off:X,trigger:ee,ajax:or,find:C,findAll:R,closest:A,values:function(e,t){var r=Bt(e,t||\"post\");return r.values},remove:O,addClass:q,removeClass:T,toggleClass:L,takeClass:H,defineExtension:dr,removeExtension:vr,logAll:E,logger:null,config:{historyEnabled:true,historyCacheSize:10,refreshOnHistoryMiss:false,defaultSwapStyle:\"innerHTML\",defaultSwapDelay:0,defaultSettleDelay:20,includeIndicatorStyles:true,indicatorClass:\"htmx-indicator\",requestClass:\"htmx-request\",addedClass:\"htmx-added\",settlingClass:\"htmx-settling\",swappingClass:\"htmx-swapping\",allowEval:true,inlineScriptNonce:\"\",attributesToSettle:[\"class\",\"style\",\"width\",\"height\"],withCredentials:false,timeout:0,wsReconnectDelay:\"full-jitter\",wsBinaryType:\"blob\",disableSelector:\"[hx-disable], [data-hx-disable]\",useTemplateFragments:false,scrollBehavior:\"smooth\",defaultFocusScroll:false,getCacheBusterParam:false},parseInterval:v,_:e,createEventSource:function(e){return new EventSource(e,{withCredentials:true})},createWebSocket:function(e){var t=new WebSocket(e,[]);t.binaryType=z.config.wsBinaryType;return t},version:\"1.8.5\"};var r={addTriggerHandler:ft,bodyContains:re,canAccessLocalStorage:S,filterValues:Wt,hasAttribute:o,getAttributeValue:J,getClosestMatch:h,getExpressionVars:rr,getHeaders:_t,getInputValues:Bt,getInternalData:K,getSwapSpecification:Gt,getTriggerSpecs:Xe,getTarget:se,makeFragment:f,mergeObjects:ne,makeSettleInfo:Zt,oobSwap:V,selectAndSwap:Oe,settleImmediately:At,shouldCancel:Ve,triggerEvent:ee,triggerErrorEvent:Q,withExtensions:wt};var n=[\"get\",\"post\",\"put\",\"delete\",\"patch\"];var i=n.map(function(e){return\"[hx-\"+e+\"], [data-hx-\"+e+\"]\"}).join(\", \");function v(e){if(e==undefined){return undefined}if(e.slice(-2)==\"ms\"){return parseFloat(e.slice(0,-2))||undefined}if(e.slice(-1)==\"s\"){return parseFloat(e.slice(0,-1))*1e3||undefined}if(e.slice(-1)==\"m\"){return parseFloat(e.slice(0,-1))*1e3*60||undefined}return parseFloat(e)||undefined}function G(e,t){return e.getAttribute&&e.getAttribute(t)}function o(e,t){return e.hasAttribute&&(e.hasAttribute(t)||e.hasAttribute(\"data-\"+t))}function J(e,t){return G(e,t)||G(e,\"data-\"+t)}function u(e){return e.parentElement}function $(){return document}function h(e,t){while(e&&!t(e)){e=u(e)}return e?e:null}function a(e,t,r){var n=J(t,r);var i=J(t,\"hx-disinherit\");if(e!==t&&i&&(i===\"*\"||i.split(\" \").indexOf(r)>=0)){return\"unset\"}else{return n}}function Z(t,r){var n=null;h(t,function(e){return n=a(t,e,r)});if(n!==\"unset\"){return n}}function d(e,t){var r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.webkitMatchesSelector||e.oMatchesSelector;return r&&r.call(e,t)}function s(e){var t=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;var r=t.exec(e);if(r){return r[1].toLowerCase()}else{return\"\"}}function l(e,t){var r=new DOMParser;var n=r.parseFromString(e,\"text/html\");var i=n.body;while(t>0){t--;i=i.firstChild}if(i==null){i=$().createDocumentFragment()}return i}function f(e){if(z.config.useTemplateFragments){var t=l(\"<body><template>\"+e+\"</template></body>\",0);return t.querySelector(\"template\").content}else{var r=s(e);switch(r){case\"thead\":case\"tbody\":case\"tfoot\":case\"colgroup\":case\"caption\":return l(\"<table>\"+e+\"</table>\",1);case\"col\":return l(\"<table><colgroup>\"+e+\"</colgroup></table>\",2);case\"tr\":return l(\"<table><tbody>\"+e+\"</tbody></table>\",2);case\"td\":case\"th\":return l(\"<table><tbody><tr>\"+e+\"</tr></tbody></table>\",3);case\"script\":return l(\"<div>\"+e+\"</div>\",1);default:return l(e,0)}}}function te(e){if(e){e()}}function g(e,t){return Object.prototype.toString.call(e)===\"[object \"+t+\"]\"}function p(e){return g(e,\"Function\")}function m(e){return g(e,\"Object\")}function K(e){var t=\"htmx-internal-data\";var r=e[t];if(!r){r=e[t]={}}return r}function y(e){var t=[];if(e){for(var r=0;r<e.length;r++){t.push(e[r])}}return t}function Y(e,t){if(e){for(var r=0;r<e.length;r++){t(e[r])}}}function x(e){var t=e.getBoundingClientRect();var r=t.top;var n=t.bottom;return r<window.innerHeight&&n>=0}function re(e){if(e.getRootNode&&e.getRootNode()instanceof ShadowRoot){return $().body.contains(e.getRootNode().host)}else{return $().body.contains(e)}}function b(e){return e.trim().split(/\\s+/)}function ne(e,t){for(var r in t){if(t.hasOwnProperty(r)){e[r]=t[r]}}return e}function w(e){try{return JSON.parse(e)}catch(e){St(e);return null}}function S(){var e=\"htmx:localStorageTest\";try{localStorage.setItem(e,e);localStorage.removeItem(e);return true}catch(e){return false}}function e(e){return Qt($().body,function(){return eval(e)})}function t(t){var e=z.on(\"htmx:load\",function(e){t(e.detail.elt)});return e}function E(){z.logger=function(e,t,r){if(console){console.log(t,e,r)}}}function C(e,t){if(t){return e.querySelector(t)}else{return C($(),e)}}function R(e,t){if(t){return e.querySelectorAll(t)}else{return R($(),e)}}function O(e,t){e=M(e);if(t){setTimeout(function(){O(e)},t)}else{e.parentElement.removeChild(e)}}function q(e,t,r){e=M(e);if(r){setTimeout(function(){q(e,t)},r)}else{e.classList&&e.classList.add(t)}}function T(e,t,r){e=M(e);if(r){setTimeout(function(){T(e,t)},r)}else{if(e.classList){e.classList.remove(t);if(e.classList.length===0){e.removeAttribute(\"class\")}}}}function L(e,t){e=M(e);e.classList.toggle(t)}function H(e,t){e=M(e);Y(e.parentElement.children,function(e){T(e,t)});q(e,t)}function A(e,t){e=M(e);if(e.closest){return e.closest(t)}else{do{if(e==null||d(e,t)){return e}}while(e=e&&u(e));return null}}function N(e,t){if(t.indexOf(\"closest \")===0){return[A(e,t.substr(8))]}else if(t.indexOf(\"find \")===0){return[C(e,t.substr(5))]}else if(t.indexOf(\"next \")===0){return[I(e,t.substr(5))]}else if(t.indexOf(\"previous \")===0){return[k(e,t.substr(9))]}else if(t===\"document\"){return[document]}else if(t===\"window\"){return[window]}else{return $().querySelectorAll(t)}}var I=function(e,t){var r=$().querySelectorAll(t);for(var n=0;n<r.length;n++){var i=r[n];if(i.compareDocumentPosition(e)===Node.DOCUMENT_POSITION_PRECEDING){return i}}};var k=function(e,t){var r=$().querySelectorAll(t);for(var n=r.length-1;n>=0;n--){var i=r[n];if(i.compareDocumentPosition(e)===Node.DOCUMENT_POSITION_FOLLOWING){return i}}};function ie(e,t){if(t){return N(e,t)[0]}else{return N($().body,e)[0]}}function M(e){if(g(e,\"String\")){return C(e)}else{return e}}function P(e,t,r){if(p(t)){return{target:$().body,event:e,listener:t}}else{return{target:M(e),event:t,listener:r}}}function D(t,r,n){pr(function(){var e=P(t,r,n);e.target.addEventListener(e.event,e.listener)});var e=p(r);return e?r:n}function X(t,r,n){pr(function(){var e=P(t,r,n);e.target.removeEventListener(e.event,e.listener)});return p(r)?r:n}var ae=$().createElement(\"output\");function F(e,t){var r=Z(e,t);if(r){if(r===\"this\"){return[oe(e,t)]}else{var n=N(e,r);if(n.length===0){St('The selector \"'+r+'\" on '+t+\" returned no matches!\");return[ae]}else{return n}}}}function oe(e,t){return h(e,function(e){return J(e,t)!=null})}function se(e){var t=Z(e,\"hx-target\");if(t){if(t===\"this\"){return oe(e,\"hx-target\")}else{return ie(e,t)}}else{var r=K(e);if(r.boosted){return $().body}else{return e}}}function B(e){var t=z.config.attributesToSettle;for(var r=0;r<t.length;r++){if(e===t[r]){return true}}return false}function j(t,r){Y(t.attributes,function(e){if(!r.hasAttribute(e.name)&&B(e.name)){t.removeAttribute(e.name)}});Y(r.attributes,function(e){if(B(e.name)){t.setAttribute(e.name,e.value)}})}function U(e,t){var r=gr(t);for(var n=0;n<r.length;n++){var i=r[n];try{if(i.isInlineSwap(e)){return true}}catch(e){St(e)}}return e===\"outerHTML\"}function V(e,i,a){var t=\"#\"+i.id;var o=\"outerHTML\";if(e===\"true\"){}else if(e.indexOf(\":\")>0){o=e.substr(0,e.indexOf(\":\"));t=e.substr(e.indexOf(\":\")+1,e.length)}else{o=e}var r=$().querySelectorAll(t);if(r){Y(r,function(e){var t;var r=i.cloneNode(true);t=$().createDocumentFragment();t.appendChild(r);if(!U(o,e)){t=r}var n={shouldSwap:true,target:e,fragment:t};if(!ee(e,\"htmx:oobBeforeSwap\",n))return;e=n.target;if(n[\"shouldSwap\"]){Ce(o,e,e,t,a)}Y(a.elts,function(e){ee(e,\"htmx:oobAfterSwap\",n)})});i.parentNode.removeChild(i)}else{i.parentNode.removeChild(i);Q($().body,\"htmx:oobErrorNoTarget\",{content:i})}return e}function _(e,t,r){var n=Z(e,\"hx-select-oob\");if(n){var i=n.split(\",\");for(let e=0;e<i.length;e++){var a=i[e].split(\":\",2);var o=a[0];if(o.indexOf(\"#\")===0){o=o.substring(1)}var s=a[1]||\"true\";var l=t.querySelector(\"#\"+o);if(l){V(s,l,r)}}}Y(R(t,\"[hx-swap-oob], [data-hx-swap-oob]\"),function(e){var t=J(e,\"hx-swap-oob\");if(t!=null){V(t,e,r)}})}function W(e){Y(R(e,\"[hx-preserve], [data-hx-preserve]\"),function(e){var t=J(e,\"id\");var r=$().getElementById(t);if(r!=null){e.parentNode.replaceChild(r,e)}})}function le(n,e,i){Y(e.querySelectorAll(\"[id]\"),function(e){if(e.id&&e.id.length>0){var t=n.querySelector(e.tagName+\"[id='\"+e.id+\"']\");if(t&&t!==n){var r=e.cloneNode();j(e,t);i.tasks.push(function(){j(e,r)})}}})}function ue(e){return function(){T(e,z.config.addedClass);mt(e);ht(e);fe(e);ee(e,\"htmx:load\")}}function fe(e){var t=\"[autofocus]\";var r=d(e,t)?e:e.querySelector(t);if(r!=null){r.focus()}}function ce(e,t,r,n){le(e,r,n);while(r.childNodes.length>0){var i=r.firstChild;q(i,z.config.addedClass);e.insertBefore(i,t);if(i.nodeType!==Node.TEXT_NODE&&i.nodeType!==Node.COMMENT_NODE){n.tasks.push(ue(i))}}}function he(e,t){var r=0;while(r<e.length){t=(t<<5)-t+e.charCodeAt(r++)|0}return t}function de(e){var t=0;if(e.attributes){for(var r=0;r<e.attributes.length;r++){var n=e.attributes[r];if(n.value){t=he(n.name,t);t=he(n.value,t)}}}return t}function ve(e){var t=K(e);if(t.webSocket){t.webSocket.close()}if(t.sseEventSource){t.sseEventSource.close()}if(t.listenerInfos){Y(t.listenerInfos,function(e){if(e.on){e.on.removeEventListener(e.trigger,e.listener)}})}}function ge(e){ee(e,\"htmx:beforeCleanupElement\");ve(e);if(e.children){Y(e.children,function(e){ge(e)})}}function pe(e,t,r){if(e.tagName===\"BODY\"){return Se(e,t,r)}else{var n;var i=e.previousSibling;ce(u(e),e,t,r);if(i==null){n=u(e).firstChild}else{n=i.nextSibling}K(e).replacedWith=n;r.elts=[];while(n&&n!==e){if(n.nodeType===Node.ELEMENT_NODE){r.elts.push(n)}n=n.nextElementSibling}ge(e);u(e).removeChild(e)}}function me(e,t,r){return ce(e,e.firstChild,t,r)}function ye(e,t,r){return ce(u(e),e,t,r)}function xe(e,t,r){return ce(e,null,t,r)}function be(e,t,r){return ce(u(e),e.nextSibling,t,r)}function we(e,t,r){ge(e);return u(e).removeChild(e)}function Se(e,t,r){var n=e.firstChild;ce(e,n,t,r);if(n){while(n.nextSibling){ge(n.nextSibling);e.removeChild(n.nextSibling)}ge(n);e.removeChild(n)}}function Ee(e,t){var r=Z(e,\"hx-select\");if(r){var n=$().createDocumentFragment();Y(t.querySelectorAll(r),function(e){n.appendChild(e)});t=n}return t}function Ce(e,t,r,n,i){switch(e){case\"none\":return;case\"outerHTML\":pe(r,n,i);return;case\"afterbegin\":me(r,n,i);return;case\"beforebegin\":ye(r,n,i);return;case\"beforeend\":xe(r,n,i);return;case\"afterend\":be(r,n,i);return;case\"delete\":we(r,n,i);return;default:var a=gr(t);for(var o=0;o<a.length;o++){var f=a[o];try{var s=f.handleSwap(e,r,n,i);if(s){if(typeof s.length!==\"undefined\"){for(var l=0;l<s.length;l++){var u=s[l];if(u.nodeType!==Node.TEXT_NODE&&u.nodeType!==Node.COMMENT_NODE){i.tasks.push(ue(u))}}}return}}catch(e){St(e)}}if(e===\"innerHTML\"){Se(r,n,i)}else{Ce(z.config.defaultSwapStyle,t,r,n,i)}}}function Re(e){if(e.indexOf(\"<title\")>-1){var t=e.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\"\");var r=t.match(/<title(\\s[^>]*>|>)([\\s\\S]*?)<\\/title>/im);if(r){return r[2]}}}function Oe(e,t,r,n,i){i.title=Re(n);var a=f(n);if(a){_(r,a,i);a=Ee(r,a);W(a);return Ce(e,r,t,a,i)}}function qe(e,t,r){var n=e.getResponseHeader(t);if(n.indexOf(\"{\")===0){var i=w(n);for(var a in i){if(i.hasOwnProperty(a)){var o=i[a];if(!m(o)){o={value:o}}ee(r,a,o)}}}else{ee(r,n,[])}}var Te=/\\s/;var Le=/[\\s,]/;var He=/[_$a-zA-Z]/;var Ae=/[_$a-zA-Z0-9]/;var Ne=['\"',\"'\",\"/\"];var Ie=/[^\\s]/;function ke(e){var t=[];var r=0;while(r<e.length){if(He.exec(e.charAt(r))){var n=r;while(Ae.exec(e.charAt(r+1))){r++}t.push(e.substr(n,r-n+1))}else if(Ne.indexOf(e.charAt(r))!==-1){var i=e.charAt(r);var n=r;r++;while(r<e.length&&e.charAt(r)!==i){if(e.charAt(r)===\"\\\\\"){r++}r++}t.push(e.substr(n,r-n+1))}else{var a=e.charAt(r);t.push(a)}r++}return t}function Me(e,t,r){return He.exec(e.charAt(0))&&e!==\"true\"&&e!==\"false\"&&e!==\"this\"&&e!==r&&t!==\".\"}function Pe(e,t,r){if(t[0]===\"[\"){t.shift();var n=1;var i=\" return (function(\"+r+\"){ return (\";var a=null;while(t.length>0){var o=t[0];if(o===\"]\"){n--;if(n===0){if(a===null){i=i+\"true\"}t.shift();i+=\")})\";try{var s=Qt(e,function(){return Function(i)()},function(){return true});s.source=i;return s}catch(e){Q($().body,\"htmx:syntax:error\",{error:e,source:i});return null}}}else if(o===\"[\"){n++}if(Me(o,a,r)){i+=\"((\"+r+\".\"+o+\") ? (\"+r+\".\"+o+\") : (window.\"+o+\"))\"}else{i=i+o}a=t.shift()}}}function c(e,t){var r=\"\";while(e.length>0&&!e[0].match(t)){r+=e.shift()}return r}var De=\"input, textarea, select\";function Xe(e){var t=J(e,\"hx-trigger\");var r=[];if(t){var n=ke(t);do{c(n,Ie);var f=n.length;var i=c(n,/[,\\[\\s]/);if(i!==\"\"){if(i===\"every\"){var a={trigger:\"every\"};c(n,Ie);a.pollInterval=v(c(n,/[,\\[\\s]/));c(n,Ie);var o=Pe(e,n,\"event\");if(o){a.eventFilter=o}r.push(a)}else if(i.indexOf(\"sse:\")===0){r.push({trigger:\"sse\",sseEvent:i.substr(4)})}else{var s={trigger:i};var o=Pe(e,n,\"event\");if(o){s.eventFilter=o}while(n.length>0&&n[0]!==\",\"){c(n,Ie);var l=n.shift();if(l===\"changed\"){s.changed=true}else if(l===\"once\"){s.once=true}else if(l===\"consume\"){s.consume=true}else if(l===\"delay\"&&n[0]===\":\"){n.shift();s.delay=v(c(n,Le))}else if(l===\"from\"&&n[0]===\":\"){n.shift();var u=c(n,Le);if(u===\"closest\"||u===\"find\"||u===\"next\"||u===\"previous\"){n.shift();u+=\" \"+c(n,Le)}s.from=u}else if(l===\"target\"&&n[0]===\":\"){n.shift();s.target=c(n,Le)}else if(l===\"throttle\"&&n[0]===\":\"){n.shift();s.throttle=v(c(n,Le))}else if(l===\"queue\"&&n[0]===\":\"){n.shift();s.queue=c(n,Le)}else if((l===\"root\"||l===\"threshold\")&&n[0]===\":\"){n.shift();s[l]=c(n,Le)}else{Q(e,\"htmx:syntax:error\",{token:n.shift()})}}r.push(s)}}if(n.length===f){Q(e,\"htmx:syntax:error\",{token:n.shift()})}c(n,Ie)}while(n[0]===\",\"&&n.shift())}if(r.length>0){return r}else if(d(e,\"form\")){return[{trigger:\"submit\"}]}else if(d(e,'input[type=\"button\"]')){return[{trigger:\"click\"}]}else if(d(e,De)){return[{trigger:\"change\"}]}else{return[{trigger:\"click\"}]}}function Fe(e){K(e).cancelled=true}function Be(e,t,r){var n=K(e);n.timeout=setTimeout(function(){if(re(e)&&n.cancelled!==true){if(!We(r,xt(\"hx:poll:trigger\",{triggerSpec:r,target:e}))){t(e)}Be(e,t,r)}},r.pollInterval)}function je(e){return location.hostname===e.hostname&&G(e,\"href\")&&G(e,\"href\").indexOf(\"#\")!==0}function Ue(t,r,e){if(t.tagName===\"A\"&&je(t)&&(t.target===\"\"||t.target===\"_self\")||t.tagName===\"FORM\"){r.boosted=true;var n,i;if(t.tagName===\"A\"){n=\"get\";i=G(t,\"href\")}else{var a=G(t,\"method\");n=a?a.toLowerCase():\"get\";if(n===\"get\"){}i=G(t,\"action\")}e.forEach(function(e){ze(t,function(e,t){lr(n,i,e,t)},r,e,true)})}}function Ve(e,t){if(e.type===\"submit\"||e.type===\"click\"){if(t.tagName===\"FORM\"){return true}if(d(t,'input[type=\"submit\"], button')&&A(t,\"form\")!==null){return true}if(t.tagName===\"A\"&&t.href&&(t.getAttribute(\"href\")===\"#\"||t.getAttribute(\"href\").indexOf(\"#\")!==0)){return true}}return false}function _e(e,t){return K(e).boosted&&e.tagName===\"A\"&&t.type===\"click\"&&(t.ctrlKey||t.metaKey)}function We(e,t){var r=e.eventFilter;if(r){try{return r(t)!==true}catch(e){Q($().body,\"htmx:eventFilter:error\",{error:e,source:r.source});return true}}return false}function ze(a,o,e,s,l){var t;if(s.from){t=N(a,s.from)}else{t=[a]}Y(t,function(n){var i=function(e){if(!re(a)){n.removeEventListener(s.trigger,i);return}if(_e(a,e)){return}if(l||Ve(e,a)){e.preventDefault()}if(We(s,e)){return}var t=K(e);t.triggerSpec=s;if(t.handledFor==null){t.handledFor=[]}var r=K(a);if(t.handledFor.indexOf(a)<0){t.handledFor.push(a);if(s.consume){e.stopPropagation()}if(s.target&&e.target){if(!d(e.target,s.target)){return}}if(s.once){if(r.triggeredOnce){return}else{r.triggeredOnce=true}}if(s.changed){if(r.lastValue===a.value){return}else{r.lastValue=a.value}}if(r.delayed){clearTimeout(r.delayed)}if(r.throttle){return}if(s.throttle){if(!r.throttle){o(a,e);r.throttle=setTimeout(function(){r.throttle=null},s.throttle)}}else if(s.delay){r.delayed=setTimeout(function(){o(a,e)},s.delay)}else{o(a,e)}}};if(e.listenerInfos==null){e.listenerInfos=[]}e.listenerInfos.push({trigger:s.trigger,listener:i,on:n});n.addEventListener(s.trigger,i)})}var Ge=false;var Je=null;function $e(){if(!Je){Je=function(){Ge=true};window.addEventListener(\"scroll\",Je);setInterval(function(){if(Ge){Ge=false;Y($().querySelectorAll(\"[hx-trigger='revealed'],[data-hx-trigger='revealed']\"),function(e){Ze(e)})}},200)}}function Ze(t){if(!o(t,\"data-hx-revealed\")&&x(t)){t.setAttribute(\"data-hx-revealed\",\"true\");var e=K(t);if(e.initHash){ee(t,\"revealed\")}else{t.addEventListener(\"htmx:afterProcessNode\",function(e){ee(t,\"revealed\")},{once:true})}}}function Ke(e,t,r){var n=b(r);for(var i=0;i<n.length;i++){var a=n[i].split(/:(.+)/);if(a[0]===\"connect\"){Ye(e,a[1],0)}if(a[0]===\"send\"){et(e)}}}function Ye(s,r,n){if(!re(s)){return}if(r.indexOf(\"/\")==0){var e=location.hostname+(location.port?\":\"+location.port:\"\");if(location.protocol==\"https:\"){r=\"wss://\"+e+r}else if(location.protocol==\"http:\"){r=\"ws://\"+e+r}}var t=z.createWebSocket(r);t.onerror=function(e){Q(s,\"htmx:wsError\",{error:e,socket:t});Qe(s)};t.onclose=function(e){if([1006,1012,1013].indexOf(e.code)>=0){var t=tt(n);setTimeout(function(){Ye(s,r,n+1)},t)}};t.onopen=function(e){n=0};K(s).webSocket=t;t.addEventListener(\"message\",function(e){if(Qe(s)){return}var t=e.data;wt(s,function(e){t=e.transformResponse(t,null,s)});var r=Zt(s);var n=f(t);var i=y(n.children);for(var a=0;a<i.length;a++){var o=i[a];V(J(o,\"hx-swap-oob\")||\"true\",o,r)}At(r.tasks)})}function Qe(e){if(!re(e)){K(e).webSocket.close();return true}}function et(u){var f=h(u,function(e){return K(e).webSocket!=null});if(f){u.addEventListener(Xe(u)[0].trigger,function(e){var t=K(f).webSocket;var r=_t(u,f);var n=Bt(u,\"post\");var i=n.errors;var a=n.values;var o=rr(u);var s=ne(a,o);var l=Wt(s,u);l[\"HEADERS\"]=r;if(i&&i.length>0){ee(u,\"htmx:validation:halted\",i);return}t.send(JSON.stringify(l));if(Ve(e,u)){e.preventDefault()}})}else{Q(u,\"htmx:noWebSocketSourceError\")}}function tt(e){var t=z.config.wsReconnectDelay;if(typeof t===\"function\"){return t(e)}if(t===\"full-jitter\"){var r=Math.min(e,6);var n=1e3*Math.pow(2,r);return n*Math.random()}St('htmx.config.wsReconnectDelay must either be a function or the string \"full-jitter\"')}function rt(e,t,r){var n=b(r);for(var i=0;i<n.length;i++){var a=n[i].split(/:(.+)/);if(a[0]===\"connect\"){nt(e,a[1])}if(a[0]===\"swap\"){it(e,a[1])}}}function nt(t,e){var r=z.createEventSource(e);r.onerror=function(e){Q(t,\"htmx:sseError\",{error:e,source:r});ot(t)};K(t).sseEventSource=r}function it(a,o){var s=h(a,st);if(s){var l=K(s).sseEventSource;var u=function(e){if(ot(s)){l.removeEventListener(o,u);return}var t=e.data;wt(a,function(e){t=e.transformResponse(t,null,a)});var r=Gt(a);var n=se(a);var i=Zt(a);Oe(r.swapStyle,a,n,t,i);At(i.tasks);ee(a,\"htmx:sseMessage\",e)};K(a).sseListener=u;l.addEventListener(o,u)}else{Q(a,\"htmx:noSSESourceError\")}}function at(e,t,r){var n=h(e,st);if(n){var i=K(n).sseEventSource;var a=function(){if(!ot(n)){if(re(e)){t(e)}else{i.removeEventListener(r,a)}}};K(e).sseListener=a;i.addEventListener(r,a)}else{Q(e,\"htmx:noSSESourceError\")}}function ot(e){if(!re(e)){K(e).sseEventSource.close();return true}}function st(e){return K(e).sseEventSource!=null}function lt(e,t,r,n){var i=function(){if(!r.loaded){r.loaded=true;t(e)}};if(n){setTimeout(i,n)}else{i()}}function ut(t,i,e){var a=false;Y(n,function(r){if(o(t,\"hx-\"+r)){var n=J(t,\"hx-\"+r);a=true;i.path=n;i.verb=r;e.forEach(function(e){ft(t,e,i,function(e,t){lr(r,n,e,t)})})}});return a}function ft(n,e,t,r){if(e.sseEvent){at(n,r,e.sseEvent)}else if(e.trigger===\"revealed\"){$e();ze(n,r,t,e);Ze(n)}else if(e.trigger===\"intersect\"){var i={};if(e.root){i.root=ie(n,e.root)}if(e.threshold){i.threshold=parseFloat(e.threshold)}var a=new IntersectionObserver(function(e){for(var t=0;t<e.length;t++){var r=e[t];if(r.isIntersecting){ee(n,\"intersect\");break}}},i);a.observe(n);ze(n,r,t,e)}else if(e.trigger===\"load\"){if(!We(e,xt(\"load\",{elt:n}))){lt(n,r,t,e.delay)}}else if(e.pollInterval){t.polling=true;Be(n,r,e)}else{ze(n,r,t,e)}}function ct(e){if(e.type===\"text/javascript\"||e.type===\"module\"||e.type===\"\"){var t=$().createElement(\"script\");Y(e.attributes,function(e){t.setAttribute(e.name,e.value)});t.textContent=e.textContent;t.async=false;if(z.config.inlineScriptNonce){t.nonce=z.config.inlineScriptNonce}var r=e.parentElement;try{r.insertBefore(t,e)}catch(e){St(e)}finally{if(e.parentElement){e.parentElement.removeChild(e)}}}}function ht(e){if(d(e,\"script\")){ct(e)}Y(R(e,\"script\"),function(e){ct(e)})}function dt(){return document.querySelector(\"[hx-boost], [data-hx-boost]\")}function vt(e){if(e.querySelectorAll){var t=dt()?\", a, form\":\"\";var r=e.querySelectorAll(i+t+\", [hx-sse], [data-hx-sse], [hx-ws],\"+\" [data-hx-ws], [hx-ext], [data-hx-ext]\");return r}else{return[]}}function gt(n){var e=function(e){var t=A(e.target,\"button, input[type='submit']\");if(t!==null){var r=K(n);r.lastButtonClicked=t}};n.addEventListener(\"click\",e);n.addEventListener(\"focusin\",e);n.addEventListener(\"focusout\",function(e){var t=K(n);t.lastButtonClicked=null})}function pt(e){if(e.closest&&e.closest(z.config.disableSelector)){return}var t=K(e);if(t.initHash!==de(e)){t.initHash=de(e);ve(e);ee(e,\"htmx:beforeProcessNode\");if(e.value){t.lastValue=e.value}var r=Xe(e);var n=ut(e,t,r);if(!n&&Z(e,\"hx-boost\")===\"true\"){Ue(e,t,r)}if(e.tagName===\"FORM\"){gt(e)}var i=J(e,\"hx-sse\");if(i){rt(e,t,i)}var a=J(e,\"hx-ws\");if(a){Ke(e,t,a)}ee(e,\"htmx:afterProcessNode\")}}function mt(e){e=M(e);pt(e);Y(vt(e),function(e){pt(e)})}function yt(e){return e.replace(/([a-z0-9])([A-Z])/g,\"$1-$2\").toLowerCase()}function xt(e,t){var r;if(window.CustomEvent&&typeof window.CustomEvent===\"function\"){r=new CustomEvent(e,{bubbles:true,cancelable:true,detail:t})}else{r=$().createEvent(\"CustomEvent\");r.initCustomEvent(e,true,true,t)}return r}function Q(e,t,r){ee(e,t,ne({error:t},r))}function bt(e){return e===\"htmx:afterProcessNode\"}function wt(e,t){Y(gr(e),function(e){try{t(e)}catch(e){St(e)}})}function St(e){if(console.error){console.error(e)}else if(console.log){console.log(\"ERROR: \",e)}}function ee(e,t,r){e=M(e);if(r==null){r={}}r[\"elt\"]=e;var n=xt(t,r);if(z.logger&&!bt(t)){z.logger(e,t,r)}if(r.error){St(r.error);ee(e,\"htmx:error\",{errorInfo:r})}var i=e.dispatchEvent(n);var a=yt(t);if(i&&a!==t){var o=xt(a,n.detail);i=i&&e.dispatchEvent(o)}wt(e,function(e){i=i&&e.onEvent(t,n)!==false});return i}var Et=location.pathname+location.search;function Ct(){var e=$().querySelector(\"[hx-history-elt],[data-hx-history-elt]\");return e||$().body}function Rt(e,t,r,n){if(!S()){return}var i=w(localStorage.getItem(\"htmx-history-cache\"))||[];for(var a=0;a<i.length;a++){if(i[a].url===e){i.splice(a,1);break}}var o={url:e,content:t,title:r,scroll:n};ee($().body,\"htmx:historyItemCreated\",{item:o,cache:i});i.push(o);while(i.length>z.config.historyCacheSize){i.shift()}while(i.length>0){try{localStorage.setItem(\"htmx-history-cache\",JSON.stringify(i));break}catch(e){Q($().body,\"htmx:historyCacheError\",{cause:e,cache:i});i.shift()}}}function Ot(e){if(!S()){return null}var t=w(localStorage.getItem(\"htmx-history-cache\"))||[];for(var r=0;r<t.length;r++){if(t[r].url===e){return t[r]}}return null}function qt(e){var t=z.config.requestClass;var r=e.cloneNode(true);Y(R(r,\".\"+t),function(e){T(e,t)});return r.innerHTML}function Tt(){var e=Ct();var t=Et||location.pathname+location.search;var r=$().querySelector('[hx-history=\"false\" i],[data-hx-history=\"false\" i]');if(!r){ee($().body,\"htmx:beforeHistorySave\",{path:t,historyElt:e});Rt(t,qt(e),$().title,window.scrollY)}if(z.config.historyEnabled)history.replaceState({htmx:true},$().title,window.location.href)}function Lt(e){if(z.config.getCacheBusterParam){e=e.replace(/org\\.htmx\\.cache-buster=[^&]*&?/,\"\");if(e.endsWith(\"&\")||e.endsWith(\"?\")){e=e.slice(0,-1)}}if(z.config.historyEnabled){history.pushState({htmx:true},\"\",e)}Et=e}function Ht(e){if(z.config.historyEnabled)history.replaceState({htmx:true},\"\",e);Et=e}function At(e){Y(e,function(e){e.call()})}function Nt(a){var e=new XMLHttpRequest;var o={path:a,xhr:e};ee($().body,\"htmx:historyCacheMiss\",o);e.open(\"GET\",a,true);e.setRequestHeader(\"HX-History-Restore-Request\",\"true\");e.onload=function(){if(this.status>=200&&this.status<400){ee($().body,\"htmx:historyCacheMissLoad\",o);var e=f(this.response);e=e.querySelector(\"[hx-history-elt],[data-hx-history-elt]\")||e;var t=Ct();var r=Zt(t);var n=Re(this.response);if(n){var i=C(\"title\");if(i){i.innerHTML=n}else{window.document.title=n}}Se(t,e,r);At(r.tasks);Et=a;ee($().body,\"htmx:historyRestore\",{path:a,cacheMiss:true,serverResponse:this.response})}else{Q($().body,\"htmx:historyCacheMissLoadError\",o)}};e.send()}function It(e){Tt();e=e||location.pathname+location.search;var t=Ot(e);if(t){var r=f(t.content);var n=Ct();var i=Zt(n);Se(n,r,i);At(i.tasks);document.title=t.title;window.scrollTo(0,t.scroll);Et=e;ee($().body,\"htmx:historyRestore\",{path:e,item:t})}else{if(z.config.refreshOnHistoryMiss){window.location.reload(true)}else{Nt(e)}}}function kt(e){var t=F(e,\"hx-indicator\");if(t==null){t=[e]}Y(t,function(e){var t=K(e);t.requestCount=(t.requestCount||0)+1;e.classList[\"add\"].call(e.classList,z.config.requestClass)});return t}function Mt(e){Y(e,function(e){var t=K(e);t.requestCount=(t.requestCount||0)-1;if(t.requestCount===0){e.classList[\"remove\"].call(e.classList,z.config.requestClass)}})}function Pt(e,t){for(var r=0;r<e.length;r++){var n=e[r];if(n.isSameNode(t)){return true}}return false}function Dt(e){if(e.name===\"\"||e.name==null||e.disabled){return false}if(e.type===\"button\"||e.type===\"submit\"||e.tagName===\"image\"||e.tagName===\"reset\"||e.tagName===\"file\"){return false}if(e.type===\"checkbox\"||e.type===\"radio\"){return e.checked}return true}function Xt(t,r,n,e,i){if(e==null||Pt(t,e)){return}else{t.push(e)}if(Dt(e)){var a=G(e,\"name\");var o=e.value;if(e.multiple){o=y(e.querySelectorAll(\"option:checked\")).map(function(e){return e.value})}if(e.files){o=y(e.files)}if(a!=null&&o!=null){var s=r[a];if(s!==undefined){if(Array.isArray(s)){if(Array.isArray(o)){r[a]=s.concat(o)}else{s.push(o)}}else{if(Array.isArray(o)){r[a]=[s].concat(o)}else{r[a]=[s,o]}}}else{r[a]=o}}if(i){Ft(e,n)}}if(d(e,\"form\")){var l=e.elements;Y(l,function(e){Xt(t,r,n,e,i)})}}function Ft(e,t){if(e.willValidate){ee(e,\"htmx:validation:validate\");if(!e.checkValidity()){t.push({elt:e,message:e.validationMessage,validity:e.validity});ee(e,\"htmx:validation:failed\",{message:e.validationMessage,validity:e.validity})}}}function Bt(e,t){var r=[];var n={};var i={};var a=[];var o=K(e);var s=d(e,\"form\")&&e.noValidate!==true||J(e,\"hx-validate\")===\"true\";if(o.lastButtonClicked){s=s&&o.lastButtonClicked.formNoValidate!==true}if(t!==\"get\"){Xt(r,i,a,A(e,\"form\"),s)}Xt(r,n,a,e,s);if(o.lastButtonClicked){var l=G(o.lastButtonClicked,\"name\");if(l){n[l]=o.lastButtonClicked.value}}var u=F(e,\"hx-include\");Y(u,function(e){Xt(r,n,a,e,s);if(!d(e,\"form\")){Y(e.querySelectorAll(De),function(e){Xt(r,n,a,e,s)})}});n=ne(n,i);return{errors:a,values:n}}function jt(e,t,r){if(e!==\"\"){e+=\"&\"}if(String(r)===\"[object Object]\"){r=JSON.stringify(r)}var n=encodeURIComponent(r);e+=encodeURIComponent(t)+\"=\"+n;return e}function Ut(e){var t=\"\";for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){Y(n,function(e){t=jt(t,r,e)})}else{t=jt(t,r,n)}}}return t}function Vt(e){var t=new FormData;for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){Y(n,function(e){t.append(r,e)})}else{t.append(r,n)}}}return t}function _t(e,t,r){var n={\"HX-Request\":\"true\",\"HX-Trigger\":G(e,\"id\"),\"HX-Trigger-Name\":G(e,\"name\"),\"HX-Target\":J(t,\"id\"),\"HX-Current-URL\":$().location.href};Yt(e,\"hx-headers\",false,n);if(r!==undefined){n[\"HX-Prompt\"]=r}if(K(e).boosted){n[\"HX-Boosted\"]=\"true\"}return n}function Wt(t,e){var r=Z(e,\"hx-params\");if(r){if(r===\"none\"){return{}}else if(r===\"*\"){return t}else if(r.indexOf(\"not \")===0){Y(r.substr(4).split(\",\"),function(e){e=e.trim();delete t[e]});return t}else{var n={};Y(r.split(\",\"),function(e){e=e.trim();n[e]=t[e]});return n}}else{return t}}function zt(e){return G(e,\"href\")&&G(e,\"href\").indexOf(\"#\")>=0}function Gt(e,t){var r=t?t:Z(e,\"hx-swap\");var n={swapStyle:K(e).boosted?\"innerHTML\":z.config.defaultSwapStyle,swapDelay:z.config.defaultSwapDelay,settleDelay:z.config.defaultSettleDelay};if(K(e).boosted&&!zt(e)){n[\"show\"]=\"top\"}if(r){var i=b(r);if(i.length>0){n[\"swapStyle\"]=i[0];for(var a=1;a<i.length;a++){var o=i[a];if(o.indexOf(\"swap:\")===0){n[\"swapDelay\"]=v(o.substr(5))}if(o.indexOf(\"settle:\")===0){n[\"settleDelay\"]=v(o.substr(7))}if(o.indexOf(\"scroll:\")===0){var s=o.substr(7);var l=s.split(\":\");var f=l.pop();var u=l.length>0?l.join(\":\"):null;n[\"scroll\"]=f;n[\"scrollTarget\"]=u}if(o.indexOf(\"show:\")===0){var c=o.substr(5);var l=c.split(\":\");var h=l.pop();var u=l.length>0?l.join(\":\"):null;n[\"show\"]=h;n[\"showTarget\"]=u}if(o.indexOf(\"focus-scroll:\")===0){var d=o.substr(\"focus-scroll:\".length);n[\"focusScroll\"]=d==\"true\"}}}}return n}function Jt(e){return Z(e,\"hx-encoding\")===\"multipart/form-data\"||d(e,\"form\")&&G(e,\"enctype\")===\"multipart/form-data\"}function $t(t,r,n){var i=null;wt(r,function(e){if(i==null){i=e.encodeParameters(t,n,r)}});if(i!=null){return i}else{if(Jt(r)){return Vt(n)}else{return Ut(n)}}}function Zt(e){return{tasks:[],elts:[e]}}function Kt(e,t){var r=e[0];var n=e[e.length-1];if(t.scroll){var i=null;if(t.scrollTarget){i=ie(r,t.scrollTarget)}if(t.scroll===\"top\"&&(r||i)){i=i||r;i.scrollTop=0}if(t.scroll===\"bottom\"&&(n||i)){i=i||n;i.scrollTop=i.scrollHeight}}if(t.show){var i=null;if(t.showTarget){var a=t.showTarget;if(t.showTarget===\"window\"){a=\"body\"}i=ie(r,a)}if(t.show===\"top\"&&(r||i)){i=i||r;i.scrollIntoView({block:\"start\",behavior:z.config.scrollBehavior})}if(t.show===\"bottom\"&&(n||i)){i=i||n;i.scrollIntoView({block:\"end\",behavior:z.config.scrollBehavior})}}}function Yt(e,t,r,n){if(n==null){n={}}if(e==null){return n}var i=J(e,t);if(i){var a=i.trim();var o=r;if(a===\"unset\"){return null}if(a.indexOf(\"javascript:\")===0){a=a.substr(11);o=true}else if(a.indexOf(\"js:\")===0){a=a.substr(3);o=true}if(a.indexOf(\"{\")!==0){a=\"{\"+a+\"}\"}var s;if(o){s=Qt(e,function(){return Function(\"return (\"+a+\")\")()},{})}else{s=w(a)}for(var l in s){if(s.hasOwnProperty(l)){if(n[l]==null){n[l]=s[l]}}}}return Yt(u(e),t,r,n)}function Qt(e,t,r){if(z.config.allowEval){return t()}else{Q(e,\"htmx:evalDisallowedError\");return r}}function er(e,t){return Yt(e,\"hx-vars\",true,t)}function tr(e,t){return Yt(e,\"hx-vals\",false,t)}function rr(e){return ne(er(e),tr(e))}function nr(t,r,n){if(n!==null){try{t.setRequestHeader(r,n)}catch(e){t.setRequestHeader(r,encodeURIComponent(n));t.setRequestHeader(r+\"-URI-AutoEncoded\",\"true\")}}}function ir(t){if(t.responseURL&&typeof URL!==\"undefined\"){try{var e=new URL(t.responseURL);return e.pathname+e.search}catch(e){Q($().body,\"htmx:badResponseUrl\",{url:t.responseURL})}}}function ar(e,t){return e.getAllResponseHeaders().match(t)}function or(e,t,r){e=e.toLowerCase();if(r){if(r instanceof Element||g(r,\"String\")){return lr(e,t,null,null,{targetOverride:M(r),returnPromise:true})}else{return lr(e,t,M(r.source),r.event,{handler:r.handler,headers:r.headers,values:r.values,targetOverride:M(r.target),swapOverride:r.swap,returnPromise:true})}}else{return lr(e,t,null,null,{returnPromise:true})}}function sr(e){var t=[];while(e){t.push(e);e=e.parentElement}return t}function lr(e,t,n,r,i,f){var c=null;var h=null;i=i!=null?i:{};if(i.returnPromise&&typeof Promise!==\"undefined\"){var d=new Promise(function(e,t){c=e;h=t})}if(n==null){n=$().body}var v=i.handler||fr;if(!re(n)){return}var g=i.targetOverride||se(n);if(g==null||g==ae){Q(n,\"htmx:targetError\",{target:J(n,\"hx-target\")});return}if(!f){var p=function(){return lr(e,t,n,r,i,true)};var m={target:g,elt:n,path:t,verb:e,triggeringEvent:r,etc:i,issueRequest:p};if(ee(n,\"htmx:confirm\",m)===false){return}}var y=n;var a=K(n);var x=Z(n,\"hx-sync\");var b=null;var w=false;if(x){var S=x.split(\":\");var E=S[0].trim();if(E===\"this\"){y=oe(n,\"hx-sync\")}else{y=ie(n,E)}x=(S[1]||\"drop\").trim();a=K(y);if(x===\"drop\"&&a.xhr&&a.abortable!==true){return}else if(x===\"abort\"){if(a.xhr){return}else{w=true}}else if(x===\"replace\"){ee(y,\"htmx:abort\")}else if(x.indexOf(\"queue\")===0){var C=x.split(\" \");b=(C[1]||\"last\").trim()}}if(a.xhr){if(a.abortable){ee(y,\"htmx:abort\")}else{if(b==null){if(r){var R=K(r);if(R&&R.triggerSpec&&R.triggerSpec.queue){b=R.triggerSpec.queue}}if(b==null){b=\"last\"}}if(a.queuedRequests==null){a.queuedRequests=[]}if(b===\"first\"&&a.queuedRequests.length===0){a.queuedRequests.push(function(){lr(e,t,n,r,i)})}else if(b===\"all\"){a.queuedRequests.push(function(){lr(e,t,n,r,i)})}else if(b===\"last\"){a.queuedRequests=[];a.queuedRequests.push(function(){lr(e,t,n,r,i)})}return}}var o=new XMLHttpRequest;a.xhr=o;a.abortable=w;var s=function(){a.xhr=null;a.abortable=false;if(a.queuedRequests!=null&&a.queuedRequests.length>0){var e=a.queuedRequests.shift();e()}};var O=Z(n,\"hx-prompt\");if(O){var q=prompt(O);if(q===null||!ee(n,\"htmx:prompt\",{prompt:q,target:g})){te(c);s();return d}}var T=Z(n,\"hx-confirm\");if(T){if(!confirm(T)){te(c);s();return d}}var L=_t(n,g,q);if(i.headers){L=ne(L,i.headers)}var H=Bt(n,e);var A=H.errors;var N=H.values;if(i.values){N=ne(N,i.values)}var I=rr(n);var k=ne(N,I);var M=Wt(k,n);if(e!==\"get\"&&!Jt(n)){L[\"Content-Type\"]=\"application/x-www-form-urlencoded\"}if(z.config.getCacheBusterParam&&e===\"get\"){M[\"org.htmx.cache-buster\"]=G(g,\"id\")||\"true\"}if(t==null||t===\"\"){t=$().location.href}var P=Yt(n,\"hx-request\");var D=K(n).boosted;var l={boosted:D,parameters:M,unfilteredParameters:k,headers:L,target:g,verb:e,errors:A,withCredentials:i.credentials||P.credentials||z.config.withCredentials,timeout:i.timeout||P.timeout||z.config.timeout,path:t,triggeringEvent:r};if(!ee(n,\"htmx:configRequest\",l)){te(c);s();return d}t=l.path;e=l.verb;L=l.headers;M=l.parameters;A=l.errors;if(A&&A.length>0){ee(n,\"htmx:validation:halted\",l);te(c);s();return d}var X=t.split(\"#\");var F=X[0];var B=X[1];var j=null;if(e===\"get\"){j=F;var U=Object.keys(M).length!==0;if(U){if(j.indexOf(\"?\")<0){j+=\"?\"}else{j+=\"&\"}j+=Ut(M);if(B){j+=\"#\"+B}}o.open(\"GET\",j,true)}else{o.open(e.toUpperCase(),t,true)}o.overrideMimeType(\"text/html\");o.withCredentials=l.withCredentials;o.timeout=l.timeout;if(P.noHeaders){}else{for(var V in L){if(L.hasOwnProperty(V)){var _=L[V];nr(o,V,_)}}}var u={xhr:o,target:g,requestConfig:l,etc:i,boosted:D,pathInfo:{requestPath:t,finalRequestPath:j||t,anchor:B}};o.onload=function(){try{var e=sr(n);u.pathInfo.responsePath=ir(o);v(n,u);Mt(W);ee(n,\"htmx:afterRequest\",u);ee(n,\"htmx:afterOnLoad\",u);if(!re(n)){var t=null;while(e.length>0&&t==null){var r=e.shift();if(re(r)){t=r}}if(t){ee(t,\"htmx:afterRequest\",u);ee(t,\"htmx:afterOnLoad\",u)}}te(c);s()}catch(e){Q(n,\"htmx:onLoadError\",ne({error:e},u));throw e}};o.onerror=function(){Mt(W);Q(n,\"htmx:afterRequest\",u);Q(n,\"htmx:sendError\",u);te(h);s()};o.onabort=function(){Mt(W);Q(n,\"htmx:afterRequest\",u);Q(n,\"htmx:sendAbort\",u);te(h);s()};o.ontimeout=function(){Mt(W);Q(n,\"htmx:afterRequest\",u);Q(n,\"htmx:timeout\",u);te(h);s()};if(!ee(n,\"htmx:beforeRequest\",u)){te(c);s();return d}var W=kt(n);Y([\"loadstart\",\"loadend\",\"progress\",\"abort\"],function(t){Y([o,o.upload],function(e){e.addEventListener(t,function(e){ee(n,\"htmx:xhr:\"+t,{lengthComputable:e.lengthComputable,loaded:e.loaded,total:e.total})})})});ee(n,\"htmx:beforeSend\",u);o.send(e===\"get\"?null:$t(o,n,M));return d}function ur(e,t){var r=t.xhr;var n=null;var i=null;if(ar(r,/HX-Push:/i)){n=r.getResponseHeader(\"HX-Push\");i=\"push\"}else if(ar(r,/HX-Push-Url:/i)){n=r.getResponseHeader(\"HX-Push-Url\");i=\"push\"}else if(ar(r,/HX-Replace-Url:/i)){n=r.getResponseHeader(\"HX-Replace-Url\");i=\"replace\"}if(n){if(n===\"false\"){return{}}else{return{type:i,path:n}}}var a=t.pathInfo.finalRequestPath;var o=t.pathInfo.responsePath;var s=Z(e,\"hx-push-url\");var f=Z(e,\"hx-replace-url\");var c=K(e).boosted;var l=null;var u=null;if(s){l=\"push\";u=s}else if(f){l=\"replace\";u=f}else if(c){l=\"push\";u=o||a}if(u){if(u===\"false\"){return{}}if(u===\"true\"){u=o||a}if(t.pathInfo.anchor&&u.indexOf(\"#\")===-1){u=u+\"#\"+t.pathInfo.anchor}return{type:l,path:u}}else{return{}}}function fr(s,l){var u=l.xhr;var f=l.target;var n=l.etc;if(!ee(s,\"htmx:beforeOnLoad\",l))return;if(ar(u,/HX-Trigger:/i)){qe(u,\"HX-Trigger\",s)}if(ar(u,/HX-Location:/i)){Tt();var e=u.getResponseHeader(\"HX-Location\");var c;if(e.indexOf(\"{\")===0){c=w(e);e=c[\"path\"];delete c[\"path\"]}or(\"GET\",e,c).then(function(){Lt(e)});return}if(ar(u,/HX-Redirect:/i)){location.href=u.getResponseHeader(\"HX-Redirect\");return}if(ar(u,/HX-Refresh:/i)){if(\"true\"===u.getResponseHeader(\"HX-Refresh\")){location.reload();return}}if(ar(u,/HX-Retarget:/i)){l.target=$().querySelector(u.getResponseHeader(\"HX-Retarget\"))}var h=ur(s,l);var i=u.status>=200&&u.status<400&&u.status!==204;var d=u.response;var t=u.status>=400;var r=ne({shouldSwap:i,serverResponse:d,isError:t},l);if(!ee(f,\"htmx:beforeSwap\",r))return;f=r.target;d=r.serverResponse;t=r.isError;l.failed=t;l.successful=!t;if(r.shouldSwap){if(u.status===286){Fe(s)}wt(s,function(e){d=e.transformResponse(d,u,s)});if(h.type){Tt()}var a=n.swapOverride;if(ar(u,/HX-Reswap:/i)){a=u.getResponseHeader(\"HX-Reswap\")}var c=Gt(s,a);f.classList.add(z.config.swappingClass);var o=function(){try{var e=document.activeElement;var t={};try{t={elt:e,start:e?e.selectionStart:null,end:e?e.selectionEnd:null}}catch(e){}var n=Zt(f);Oe(c.swapStyle,f,s,d,n);if(t.elt&&!re(t.elt)&&t.elt.id){var r=document.getElementById(t.elt.id);var i={preventScroll:c.focusScroll!==undefined?!c.focusScroll:!z.config.defaultFocusScroll};if(r){if(t.start&&r.setSelectionRange){try{r.setSelectionRange(t.start,t.end)}catch(e){}}r.focus(i)}}f.classList.remove(z.config.swappingClass);Y(n.elts,function(e){if(e.classList){e.classList.add(z.config.settlingClass)}ee(e,\"htmx:afterSwap\",l)});if(ar(u,/HX-Trigger-After-Swap:/i)){var a=s;if(!re(s)){a=$().body}qe(u,\"HX-Trigger-After-Swap\",a)}var o=function(){Y(n.tasks,function(e){e.call()});Y(n.elts,function(e){if(e.classList){e.classList.remove(z.config.settlingClass)}ee(e,\"htmx:afterSettle\",l)});if(h.type){if(h.type===\"push\"){Lt(h.path);ee($().body,\"htmx:pushedIntoHistory\",{path:h.path})}else{Ht(h.path);ee($().body,\"htmx:replacedInHistory\",{path:h.path})}}if(l.pathInfo.anchor){var e=C(\"#\"+l.pathInfo.anchor);if(e){e.scrollIntoView({block:\"start\",behavior:\"auto\"})}}if(n.title){var t=C(\"title\");if(t){t.innerHTML=n.title}else{window.document.title=n.title}}Kt(n.elts,c);if(ar(u,/HX-Trigger-After-Settle:/i)){var r=s;if(!re(s)){r=$().body}qe(u,\"HX-Trigger-After-Settle\",r)}};if(c.settleDelay>0){setTimeout(o,c.settleDelay)}else{o()}}catch(e){Q(s,\"htmx:swapError\",l);throw e}};if(c.swapDelay>0){setTimeout(o,c.swapDelay)}else{o()}}if(t){Q(s,\"htmx:responseError\",ne({error:\"Response Status Error Code \"+u.status+\" from \"+l.pathInfo.requestPath},l))}}var cr={};function hr(){return{init:function(e){return null},onEvent:function(e,t){return true},transformResponse:function(e,t,r){return e},isInlineSwap:function(e){return false},handleSwap:function(e,t,r,n){return false},encodeParameters:function(e,t,r){return null}}}function dr(e,t){if(t.init){t.init(r)}cr[e]=ne(hr(),t)}function vr(e){delete cr[e]}function gr(e,r,n){if(e==undefined){return r}if(r==undefined){r=[]}if(n==undefined){n=[]}var t=J(e,\"hx-ext\");if(t){Y(t.split(\",\"),function(e){e=e.replace(/ /g,\"\");if(e.slice(0,7)==\"ignore:\"){n.push(e.slice(7));return}if(n.indexOf(e)<0){var t=cr[e];if(t&&r.indexOf(t)<0){r.push(t)}}})}return gr(u(e),r,n)}function pr(e){if($().readyState!==\"loading\"){e()}else{$().addEventListener(\"DOMContentLoaded\",e)}}function mr(){if(z.config.includeIndicatorStyles!==false){$().head.insertAdjacentHTML(\"beforeend\",\"<style>                      .\"+z.config.indicatorClass+\"{opacity:0;transition: opacity 200ms ease-in;}                      .\"+z.config.requestClass+\" .\"+z.config.indicatorClass+\"{opacity:1}                      .\"+z.config.requestClass+\".\"+z.config.indicatorClass+\"{opacity:1}                    </style>\")}}function yr(){var e=$().querySelector('meta[name=\"htmx-config\"]');if(e){return w(e.content)}else{return null}}function xr(){var e=yr();if(e){z.config=ne(z.config,e)}}pr(function(){xr();mr();var e=$().body;mt(e);var t=$().querySelectorAll(\"[hx-trigger='restored'],[data-hx-trigger='restored']\");e.addEventListener(\"htmx:abort\",function(e){var t=e.target;var r=K(t);if(r&&r.xhr){r.xhr.abort()}});window.onpopstate=function(e){if(e.state&&e.state.htmx){It();Y(t,function(e){ee(e,\"htmx:restored\",{document:$(),triggerEvent:ee})})}};setTimeout(function(){ee(e,\"htmx:load\",{})},0)});return z}()});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRteC5vcmcvZGlzdC9odG14Lm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrR0FBZSxHQUFHLElBQXNDLEVBQUUsaUNBQU8sRUFBRSxvQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBLGtHQUFDLENBQUMsSUFBSSxFQUFvQixDQUFDLGlEQUFpRCxrQkFBa0IsYUFBYSxPQUFPLGtHQUFrRyxzQkFBc0IsZ0JBQWdCLGdJQUFnSSwwbkJBQTBuQixtREFBbUQsMEJBQTBCLHFCQUFxQixFQUFFLDZCQUE2QiwwQkFBMEIsbUNBQW1DLFNBQVMsa0JBQWtCLE9BQU8seWFBQXlhLDRDQUE0Qyx3QkFBd0Isb0NBQW9DLGFBQWEsY0FBYyxpQkFBaUIsaUJBQWlCLHNCQUFzQiw0Q0FBNEMscUJBQXFCLGdEQUFnRCxxQkFBcUIsbURBQW1ELGdDQUFnQyxnQkFBZ0IseUNBQXlDLGdCQUFnQixzRUFBc0UsZ0JBQWdCLDhCQUE4QixjQUFjLHVCQUF1QixhQUFhLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLE9BQU8sZ0JBQWdCLGtCQUFrQixhQUFhLDJCQUEyQixvREFBb0QsY0FBYyxLQUFLLFVBQVUsZ0JBQWdCLFdBQVcsZ0JBQWdCLGtCQUFrQixFQUFFLGdCQUFnQixVQUFVLGdCQUFnQiwySEFBMkgsc0JBQXNCLGNBQWMsdUNBQXVDLGdCQUFnQixNQUFNLDBCQUEwQixLQUFLLFVBQVUsZ0JBQWdCLG9CQUFvQix1Q0FBdUMsYUFBYSxXQUFXLElBQUksZUFBZSxZQUFZLCtCQUErQixTQUFTLGNBQWMsa0NBQWtDLHFEQUFxRCwyQ0FBMkMsS0FBSyxXQUFXLFVBQVUsb0dBQW9HLGtFQUFrRSwyREFBMkQsNkVBQTZFLDRDQUE0Qyx3QkFBd0IsZUFBZSxNQUFNLEtBQUssZ0JBQWdCLDREQUE0RCxjQUFjLHVCQUF1QixjQUFjLHFCQUFxQixjQUFjLDJCQUEyQixXQUFXLE9BQU8sVUFBVSxTQUFTLGNBQWMsU0FBUyxNQUFNLFlBQVksV0FBVyxLQUFLLGNBQWMsU0FBUyxn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QUF3QixVQUFVLGtCQUFrQiwwQkFBMEIsS0FBSyxLQUFLLE1BQU0sNkJBQTZCLDZFQUE2RSxNQUFNLFVBQVUsY0FBYyxPQUFPLGlCQUFpQixZQUFZLHVCQUF1QixZQUFZLG1DQUFtQyxTQUFTLDBCQUEwQixhQUFhLDhCQUE4QixhQUFhLGtDQUFrQyxjQUFjLGlCQUFpQixXQUFXLFVBQVUsaUJBQWlCLGVBQWUsYUFBYSxtQkFBbUIsaUJBQWlCLFNBQVMsaUJBQWlCLEtBQUssaUJBQWlCLEtBQUssb0JBQW9CLE1BQU0sMkJBQTJCLHFCQUFxQiw0QkFBNEIsbUJBQW1CLE9BQU8sbUJBQW1CLFlBQVksc0JBQXNCLFlBQVksRUFBRSxvQkFBb0IsZUFBZSwrQkFBK0IsSUFBSSxLQUFLLDRDQUE0QyxjQUFjLDRDQUE0QyxtR0FBbUcsVUFBVSx5REFBeUQsd0RBQXdELGdDQUFnQyx1REFBdUQsOEJBQThCLFlBQVksY0FBYyxvREFBb0QsTUFBTSxvQkFBb0IsS0FBSyxhQUFhLGNBQWMsV0FBVyxNQUFNLHlCQUF5QixjQUFjLEtBQUssS0FBSyxlQUFlLE1BQU0sbUZBQW1GLDRDQUE0QyxlQUFlLFdBQVcsYUFBYSxlQUFlLEVBQUUsOEJBQThCLDBCQUEwQixLQUFLLGdCQUFnQixzQkFBc0IsNkJBQTZCLEVBQUUsSUFBSSxzQkFBc0IsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLFNBQVMsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG14Lm9yZy9kaXN0L2h0bXgubWluLmpzPzk3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7aWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLHQpfWVsc2V7ZS5odG14PWUuaHRteHx8dCgpfX0pKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgej17b25Mb2FkOnQscHJvY2VzczptdCxvbjpELG9mZjpYLHRyaWdnZXI6ZWUsYWpheDpvcixmaW5kOkMsZmluZEFsbDpSLGNsb3Nlc3Q6QSx2YWx1ZXM6ZnVuY3Rpb24oZSx0KXt2YXIgcj1CdChlLHR8fFwicG9zdFwiKTtyZXR1cm4gci52YWx1ZXN9LHJlbW92ZTpPLGFkZENsYXNzOnEscmVtb3ZlQ2xhc3M6VCx0b2dnbGVDbGFzczpMLHRha2VDbGFzczpILGRlZmluZUV4dGVuc2lvbjpkcixyZW1vdmVFeHRlbnNpb246dnIsbG9nQWxsOkUsbG9nZ2VyOm51bGwsY29uZmlnOntoaXN0b3J5RW5hYmxlZDp0cnVlLGhpc3RvcnlDYWNoZVNpemU6MTAscmVmcmVzaE9uSGlzdG9yeU1pc3M6ZmFsc2UsZGVmYXVsdFN3YXBTdHlsZTpcImlubmVySFRNTFwiLGRlZmF1bHRTd2FwRGVsYXk6MCxkZWZhdWx0U2V0dGxlRGVsYXk6MjAsaW5jbHVkZUluZGljYXRvclN0eWxlczp0cnVlLGluZGljYXRvckNsYXNzOlwiaHRteC1pbmRpY2F0b3JcIixyZXF1ZXN0Q2xhc3M6XCJodG14LXJlcXVlc3RcIixhZGRlZENsYXNzOlwiaHRteC1hZGRlZFwiLHNldHRsaW5nQ2xhc3M6XCJodG14LXNldHRsaW5nXCIsc3dhcHBpbmdDbGFzczpcImh0bXgtc3dhcHBpbmdcIixhbGxvd0V2YWw6dHJ1ZSxpbmxpbmVTY3JpcHROb25jZTpcIlwiLGF0dHJpYnV0ZXNUb1NldHRsZTpbXCJjbGFzc1wiLFwic3R5bGVcIixcIndpZHRoXCIsXCJoZWlnaHRcIl0sd2l0aENyZWRlbnRpYWxzOmZhbHNlLHRpbWVvdXQ6MCx3c1JlY29ubmVjdERlbGF5OlwiZnVsbC1qaXR0ZXJcIix3c0JpbmFyeVR5cGU6XCJibG9iXCIsZGlzYWJsZVNlbGVjdG9yOlwiW2h4LWRpc2FibGVdLCBbZGF0YS1oeC1kaXNhYmxlXVwiLHVzZVRlbXBsYXRlRnJhZ21lbnRzOmZhbHNlLHNjcm9sbEJlaGF2aW9yOlwic21vb3RoXCIsZGVmYXVsdEZvY3VzU2Nyb2xsOmZhbHNlLGdldENhY2hlQnVzdGVyUGFyYW06ZmFsc2V9LHBhcnNlSW50ZXJ2YWw6dixfOmUsY3JlYXRlRXZlbnRTb3VyY2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBFdmVudFNvdXJjZShlLHt3aXRoQ3JlZGVudGlhbHM6dHJ1ZX0pfSxjcmVhdGVXZWJTb2NrZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFdlYlNvY2tldChlLFtdKTt0LmJpbmFyeVR5cGU9ei5jb25maWcud3NCaW5hcnlUeXBlO3JldHVybiB0fSx2ZXJzaW9uOlwiMS44LjVcIn07dmFyIHI9e2FkZFRyaWdnZXJIYW5kbGVyOmZ0LGJvZHlDb250YWluczpyZSxjYW5BY2Nlc3NMb2NhbFN0b3JhZ2U6UyxmaWx0ZXJWYWx1ZXM6V3QsaGFzQXR0cmlidXRlOm8sZ2V0QXR0cmlidXRlVmFsdWU6SixnZXRDbG9zZXN0TWF0Y2g6aCxnZXRFeHByZXNzaW9uVmFyczpycixnZXRIZWFkZXJzOl90LGdldElucHV0VmFsdWVzOkJ0LGdldEludGVybmFsRGF0YTpLLGdldFN3YXBTcGVjaWZpY2F0aW9uOkd0LGdldFRyaWdnZXJTcGVjczpYZSxnZXRUYXJnZXQ6c2UsbWFrZUZyYWdtZW50OmYsbWVyZ2VPYmplY3RzOm5lLG1ha2VTZXR0bGVJbmZvOlp0LG9vYlN3YXA6VixzZWxlY3RBbmRTd2FwOk9lLHNldHRsZUltbWVkaWF0ZWx5OkF0LHNob3VsZENhbmNlbDpWZSx0cmlnZ2VyRXZlbnQ6ZWUsdHJpZ2dlckVycm9yRXZlbnQ6USx3aXRoRXh0ZW5zaW9uczp3dH07dmFyIG49W1wiZ2V0XCIsXCJwb3N0XCIsXCJwdXRcIixcImRlbGV0ZVwiLFwicGF0Y2hcIl07dmFyIGk9bi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJbaHgtXCIrZStcIl0sIFtkYXRhLWh4LVwiK2UrXCJdXCJ9KS5qb2luKFwiLCBcIik7ZnVuY3Rpb24gdihlKXtpZihlPT11bmRlZmluZWQpe3JldHVybiB1bmRlZmluZWR9aWYoZS5zbGljZSgtMik9PVwibXNcIil7cmV0dXJuIHBhcnNlRmxvYXQoZS5zbGljZSgwLC0yKSl8fHVuZGVmaW5lZH1pZihlLnNsaWNlKC0xKT09XCJzXCIpe3JldHVybiBwYXJzZUZsb2F0KGUuc2xpY2UoMCwtMSkpKjFlM3x8dW5kZWZpbmVkfWlmKGUuc2xpY2UoLTEpPT1cIm1cIil7cmV0dXJuIHBhcnNlRmxvYXQoZS5zbGljZSgwLC0xKSkqMWUzKjYwfHx1bmRlZmluZWR9cmV0dXJuIHBhcnNlRmxvYXQoZSl8fHVuZGVmaW5lZH1mdW5jdGlvbiBHKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZSh0KX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIGUuaGFzQXR0cmlidXRlJiYoZS5oYXNBdHRyaWJ1dGUodCl8fGUuaGFzQXR0cmlidXRlKFwiZGF0YS1cIit0KSl9ZnVuY3Rpb24gSihlLHQpe3JldHVybiBHKGUsdCl8fEcoZSxcImRhdGEtXCIrdCl9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZS5wYXJlbnRFbGVtZW50fWZ1bmN0aW9uICQoKXtyZXR1cm4gZG9jdW1lbnR9ZnVuY3Rpb24gaChlLHQpe3doaWxlKGUmJiF0KGUpKXtlPXUoZSl9cmV0dXJuIGU/ZTpudWxsfWZ1bmN0aW9uIGEoZSx0LHIpe3ZhciBuPUoodCxyKTt2YXIgaT1KKHQsXCJoeC1kaXNpbmhlcml0XCIpO2lmKGUhPT10JiZpJiYoaT09PVwiKlwifHxpLnNwbGl0KFwiIFwiKS5pbmRleE9mKHIpPj0wKSl7cmV0dXJuXCJ1bnNldFwifWVsc2V7cmV0dXJuIG59fWZ1bmN0aW9uIFoodCxyKXt2YXIgbj1udWxsO2godCxmdW5jdGlvbihlKXtyZXR1cm4gbj1hKHQsZSxyKX0pO2lmKG4hPT1cInVuc2V0XCIpe3JldHVybiBufX1mdW5jdGlvbiBkKGUsdCl7dmFyIHI9ZS5tYXRjaGVzfHxlLm1hdGNoZXNTZWxlY3Rvcnx8ZS5tc01hdGNoZXNTZWxlY3Rvcnx8ZS5tb3pNYXRjaGVzU2VsZWN0b3J8fGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxlLm9NYXRjaGVzU2VsZWN0b3I7cmV0dXJuIHImJnIuY2FsbChlLHQpfWZ1bmN0aW9uIHMoZSl7dmFyIHQ9LzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pO3ZhciByPXQuZXhlYyhlKTtpZihyKXtyZXR1cm4gclsxXS50b0xvd2VyQ2FzZSgpfWVsc2V7cmV0dXJuXCJcIn19ZnVuY3Rpb24gbChlLHQpe3ZhciByPW5ldyBET01QYXJzZXI7dmFyIG49ci5wYXJzZUZyb21TdHJpbmcoZSxcInRleHQvaHRtbFwiKTt2YXIgaT1uLmJvZHk7d2hpbGUodD4wKXt0LS07aT1pLmZpcnN0Q2hpbGR9aWYoaT09bnVsbCl7aT0kKCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpfXJldHVybiBpfWZ1bmN0aW9uIGYoZSl7aWYoei5jb25maWcudXNlVGVtcGxhdGVGcmFnbWVudHMpe3ZhciB0PWwoXCI8Ym9keT48dGVtcGxhdGU+XCIrZStcIjwvdGVtcGxhdGU+PC9ib2R5PlwiLDApO3JldHVybiB0LnF1ZXJ5U2VsZWN0b3IoXCJ0ZW1wbGF0ZVwiKS5jb250ZW50fWVsc2V7dmFyIHI9cyhlKTtzd2l0Y2gocil7Y2FzZVwidGhlYWRcIjpjYXNlXCJ0Ym9keVwiOmNhc2VcInRmb290XCI6Y2FzZVwiY29sZ3JvdXBcIjpjYXNlXCJjYXB0aW9uXCI6cmV0dXJuIGwoXCI8dGFibGU+XCIrZStcIjwvdGFibGU+XCIsMSk7Y2FzZVwiY29sXCI6cmV0dXJuIGwoXCI8dGFibGU+PGNvbGdyb3VwPlwiK2UrXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIsMik7Y2FzZVwidHJcIjpyZXR1cm4gbChcIjx0YWJsZT48dGJvZHk+XCIrZStcIjwvdGJvZHk+PC90YWJsZT5cIiwyKTtjYXNlXCJ0ZFwiOmNhc2VcInRoXCI6cmV0dXJuIGwoXCI8dGFibGU+PHRib2R5Pjx0cj5cIitlK1wiPC90cj48L3Rib2R5PjwvdGFibGU+XCIsMyk7Y2FzZVwic2NyaXB0XCI6cmV0dXJuIGwoXCI8ZGl2PlwiK2UrXCI8L2Rpdj5cIiwxKTtkZWZhdWx0OnJldHVybiBsKGUsMCl9fX1mdW5jdGlvbiB0ZShlKXtpZihlKXtlKCl9fWZ1bmN0aW9uIGcoZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IFwiK3QrXCJdXCJ9ZnVuY3Rpb24gcChlKXtyZXR1cm4gZyhlLFwiRnVuY3Rpb25cIil9ZnVuY3Rpb24gbShlKXtyZXR1cm4gZyhlLFwiT2JqZWN0XCIpfWZ1bmN0aW9uIEsoZSl7dmFyIHQ9XCJodG14LWludGVybmFsLWRhdGFcIjt2YXIgcj1lW3RdO2lmKCFyKXtyPWVbdF09e319cmV0dXJuIHJ9ZnVuY3Rpb24geShlKXt2YXIgdD1bXTtpZihlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dC5wdXNoKGVbcl0pfX1yZXR1cm4gdH1mdW5jdGlvbiBZKGUsdCl7aWYoZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3QoZVtyXSl9fX1mdW5jdGlvbiB4KGUpe3ZhciB0PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIHI9dC50b3A7dmFyIG49dC5ib3R0b207cmV0dXJuIHI8d2luZG93LmlubmVySGVpZ2h0JiZuPj0wfWZ1bmN0aW9uIHJlKGUpe2lmKGUuZ2V0Um9vdE5vZGUmJmUuZ2V0Um9vdE5vZGUoKWluc3RhbmNlb2YgU2hhZG93Um9vdCl7cmV0dXJuICQoKS5ib2R5LmNvbnRhaW5zKGUuZ2V0Um9vdE5vZGUoKS5ob3N0KX1lbHNle3JldHVybiAkKCkuYm9keS5jb250YWlucyhlKX19ZnVuY3Rpb24gYihlKXtyZXR1cm4gZS50cmltKCkuc3BsaXQoL1xccysvKX1mdW5jdGlvbiBuZShlLHQpe2Zvcih2YXIgciBpbiB0KXtpZih0Lmhhc093blByb3BlcnR5KHIpKXtlW3JdPXRbcl19fXJldHVybiBlfWZ1bmN0aW9uIHcoZSl7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUpfWNhdGNoKGUpe1N0KGUpO3JldHVybiBudWxsfX1mdW5jdGlvbiBTKCl7dmFyIGU9XCJodG14OmxvY2FsU3RvcmFnZVRlc3RcIjt0cnl7bG9jYWxTdG9yYWdlLnNldEl0ZW0oZSxlKTtsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShlKTtyZXR1cm4gdHJ1ZX1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fWZ1bmN0aW9uIGUoZSl7cmV0dXJuIFF0KCQoKS5ib2R5LGZ1bmN0aW9uKCl7cmV0dXJuIGV2YWwoZSl9KX1mdW5jdGlvbiB0KHQpe3ZhciBlPXoub24oXCJodG14OmxvYWRcIixmdW5jdGlvbihlKXt0KGUuZGV0YWlsLmVsdCl9KTtyZXR1cm4gZX1mdW5jdGlvbiBFKCl7ei5sb2dnZXI9ZnVuY3Rpb24oZSx0LHIpe2lmKGNvbnNvbGUpe2NvbnNvbGUubG9nKHQsZSxyKX19fWZ1bmN0aW9uIEMoZSx0KXtpZih0KXtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKHQpfWVsc2V7cmV0dXJuIEMoJCgpLGUpfX1mdW5jdGlvbiBSKGUsdCl7aWYodCl7cmV0dXJuIGUucXVlcnlTZWxlY3RvckFsbCh0KX1lbHNle3JldHVybiBSKCQoKSxlKX19ZnVuY3Rpb24gTyhlLHQpe2U9TShlKTtpZih0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TyhlKX0sdCl9ZWxzZXtlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZSl9fWZ1bmN0aW9uIHEoZSx0LHIpe2U9TShlKTtpZihyKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cShlLHQpfSxyKX1lbHNle2UuY2xhc3NMaXN0JiZlLmNsYXNzTGlzdC5hZGQodCl9fWZ1bmN0aW9uIFQoZSx0LHIpe2U9TShlKTtpZihyKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VChlLHQpfSxyKX1lbHNle2lmKGUuY2xhc3NMaXN0KXtlLmNsYXNzTGlzdC5yZW1vdmUodCk7aWYoZS5jbGFzc0xpc3QubGVuZ3RoPT09MCl7ZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKX19fX1mdW5jdGlvbiBMKGUsdCl7ZT1NKGUpO2UuY2xhc3NMaXN0LnRvZ2dsZSh0KX1mdW5jdGlvbiBIKGUsdCl7ZT1NKGUpO1koZS5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLGZ1bmN0aW9uKGUpe1QoZSx0KX0pO3EoZSx0KX1mdW5jdGlvbiBBKGUsdCl7ZT1NKGUpO2lmKGUuY2xvc2VzdCl7cmV0dXJuIGUuY2xvc2VzdCh0KX1lbHNle2Rve2lmKGU9PW51bGx8fGQoZSx0KSl7cmV0dXJuIGV9fXdoaWxlKGU9ZSYmdShlKSk7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIE4oZSx0KXtpZih0LmluZGV4T2YoXCJjbG9zZXN0IFwiKT09PTApe3JldHVybltBKGUsdC5zdWJzdHIoOCkpXX1lbHNlIGlmKHQuaW5kZXhPZihcImZpbmQgXCIpPT09MCl7cmV0dXJuW0MoZSx0LnN1YnN0cig1KSldfWVsc2UgaWYodC5pbmRleE9mKFwibmV4dCBcIik9PT0wKXtyZXR1cm5bSShlLHQuc3Vic3RyKDUpKV19ZWxzZSBpZih0LmluZGV4T2YoXCJwcmV2aW91cyBcIik9PT0wKXtyZXR1cm5bayhlLHQuc3Vic3RyKDkpKV19ZWxzZSBpZih0PT09XCJkb2N1bWVudFwiKXtyZXR1cm5bZG9jdW1lbnRdfWVsc2UgaWYodD09PVwid2luZG93XCIpe3JldHVyblt3aW5kb3ddfWVsc2V7cmV0dXJuICQoKS5xdWVyeVNlbGVjdG9yQWxsKHQpfX12YXIgST1mdW5jdGlvbihlLHQpe3ZhciByPSQoKS5xdWVyeVNlbGVjdG9yQWxsKHQpO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2lmKGkuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSk9PT1Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyl7cmV0dXJuIGl9fX07dmFyIGs9ZnVuY3Rpb24oZSx0KXt2YXIgcj0kKCkucXVlcnlTZWxlY3RvckFsbCh0KTtmb3IodmFyIG49ci5sZW5ndGgtMTtuPj0wO24tLSl7dmFyIGk9cltuXTtpZihpLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpPT09Tm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpe3JldHVybiBpfX19O2Z1bmN0aW9uIGllKGUsdCl7aWYodCl7cmV0dXJuIE4oZSx0KVswXX1lbHNle3JldHVybiBOKCQoKS5ib2R5LGUpWzBdfX1mdW5jdGlvbiBNKGUpe2lmKGcoZSxcIlN0cmluZ1wiKSl7cmV0dXJuIEMoZSl9ZWxzZXtyZXR1cm4gZX19ZnVuY3Rpb24gUChlLHQscil7aWYocCh0KSl7cmV0dXJue3RhcmdldDokKCkuYm9keSxldmVudDplLGxpc3RlbmVyOnR9fWVsc2V7cmV0dXJue3RhcmdldDpNKGUpLGV2ZW50OnQsbGlzdGVuZXI6cn19fWZ1bmN0aW9uIEQodCxyLG4pe3ByKGZ1bmN0aW9uKCl7dmFyIGU9UCh0LHIsbik7ZS50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihlLmV2ZW50LGUubGlzdGVuZXIpfSk7dmFyIGU9cChyKTtyZXR1cm4gZT9yOm59ZnVuY3Rpb24gWCh0LHIsbil7cHIoZnVuY3Rpb24oKXt2YXIgZT1QKHQscixuKTtlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGUuZXZlbnQsZS5saXN0ZW5lcil9KTtyZXR1cm4gcChyKT9yOm59dmFyIGFlPSQoKS5jcmVhdGVFbGVtZW50KFwib3V0cHV0XCIpO2Z1bmN0aW9uIEYoZSx0KXt2YXIgcj1aKGUsdCk7aWYocil7aWYocj09PVwidGhpc1wiKXtyZXR1cm5bb2UoZSx0KV19ZWxzZXt2YXIgbj1OKGUscik7aWYobi5sZW5ndGg9PT0wKXtTdCgnVGhlIHNlbGVjdG9yIFwiJytyKydcIiBvbiAnK3QrXCIgcmV0dXJuZWQgbm8gbWF0Y2hlcyFcIik7cmV0dXJuW2FlXX1lbHNle3JldHVybiBufX19fWZ1bmN0aW9uIG9lKGUsdCl7cmV0dXJuIGgoZSxmdW5jdGlvbihlKXtyZXR1cm4gSihlLHQpIT1udWxsfSl9ZnVuY3Rpb24gc2UoZSl7dmFyIHQ9WihlLFwiaHgtdGFyZ2V0XCIpO2lmKHQpe2lmKHQ9PT1cInRoaXNcIil7cmV0dXJuIG9lKGUsXCJoeC10YXJnZXRcIil9ZWxzZXtyZXR1cm4gaWUoZSx0KX19ZWxzZXt2YXIgcj1LKGUpO2lmKHIuYm9vc3RlZCl7cmV0dXJuICQoKS5ib2R5fWVsc2V7cmV0dXJuIGV9fX1mdW5jdGlvbiBCKGUpe3ZhciB0PXouY29uZmlnLmF0dHJpYnV0ZXNUb1NldHRsZTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7aWYoZT09PXRbcl0pe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gaih0LHIpe1kodC5hdHRyaWJ1dGVzLGZ1bmN0aW9uKGUpe2lmKCFyLmhhc0F0dHJpYnV0ZShlLm5hbWUpJiZCKGUubmFtZSkpe3QucmVtb3ZlQXR0cmlidXRlKGUubmFtZSl9fSk7WShyLmF0dHJpYnV0ZXMsZnVuY3Rpb24oZSl7aWYoQihlLm5hbWUpKXt0LnNldEF0dHJpYnV0ZShlLm5hbWUsZS52YWx1ZSl9fSl9ZnVuY3Rpb24gVShlLHQpe3ZhciByPWdyKHQpO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO3RyeXtpZihpLmlzSW5saW5lU3dhcChlKSl7cmV0dXJuIHRydWV9fWNhdGNoKGUpe1N0KGUpfX1yZXR1cm4gZT09PVwib3V0ZXJIVE1MXCJ9ZnVuY3Rpb24gVihlLGksYSl7dmFyIHQ9XCIjXCIraS5pZDt2YXIgbz1cIm91dGVySFRNTFwiO2lmKGU9PT1cInRydWVcIil7fWVsc2UgaWYoZS5pbmRleE9mKFwiOlwiKT4wKXtvPWUuc3Vic3RyKDAsZS5pbmRleE9mKFwiOlwiKSk7dD1lLnN1YnN0cihlLmluZGV4T2YoXCI6XCIpKzEsZS5sZW5ndGgpfWVsc2V7bz1lfXZhciByPSQoKS5xdWVyeVNlbGVjdG9yQWxsKHQpO2lmKHIpe1kocixmdW5jdGlvbihlKXt2YXIgdDt2YXIgcj1pLmNsb25lTm9kZSh0cnVlKTt0PSQoKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7dC5hcHBlbmRDaGlsZChyKTtpZighVShvLGUpKXt0PXJ9dmFyIG49e3Nob3VsZFN3YXA6dHJ1ZSx0YXJnZXQ6ZSxmcmFnbWVudDp0fTtpZighZWUoZSxcImh0bXg6b29iQmVmb3JlU3dhcFwiLG4pKXJldHVybjtlPW4udGFyZ2V0O2lmKG5bXCJzaG91bGRTd2FwXCJdKXtDZShvLGUsZSx0LGEpfVkoYS5lbHRzLGZ1bmN0aW9uKGUpe2VlKGUsXCJodG14Om9vYkFmdGVyU3dhcFwiLG4pfSl9KTtpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaSl9ZWxzZXtpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaSk7USgkKCkuYm9keSxcImh0bXg6b29iRXJyb3JOb1RhcmdldFwiLHtjb250ZW50Oml9KX1yZXR1cm4gZX1mdW5jdGlvbiBfKGUsdCxyKXt2YXIgbj1aKGUsXCJoeC1zZWxlY3Qtb29iXCIpO2lmKG4pe3ZhciBpPW4uc3BsaXQoXCIsXCIpO2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXt2YXIgYT1pW2VdLnNwbGl0KFwiOlwiLDIpO3ZhciBvPWFbMF07aWYoby5pbmRleE9mKFwiI1wiKT09PTApe289by5zdWJzdHJpbmcoMSl9dmFyIHM9YVsxXXx8XCJ0cnVlXCI7dmFyIGw9dC5xdWVyeVNlbGVjdG9yKFwiI1wiK28pO2lmKGwpe1YocyxsLHIpfX19WShSKHQsXCJbaHgtc3dhcC1vb2JdLCBbZGF0YS1oeC1zd2FwLW9vYl1cIiksZnVuY3Rpb24oZSl7dmFyIHQ9SihlLFwiaHgtc3dhcC1vb2JcIik7aWYodCE9bnVsbCl7Vih0LGUscil9fSl9ZnVuY3Rpb24gVyhlKXtZKFIoZSxcIltoeC1wcmVzZXJ2ZV0sIFtkYXRhLWh4LXByZXNlcnZlXVwiKSxmdW5jdGlvbihlKXt2YXIgdD1KKGUsXCJpZFwiKTt2YXIgcj0kKCkuZ2V0RWxlbWVudEJ5SWQodCk7aWYociE9bnVsbCl7ZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyLGUpfX0pfWZ1bmN0aW9uIGxlKG4sZSxpKXtZKGUucXVlcnlTZWxlY3RvckFsbChcIltpZF1cIiksZnVuY3Rpb24oZSl7aWYoZS5pZCYmZS5pZC5sZW5ndGg+MCl7dmFyIHQ9bi5xdWVyeVNlbGVjdG9yKGUudGFnTmFtZStcIltpZD0nXCIrZS5pZCtcIiddXCIpO2lmKHQmJnQhPT1uKXt2YXIgcj1lLmNsb25lTm9kZSgpO2ooZSx0KTtpLnRhc2tzLnB1c2goZnVuY3Rpb24oKXtqKGUscil9KX19fSl9ZnVuY3Rpb24gdWUoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7VChlLHouY29uZmlnLmFkZGVkQ2xhc3MpO210KGUpO2h0KGUpO2ZlKGUpO2VlKGUsXCJodG14OmxvYWRcIil9fWZ1bmN0aW9uIGZlKGUpe3ZhciB0PVwiW2F1dG9mb2N1c11cIjt2YXIgcj1kKGUsdCk/ZTplLnF1ZXJ5U2VsZWN0b3IodCk7aWYociE9bnVsbCl7ci5mb2N1cygpfX1mdW5jdGlvbiBjZShlLHQscixuKXtsZShlLHIsbik7d2hpbGUoci5jaGlsZE5vZGVzLmxlbmd0aD4wKXt2YXIgaT1yLmZpcnN0Q2hpbGQ7cShpLHouY29uZmlnLmFkZGVkQ2xhc3MpO2UuaW5zZXJ0QmVmb3JlKGksdCk7aWYoaS5ub2RlVHlwZSE9PU5vZGUuVEVYVF9OT0RFJiZpLm5vZGVUeXBlIT09Tm9kZS5DT01NRU5UX05PREUpe24udGFza3MucHVzaCh1ZShpKSl9fX1mdW5jdGlvbiBoZShlLHQpe3ZhciByPTA7d2hpbGUocjxlLmxlbmd0aCl7dD0odDw8NSktdCtlLmNoYXJDb2RlQXQocisrKXwwfXJldHVybiB0fWZ1bmN0aW9uIGRlKGUpe3ZhciB0PTA7aWYoZS5hdHRyaWJ1dGVzKXtmb3IodmFyIHI9MDtyPGUuYXR0cmlidXRlcy5sZW5ndGg7cisrKXt2YXIgbj1lLmF0dHJpYnV0ZXNbcl07aWYobi52YWx1ZSl7dD1oZShuLm5hbWUsdCk7dD1oZShuLnZhbHVlLHQpfX19cmV0dXJuIHR9ZnVuY3Rpb24gdmUoZSl7dmFyIHQ9SyhlKTtpZih0LndlYlNvY2tldCl7dC53ZWJTb2NrZXQuY2xvc2UoKX1pZih0LnNzZUV2ZW50U291cmNlKXt0LnNzZUV2ZW50U291cmNlLmNsb3NlKCl9aWYodC5saXN0ZW5lckluZm9zKXtZKHQubGlzdGVuZXJJbmZvcyxmdW5jdGlvbihlKXtpZihlLm9uKXtlLm9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoZS50cmlnZ2VyLGUubGlzdGVuZXIpfX0pfX1mdW5jdGlvbiBnZShlKXtlZShlLFwiaHRteDpiZWZvcmVDbGVhbnVwRWxlbWVudFwiKTt2ZShlKTtpZihlLmNoaWxkcmVuKXtZKGUuY2hpbGRyZW4sZnVuY3Rpb24oZSl7Z2UoZSl9KX19ZnVuY3Rpb24gcGUoZSx0LHIpe2lmKGUudGFnTmFtZT09PVwiQk9EWVwiKXtyZXR1cm4gU2UoZSx0LHIpfWVsc2V7dmFyIG47dmFyIGk9ZS5wcmV2aW91c1NpYmxpbmc7Y2UodShlKSxlLHQscik7aWYoaT09bnVsbCl7bj11KGUpLmZpcnN0Q2hpbGR9ZWxzZXtuPWkubmV4dFNpYmxpbmd9SyhlKS5yZXBsYWNlZFdpdGg9bjtyLmVsdHM9W107d2hpbGUobiYmbiE9PWUpe2lmKG4ubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7ci5lbHRzLnB1c2gobil9bj1uLm5leHRFbGVtZW50U2libGluZ31nZShlKTt1KGUpLnJlbW92ZUNoaWxkKGUpfX1mdW5jdGlvbiBtZShlLHQscil7cmV0dXJuIGNlKGUsZS5maXJzdENoaWxkLHQscil9ZnVuY3Rpb24geWUoZSx0LHIpe3JldHVybiBjZSh1KGUpLGUsdCxyKX1mdW5jdGlvbiB4ZShlLHQscil7cmV0dXJuIGNlKGUsbnVsbCx0LHIpfWZ1bmN0aW9uIGJlKGUsdCxyKXtyZXR1cm4gY2UodShlKSxlLm5leHRTaWJsaW5nLHQscil9ZnVuY3Rpb24gd2UoZSx0LHIpe2dlKGUpO3JldHVybiB1KGUpLnJlbW92ZUNoaWxkKGUpfWZ1bmN0aW9uIFNlKGUsdCxyKXt2YXIgbj1lLmZpcnN0Q2hpbGQ7Y2UoZSxuLHQscik7aWYobil7d2hpbGUobi5uZXh0U2libGluZyl7Z2Uobi5uZXh0U2libGluZyk7ZS5yZW1vdmVDaGlsZChuLm5leHRTaWJsaW5nKX1nZShuKTtlLnJlbW92ZUNoaWxkKG4pfX1mdW5jdGlvbiBFZShlLHQpe3ZhciByPVooZSxcImh4LXNlbGVjdFwiKTtpZihyKXt2YXIgbj0kKCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1kodC5xdWVyeVNlbGVjdG9yQWxsKHIpLGZ1bmN0aW9uKGUpe24uYXBwZW5kQ2hpbGQoZSl9KTt0PW59cmV0dXJuIHR9ZnVuY3Rpb24gQ2UoZSx0LHIsbixpKXtzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybjtjYXNlXCJvdXRlckhUTUxcIjpwZShyLG4saSk7cmV0dXJuO2Nhc2VcImFmdGVyYmVnaW5cIjptZShyLG4saSk7cmV0dXJuO2Nhc2VcImJlZm9yZWJlZ2luXCI6eWUocixuLGkpO3JldHVybjtjYXNlXCJiZWZvcmVlbmRcIjp4ZShyLG4saSk7cmV0dXJuO2Nhc2VcImFmdGVyZW5kXCI6YmUocixuLGkpO3JldHVybjtjYXNlXCJkZWxldGVcIjp3ZShyLG4saSk7cmV0dXJuO2RlZmF1bHQ6dmFyIGE9Z3IodCk7Zm9yKHZhciBvPTA7bzxhLmxlbmd0aDtvKyspe3ZhciBmPWFbb107dHJ5e3ZhciBzPWYuaGFuZGxlU3dhcChlLHIsbixpKTtpZihzKXtpZih0eXBlb2Ygcy5sZW5ndGghPT1cInVuZGVmaW5lZFwiKXtmb3IodmFyIGw9MDtsPHMubGVuZ3RoO2wrKyl7dmFyIHU9c1tsXTtpZih1Lm5vZGVUeXBlIT09Tm9kZS5URVhUX05PREUmJnUubm9kZVR5cGUhPT1Ob2RlLkNPTU1FTlRfTk9ERSl7aS50YXNrcy5wdXNoKHVlKHUpKX19fXJldHVybn19Y2F0Y2goZSl7U3QoZSl9fWlmKGU9PT1cImlubmVySFRNTFwiKXtTZShyLG4saSl9ZWxzZXtDZSh6LmNvbmZpZy5kZWZhdWx0U3dhcFN0eWxlLHQscixuLGkpfX19ZnVuY3Rpb24gUmUoZSl7aWYoZS5pbmRleE9mKFwiPHRpdGxlXCIpPi0xKXt2YXIgdD1lLnJlcGxhY2UoLzxzdmcoXFxzW14+XSo+fD4pKFtcXHNcXFNdKj8pPFxcL3N2Zz4vZ2ltLFwiXCIpO3ZhciByPXQubWF0Y2goLzx0aXRsZShcXHNbXj5dKj58PikoW1xcc1xcU10qPyk8XFwvdGl0bGU+L2ltKTtpZihyKXtyZXR1cm4gclsyXX19fWZ1bmN0aW9uIE9lKGUsdCxyLG4saSl7aS50aXRsZT1SZShuKTt2YXIgYT1mKG4pO2lmKGEpe18ocixhLGkpO2E9RWUocixhKTtXKGEpO3JldHVybiBDZShlLHIsdCxhLGkpfX1mdW5jdGlvbiBxZShlLHQscil7dmFyIG49ZS5nZXRSZXNwb25zZUhlYWRlcih0KTtpZihuLmluZGV4T2YoXCJ7XCIpPT09MCl7dmFyIGk9dyhuKTtmb3IodmFyIGEgaW4gaSl7aWYoaS5oYXNPd25Qcm9wZXJ0eShhKSl7dmFyIG89aVthXTtpZighbShvKSl7bz17dmFsdWU6b319ZWUocixhLG8pfX19ZWxzZXtlZShyLG4sW10pfX12YXIgVGU9L1xccy87dmFyIExlPS9bXFxzLF0vO3ZhciBIZT0vW18kYS16QS1aXS87dmFyIEFlPS9bXyRhLXpBLVowLTldLzt2YXIgTmU9WydcIicsXCInXCIsXCIvXCJdO3ZhciBJZT0vW15cXHNdLztmdW5jdGlvbiBrZShlKXt2YXIgdD1bXTt2YXIgcj0wO3doaWxlKHI8ZS5sZW5ndGgpe2lmKEhlLmV4ZWMoZS5jaGFyQXQocikpKXt2YXIgbj1yO3doaWxlKEFlLmV4ZWMoZS5jaGFyQXQocisxKSkpe3IrK310LnB1c2goZS5zdWJzdHIobixyLW4rMSkpfWVsc2UgaWYoTmUuaW5kZXhPZihlLmNoYXJBdChyKSkhPT0tMSl7dmFyIGk9ZS5jaGFyQXQocik7dmFyIG49cjtyKys7d2hpbGUocjxlLmxlbmd0aCYmZS5jaGFyQXQocikhPT1pKXtpZihlLmNoYXJBdChyKT09PVwiXFxcXFwiKXtyKyt9cisrfXQucHVzaChlLnN1YnN0cihuLHItbisxKSl9ZWxzZXt2YXIgYT1lLmNoYXJBdChyKTt0LnB1c2goYSl9cisrfXJldHVybiB0fWZ1bmN0aW9uIE1lKGUsdCxyKXtyZXR1cm4gSGUuZXhlYyhlLmNoYXJBdCgwKSkmJmUhPT1cInRydWVcIiYmZSE9PVwiZmFsc2VcIiYmZSE9PVwidGhpc1wiJiZlIT09ciYmdCE9PVwiLlwifWZ1bmN0aW9uIFBlKGUsdCxyKXtpZih0WzBdPT09XCJbXCIpe3Quc2hpZnQoKTt2YXIgbj0xO3ZhciBpPVwiIHJldHVybiAoZnVuY3Rpb24oXCIrcitcIil7IHJldHVybiAoXCI7dmFyIGE9bnVsbDt3aGlsZSh0Lmxlbmd0aD4wKXt2YXIgbz10WzBdO2lmKG89PT1cIl1cIil7bi0tO2lmKG49PT0wKXtpZihhPT09bnVsbCl7aT1pK1widHJ1ZVwifXQuc2hpZnQoKTtpKz1cIil9KVwiO3RyeXt2YXIgcz1RdChlLGZ1bmN0aW9uKCl7cmV0dXJuIEZ1bmN0aW9uKGkpKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHRydWV9KTtzLnNvdXJjZT1pO3JldHVybiBzfWNhdGNoKGUpe1EoJCgpLmJvZHksXCJodG14OnN5bnRheDplcnJvclwiLHtlcnJvcjplLHNvdXJjZTppfSk7cmV0dXJuIG51bGx9fX1lbHNlIGlmKG89PT1cIltcIil7bisrfWlmKE1lKG8sYSxyKSl7aSs9XCIoKFwiK3IrXCIuXCIrbytcIikgPyAoXCIrcitcIi5cIitvK1wiKSA6ICh3aW5kb3cuXCIrbytcIikpXCJ9ZWxzZXtpPWkrb31hPXQuc2hpZnQoKX19fWZ1bmN0aW9uIGMoZSx0KXt2YXIgcj1cIlwiO3doaWxlKGUubGVuZ3RoPjAmJiFlWzBdLm1hdGNoKHQpKXtyKz1lLnNoaWZ0KCl9cmV0dXJuIHJ9dmFyIERlPVwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIjtmdW5jdGlvbiBYZShlKXt2YXIgdD1KKGUsXCJoeC10cmlnZ2VyXCIpO3ZhciByPVtdO2lmKHQpe3ZhciBuPWtlKHQpO2Rve2MobixJZSk7dmFyIGY9bi5sZW5ndGg7dmFyIGk9YyhuLC9bLFxcW1xcc10vKTtpZihpIT09XCJcIil7aWYoaT09PVwiZXZlcnlcIil7dmFyIGE9e3RyaWdnZXI6XCJldmVyeVwifTtjKG4sSWUpO2EucG9sbEludGVydmFsPXYoYyhuLC9bLFxcW1xcc10vKSk7YyhuLEllKTt2YXIgbz1QZShlLG4sXCJldmVudFwiKTtpZihvKXthLmV2ZW50RmlsdGVyPW99ci5wdXNoKGEpfWVsc2UgaWYoaS5pbmRleE9mKFwic3NlOlwiKT09PTApe3IucHVzaCh7dHJpZ2dlcjpcInNzZVwiLHNzZUV2ZW50Omkuc3Vic3RyKDQpfSl9ZWxzZXt2YXIgcz17dHJpZ2dlcjppfTt2YXIgbz1QZShlLG4sXCJldmVudFwiKTtpZihvKXtzLmV2ZW50RmlsdGVyPW99d2hpbGUobi5sZW5ndGg+MCYmblswXSE9PVwiLFwiKXtjKG4sSWUpO3ZhciBsPW4uc2hpZnQoKTtpZihsPT09XCJjaGFuZ2VkXCIpe3MuY2hhbmdlZD10cnVlfWVsc2UgaWYobD09PVwib25jZVwiKXtzLm9uY2U9dHJ1ZX1lbHNlIGlmKGw9PT1cImNvbnN1bWVcIil7cy5jb25zdW1lPXRydWV9ZWxzZSBpZihsPT09XCJkZWxheVwiJiZuWzBdPT09XCI6XCIpe24uc2hpZnQoKTtzLmRlbGF5PXYoYyhuLExlKSl9ZWxzZSBpZihsPT09XCJmcm9tXCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3ZhciB1PWMobixMZSk7aWYodT09PVwiY2xvc2VzdFwifHx1PT09XCJmaW5kXCJ8fHU9PT1cIm5leHRcInx8dT09PVwicHJldmlvdXNcIil7bi5zaGlmdCgpO3UrPVwiIFwiK2MobixMZSl9cy5mcm9tPXV9ZWxzZSBpZihsPT09XCJ0YXJnZXRcIiYmblswXT09PVwiOlwiKXtuLnNoaWZ0KCk7cy50YXJnZXQ9YyhuLExlKX1lbHNlIGlmKGw9PT1cInRocm90dGxlXCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3MudGhyb3R0bGU9dihjKG4sTGUpKX1lbHNlIGlmKGw9PT1cInF1ZXVlXCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3MucXVldWU9YyhuLExlKX1lbHNlIGlmKChsPT09XCJyb290XCJ8fGw9PT1cInRocmVzaG9sZFwiKSYmblswXT09PVwiOlwiKXtuLnNoaWZ0KCk7c1tsXT1jKG4sTGUpfWVsc2V7UShlLFwiaHRteDpzeW50YXg6ZXJyb3JcIix7dG9rZW46bi5zaGlmdCgpfSl9fXIucHVzaChzKX19aWYobi5sZW5ndGg9PT1mKXtRKGUsXCJodG14OnN5bnRheDplcnJvclwiLHt0b2tlbjpuLnNoaWZ0KCl9KX1jKG4sSWUpfXdoaWxlKG5bMF09PT1cIixcIiYmbi5zaGlmdCgpKX1pZihyLmxlbmd0aD4wKXtyZXR1cm4gcn1lbHNlIGlmKGQoZSxcImZvcm1cIikpe3JldHVyblt7dHJpZ2dlcjpcInN1Ym1pdFwifV19ZWxzZSBpZihkKGUsJ2lucHV0W3R5cGU9XCJidXR0b25cIl0nKSl7cmV0dXJuW3t0cmlnZ2VyOlwiY2xpY2tcIn1dfWVsc2UgaWYoZChlLERlKSl7cmV0dXJuW3t0cmlnZ2VyOlwiY2hhbmdlXCJ9XX1lbHNle3JldHVyblt7dHJpZ2dlcjpcImNsaWNrXCJ9XX19ZnVuY3Rpb24gRmUoZSl7SyhlKS5jYW5jZWxsZWQ9dHJ1ZX1mdW5jdGlvbiBCZShlLHQscil7dmFyIG49SyhlKTtuLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKHJlKGUpJiZuLmNhbmNlbGxlZCE9PXRydWUpe2lmKCFXZShyLHh0KFwiaHg6cG9sbDp0cmlnZ2VyXCIse3RyaWdnZXJTcGVjOnIsdGFyZ2V0OmV9KSkpe3QoZSl9QmUoZSx0LHIpfX0sci5wb2xsSW50ZXJ2YWwpfWZ1bmN0aW9uIGplKGUpe3JldHVybiBsb2NhdGlvbi5ob3N0bmFtZT09PWUuaG9zdG5hbWUmJkcoZSxcImhyZWZcIikmJkcoZSxcImhyZWZcIikuaW5kZXhPZihcIiNcIikhPT0wfWZ1bmN0aW9uIFVlKHQscixlKXtpZih0LnRhZ05hbWU9PT1cIkFcIiYmamUodCkmJih0LnRhcmdldD09PVwiXCJ8fHQudGFyZ2V0PT09XCJfc2VsZlwiKXx8dC50YWdOYW1lPT09XCJGT1JNXCIpe3IuYm9vc3RlZD10cnVlO3ZhciBuLGk7aWYodC50YWdOYW1lPT09XCJBXCIpe249XCJnZXRcIjtpPUcodCxcImhyZWZcIil9ZWxzZXt2YXIgYT1HKHQsXCJtZXRob2RcIik7bj1hP2EudG9Mb3dlckNhc2UoKTpcImdldFwiO2lmKG49PT1cImdldFwiKXt9aT1HKHQsXCJhY3Rpb25cIil9ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3plKHQsZnVuY3Rpb24oZSx0KXtscihuLGksZSx0KX0scixlLHRydWUpfSl9fWZ1bmN0aW9uIFZlKGUsdCl7aWYoZS50eXBlPT09XCJzdWJtaXRcInx8ZS50eXBlPT09XCJjbGlja1wiKXtpZih0LnRhZ05hbWU9PT1cIkZPUk1cIil7cmV0dXJuIHRydWV9aWYoZCh0LCdpbnB1dFt0eXBlPVwic3VibWl0XCJdLCBidXR0b24nKSYmQSh0LFwiZm9ybVwiKSE9PW51bGwpe3JldHVybiB0cnVlfWlmKHQudGFnTmFtZT09PVwiQVwiJiZ0LmhyZWYmJih0LmdldEF0dHJpYnV0ZShcImhyZWZcIik9PT1cIiNcInx8dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLmluZGV4T2YoXCIjXCIpIT09MCkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gX2UoZSx0KXtyZXR1cm4gSyhlKS5ib29zdGVkJiZlLnRhZ05hbWU9PT1cIkFcIiYmdC50eXBlPT09XCJjbGlja1wiJiYodC5jdHJsS2V5fHx0Lm1ldGFLZXkpfWZ1bmN0aW9uIFdlKGUsdCl7dmFyIHI9ZS5ldmVudEZpbHRlcjtpZihyKXt0cnl7cmV0dXJuIHIodCkhPT10cnVlfWNhdGNoKGUpe1EoJCgpLmJvZHksXCJodG14OmV2ZW50RmlsdGVyOmVycm9yXCIse2Vycm9yOmUsc291cmNlOnIuc291cmNlfSk7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX1mdW5jdGlvbiB6ZShhLG8sZSxzLGwpe3ZhciB0O2lmKHMuZnJvbSl7dD1OKGEscy5mcm9tKX1lbHNle3Q9W2FdfVkodCxmdW5jdGlvbihuKXt2YXIgaT1mdW5jdGlvbihlKXtpZighcmUoYSkpe24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLnRyaWdnZXIsaSk7cmV0dXJufWlmKF9lKGEsZSkpe3JldHVybn1pZihsfHxWZShlLGEpKXtlLnByZXZlbnREZWZhdWx0KCl9aWYoV2UocyxlKSl7cmV0dXJufXZhciB0PUsoZSk7dC50cmlnZ2VyU3BlYz1zO2lmKHQuaGFuZGxlZEZvcj09bnVsbCl7dC5oYW5kbGVkRm9yPVtdfXZhciByPUsoYSk7aWYodC5oYW5kbGVkRm9yLmluZGV4T2YoYSk8MCl7dC5oYW5kbGVkRm9yLnB1c2goYSk7aWYocy5jb25zdW1lKXtlLnN0b3BQcm9wYWdhdGlvbigpfWlmKHMudGFyZ2V0JiZlLnRhcmdldCl7aWYoIWQoZS50YXJnZXQscy50YXJnZXQpKXtyZXR1cm59fWlmKHMub25jZSl7aWYoci50cmlnZ2VyZWRPbmNlKXtyZXR1cm59ZWxzZXtyLnRyaWdnZXJlZE9uY2U9dHJ1ZX19aWYocy5jaGFuZ2VkKXtpZihyLmxhc3RWYWx1ZT09PWEudmFsdWUpe3JldHVybn1lbHNle3IubGFzdFZhbHVlPWEudmFsdWV9fWlmKHIuZGVsYXllZCl7Y2xlYXJUaW1lb3V0KHIuZGVsYXllZCl9aWYoci50aHJvdHRsZSl7cmV0dXJufWlmKHMudGhyb3R0bGUpe2lmKCFyLnRocm90dGxlKXtvKGEsZSk7ci50aHJvdHRsZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ci50aHJvdHRsZT1udWxsfSxzLnRocm90dGxlKX19ZWxzZSBpZihzLmRlbGF5KXtyLmRlbGF5ZWQ9c2V0VGltZW91dChmdW5jdGlvbigpe28oYSxlKX0scy5kZWxheSl9ZWxzZXtvKGEsZSl9fX07aWYoZS5saXN0ZW5lckluZm9zPT1udWxsKXtlLmxpc3RlbmVySW5mb3M9W119ZS5saXN0ZW5lckluZm9zLnB1c2goe3RyaWdnZXI6cy50cmlnZ2VyLGxpc3RlbmVyOmksb246bn0pO24uYWRkRXZlbnRMaXN0ZW5lcihzLnRyaWdnZXIsaSl9KX12YXIgR2U9ZmFsc2U7dmFyIEplPW51bGw7ZnVuY3Rpb24gJGUoKXtpZighSmUpe0plPWZ1bmN0aW9uKCl7R2U9dHJ1ZX07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixKZSk7c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihHZSl7R2U9ZmFsc2U7WSgkKCkucXVlcnlTZWxlY3RvckFsbChcIltoeC10cmlnZ2VyPSdyZXZlYWxlZCddLFtkYXRhLWh4LXRyaWdnZXI9J3JldmVhbGVkJ11cIiksZnVuY3Rpb24oZSl7WmUoZSl9KX19LDIwMCl9fWZ1bmN0aW9uIFplKHQpe2lmKCFvKHQsXCJkYXRhLWh4LXJldmVhbGVkXCIpJiZ4KHQpKXt0LnNldEF0dHJpYnV0ZShcImRhdGEtaHgtcmV2ZWFsZWRcIixcInRydWVcIik7dmFyIGU9Syh0KTtpZihlLmluaXRIYXNoKXtlZSh0LFwicmV2ZWFsZWRcIil9ZWxzZXt0LmFkZEV2ZW50TGlzdGVuZXIoXCJodG14OmFmdGVyUHJvY2Vzc05vZGVcIixmdW5jdGlvbihlKXtlZSh0LFwicmV2ZWFsZWRcIil9LHtvbmNlOnRydWV9KX19fWZ1bmN0aW9uIEtlKGUsdCxyKXt2YXIgbj1iKHIpO2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgYT1uW2ldLnNwbGl0KC86KC4rKS8pO2lmKGFbMF09PT1cImNvbm5lY3RcIil7WWUoZSxhWzFdLDApfWlmKGFbMF09PT1cInNlbmRcIil7ZXQoZSl9fX1mdW5jdGlvbiBZZShzLHIsbil7aWYoIXJlKHMpKXtyZXR1cm59aWYoci5pbmRleE9mKFwiL1wiKT09MCl7dmFyIGU9bG9jYXRpb24uaG9zdG5hbWUrKGxvY2F0aW9uLnBvcnQ/XCI6XCIrbG9jYXRpb24ucG9ydDpcIlwiKTtpZihsb2NhdGlvbi5wcm90b2NvbD09XCJodHRwczpcIil7cj1cIndzczovL1wiK2Urcn1lbHNlIGlmKGxvY2F0aW9uLnByb3RvY29sPT1cImh0dHA6XCIpe3I9XCJ3czovL1wiK2Urcn19dmFyIHQ9ei5jcmVhdGVXZWJTb2NrZXQocik7dC5vbmVycm9yPWZ1bmN0aW9uKGUpe1EocyxcImh0bXg6d3NFcnJvclwiLHtlcnJvcjplLHNvY2tldDp0fSk7UWUocyl9O3Qub25jbG9zZT1mdW5jdGlvbihlKXtpZihbMTAwNiwxMDEyLDEwMTNdLmluZGV4T2YoZS5jb2RlKT49MCl7dmFyIHQ9dHQobik7c2V0VGltZW91dChmdW5jdGlvbigpe1llKHMscixuKzEpfSx0KX19O3Qub25vcGVuPWZ1bmN0aW9uKGUpe249MH07SyhzKS53ZWJTb2NrZXQ9dDt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oZSl7aWYoUWUocykpe3JldHVybn12YXIgdD1lLmRhdGE7d3QocyxmdW5jdGlvbihlKXt0PWUudHJhbnNmb3JtUmVzcG9uc2UodCxudWxsLHMpfSk7dmFyIHI9WnQocyk7dmFyIG49Zih0KTt2YXIgaT15KG4uY2hpbGRyZW4pO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgbz1pW2FdO1YoSihvLFwiaHgtc3dhcC1vb2JcIil8fFwidHJ1ZVwiLG8scil9QXQoci50YXNrcyl9KX1mdW5jdGlvbiBRZShlKXtpZighcmUoZSkpe0soZSkud2ViU29ja2V0LmNsb3NlKCk7cmV0dXJuIHRydWV9fWZ1bmN0aW9uIGV0KHUpe3ZhciBmPWgodSxmdW5jdGlvbihlKXtyZXR1cm4gSyhlKS53ZWJTb2NrZXQhPW51bGx9KTtpZihmKXt1LmFkZEV2ZW50TGlzdGVuZXIoWGUodSlbMF0udHJpZ2dlcixmdW5jdGlvbihlKXt2YXIgdD1LKGYpLndlYlNvY2tldDt2YXIgcj1fdCh1LGYpO3ZhciBuPUJ0KHUsXCJwb3N0XCIpO3ZhciBpPW4uZXJyb3JzO3ZhciBhPW4udmFsdWVzO3ZhciBvPXJyKHUpO3ZhciBzPW5lKGEsbyk7dmFyIGw9V3Qocyx1KTtsW1wiSEVBREVSU1wiXT1yO2lmKGkmJmkubGVuZ3RoPjApe2VlKHUsXCJodG14OnZhbGlkYXRpb246aGFsdGVkXCIsaSk7cmV0dXJufXQuc2VuZChKU09OLnN0cmluZ2lmeShsKSk7aWYoVmUoZSx1KSl7ZS5wcmV2ZW50RGVmYXVsdCgpfX0pfWVsc2V7USh1LFwiaHRteDpub1dlYlNvY2tldFNvdXJjZUVycm9yXCIpfX1mdW5jdGlvbiB0dChlKXt2YXIgdD16LmNvbmZpZy53c1JlY29ubmVjdERlbGF5O2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiKXtyZXR1cm4gdChlKX1pZih0PT09XCJmdWxsLWppdHRlclwiKXt2YXIgcj1NYXRoLm1pbihlLDYpO3ZhciBuPTFlMypNYXRoLnBvdygyLHIpO3JldHVybiBuKk1hdGgucmFuZG9tKCl9U3QoJ2h0bXguY29uZmlnLndzUmVjb25uZWN0RGVsYXkgbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciB0aGUgc3RyaW5nIFwiZnVsbC1qaXR0ZXJcIicpfWZ1bmN0aW9uIHJ0KGUsdCxyKXt2YXIgbj1iKHIpO2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgYT1uW2ldLnNwbGl0KC86KC4rKS8pO2lmKGFbMF09PT1cImNvbm5lY3RcIil7bnQoZSxhWzFdKX1pZihhWzBdPT09XCJzd2FwXCIpe2l0KGUsYVsxXSl9fX1mdW5jdGlvbiBudCh0LGUpe3ZhciByPXouY3JlYXRlRXZlbnRTb3VyY2UoZSk7ci5vbmVycm9yPWZ1bmN0aW9uKGUpe1EodCxcImh0bXg6c3NlRXJyb3JcIix7ZXJyb3I6ZSxzb3VyY2U6cn0pO290KHQpfTtLKHQpLnNzZUV2ZW50U291cmNlPXJ9ZnVuY3Rpb24gaXQoYSxvKXt2YXIgcz1oKGEsc3QpO2lmKHMpe3ZhciBsPUsocykuc3NlRXZlbnRTb3VyY2U7dmFyIHU9ZnVuY3Rpb24oZSl7aWYob3Qocykpe2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLHUpO3JldHVybn12YXIgdD1lLmRhdGE7d3QoYSxmdW5jdGlvbihlKXt0PWUudHJhbnNmb3JtUmVzcG9uc2UodCxudWxsLGEpfSk7dmFyIHI9R3QoYSk7dmFyIG49c2UoYSk7dmFyIGk9WnQoYSk7T2Uoci5zd2FwU3R5bGUsYSxuLHQsaSk7QXQoaS50YXNrcyk7ZWUoYSxcImh0bXg6c3NlTWVzc2FnZVwiLGUpfTtLKGEpLnNzZUxpc3RlbmVyPXU7bC5hZGRFdmVudExpc3RlbmVyKG8sdSl9ZWxzZXtRKGEsXCJodG14Om5vU1NFU291cmNlRXJyb3JcIil9fWZ1bmN0aW9uIGF0KGUsdCxyKXt2YXIgbj1oKGUsc3QpO2lmKG4pe3ZhciBpPUsobikuc3NlRXZlbnRTb3VyY2U7dmFyIGE9ZnVuY3Rpb24oKXtpZighb3Qobikpe2lmKHJlKGUpKXt0KGUpfWVsc2V7aS5yZW1vdmVFdmVudExpc3RlbmVyKHIsYSl9fX07SyhlKS5zc2VMaXN0ZW5lcj1hO2kuYWRkRXZlbnRMaXN0ZW5lcihyLGEpfWVsc2V7UShlLFwiaHRteDpub1NTRVNvdXJjZUVycm9yXCIpfX1mdW5jdGlvbiBvdChlKXtpZighcmUoZSkpe0soZSkuc3NlRXZlbnRTb3VyY2UuY2xvc2UoKTtyZXR1cm4gdHJ1ZX19ZnVuY3Rpb24gc3QoZSl7cmV0dXJuIEsoZSkuc3NlRXZlbnRTb3VyY2UhPW51bGx9ZnVuY3Rpb24gbHQoZSx0LHIsbil7dmFyIGk9ZnVuY3Rpb24oKXtpZighci5sb2FkZWQpe3IubG9hZGVkPXRydWU7dChlKX19O2lmKG4pe3NldFRpbWVvdXQoaSxuKX1lbHNle2koKX19ZnVuY3Rpb24gdXQodCxpLGUpe3ZhciBhPWZhbHNlO1kobixmdW5jdGlvbihyKXtpZihvKHQsXCJoeC1cIityKSl7dmFyIG49Sih0LFwiaHgtXCIrcik7YT10cnVlO2kucGF0aD1uO2kudmVyYj1yO2UuZm9yRWFjaChmdW5jdGlvbihlKXtmdCh0LGUsaSxmdW5jdGlvbihlLHQpe2xyKHIsbixlLHQpfSl9KX19KTtyZXR1cm4gYX1mdW5jdGlvbiBmdChuLGUsdCxyKXtpZihlLnNzZUV2ZW50KXthdChuLHIsZS5zc2VFdmVudCl9ZWxzZSBpZihlLnRyaWdnZXI9PT1cInJldmVhbGVkXCIpeyRlKCk7emUobixyLHQsZSk7WmUobil9ZWxzZSBpZihlLnRyaWdnZXI9PT1cImludGVyc2VjdFwiKXt2YXIgaT17fTtpZihlLnJvb3Qpe2kucm9vdD1pZShuLGUucm9vdCl9aWYoZS50aHJlc2hvbGQpe2kudGhyZXNob2xkPXBhcnNlRmxvYXQoZS50aHJlc2hvbGQpfXZhciBhPW5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7dmFyIHI9ZVt0XTtpZihyLmlzSW50ZXJzZWN0aW5nKXtlZShuLFwiaW50ZXJzZWN0XCIpO2JyZWFrfX19LGkpO2Eub2JzZXJ2ZShuKTt6ZShuLHIsdCxlKX1lbHNlIGlmKGUudHJpZ2dlcj09PVwibG9hZFwiKXtpZighV2UoZSx4dChcImxvYWRcIix7ZWx0Om59KSkpe2x0KG4scix0LGUuZGVsYXkpfX1lbHNlIGlmKGUucG9sbEludGVydmFsKXt0LnBvbGxpbmc9dHJ1ZTtCZShuLHIsZSl9ZWxzZXt6ZShuLHIsdCxlKX19ZnVuY3Rpb24gY3QoZSl7aWYoZS50eXBlPT09XCJ0ZXh0L2phdmFzY3JpcHRcInx8ZS50eXBlPT09XCJtb2R1bGVcInx8ZS50eXBlPT09XCJcIil7dmFyIHQ9JCgpLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7WShlLmF0dHJpYnV0ZXMsZnVuY3Rpb24oZSl7dC5zZXRBdHRyaWJ1dGUoZS5uYW1lLGUudmFsdWUpfSk7dC50ZXh0Q29udGVudD1lLnRleHRDb250ZW50O3QuYXN5bmM9ZmFsc2U7aWYoei5jb25maWcuaW5saW5lU2NyaXB0Tm9uY2Upe3Qubm9uY2U9ei5jb25maWcuaW5saW5lU2NyaXB0Tm9uY2V9dmFyIHI9ZS5wYXJlbnRFbGVtZW50O3RyeXtyLmluc2VydEJlZm9yZSh0LGUpfWNhdGNoKGUpe1N0KGUpfWZpbmFsbHl7aWYoZS5wYXJlbnRFbGVtZW50KXtlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZSl9fX19ZnVuY3Rpb24gaHQoZSl7aWYoZChlLFwic2NyaXB0XCIpKXtjdChlKX1ZKFIoZSxcInNjcmlwdFwiKSxmdW5jdGlvbihlKXtjdChlKX0pfWZ1bmN0aW9uIGR0KCl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbaHgtYm9vc3RdLCBbZGF0YS1oeC1ib29zdF1cIil9ZnVuY3Rpb24gdnQoZSl7aWYoZS5xdWVyeVNlbGVjdG9yQWxsKXt2YXIgdD1kdCgpP1wiLCBhLCBmb3JtXCI6XCJcIjt2YXIgcj1lLnF1ZXJ5U2VsZWN0b3JBbGwoaSt0K1wiLCBbaHgtc3NlXSwgW2RhdGEtaHgtc3NlXSwgW2h4LXdzXSxcIitcIiBbZGF0YS1oeC13c10sIFtoeC1leHRdLCBbZGF0YS1oeC1leHRdXCIpO3JldHVybiByfWVsc2V7cmV0dXJuW119fWZ1bmN0aW9uIGd0KG4pe3ZhciBlPWZ1bmN0aW9uKGUpe3ZhciB0PUEoZS50YXJnZXQsXCJidXR0b24sIGlucHV0W3R5cGU9J3N1Ym1pdCddXCIpO2lmKHQhPT1udWxsKXt2YXIgcj1LKG4pO3IubGFzdEJ1dHRvbkNsaWNrZWQ9dH19O24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZSk7bi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLGUpO24uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsZnVuY3Rpb24oZSl7dmFyIHQ9SyhuKTt0Lmxhc3RCdXR0b25DbGlja2VkPW51bGx9KX1mdW5jdGlvbiBwdChlKXtpZihlLmNsb3Nlc3QmJmUuY2xvc2VzdCh6LmNvbmZpZy5kaXNhYmxlU2VsZWN0b3IpKXtyZXR1cm59dmFyIHQ9SyhlKTtpZih0LmluaXRIYXNoIT09ZGUoZSkpe3QuaW5pdEhhc2g9ZGUoZSk7dmUoZSk7ZWUoZSxcImh0bXg6YmVmb3JlUHJvY2Vzc05vZGVcIik7aWYoZS52YWx1ZSl7dC5sYXN0VmFsdWU9ZS52YWx1ZX12YXIgcj1YZShlKTt2YXIgbj11dChlLHQscik7aWYoIW4mJlooZSxcImh4LWJvb3N0XCIpPT09XCJ0cnVlXCIpe1VlKGUsdCxyKX1pZihlLnRhZ05hbWU9PT1cIkZPUk1cIil7Z3QoZSl9dmFyIGk9SihlLFwiaHgtc3NlXCIpO2lmKGkpe3J0KGUsdCxpKX12YXIgYT1KKGUsXCJoeC13c1wiKTtpZihhKXtLZShlLHQsYSl9ZWUoZSxcImh0bXg6YWZ0ZXJQcm9jZXNzTm9kZVwiKX19ZnVuY3Rpb24gbXQoZSl7ZT1NKGUpO3B0KGUpO1kodnQoZSksZnVuY3Rpb24oZSl7cHQoZSl9KX1mdW5jdGlvbiB5dChlKXtyZXR1cm4gZS5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiB4dChlLHQpe3ZhciByO2lmKHdpbmRvdy5DdXN0b21FdmVudCYmdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudD09PVwiZnVuY3Rpb25cIil7cj1uZXcgQ3VzdG9tRXZlbnQoZSx7YnViYmxlczp0cnVlLGNhbmNlbGFibGU6dHJ1ZSxkZXRhaWw6dH0pfWVsc2V7cj0kKCkuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyLmluaXRDdXN0b21FdmVudChlLHRydWUsdHJ1ZSx0KX1yZXR1cm4gcn1mdW5jdGlvbiBRKGUsdCxyKXtlZShlLHQsbmUoe2Vycm9yOnR9LHIpKX1mdW5jdGlvbiBidChlKXtyZXR1cm4gZT09PVwiaHRteDphZnRlclByb2Nlc3NOb2RlXCJ9ZnVuY3Rpb24gd3QoZSx0KXtZKGdyKGUpLGZ1bmN0aW9uKGUpe3RyeXt0KGUpfWNhdGNoKGUpe1N0KGUpfX0pfWZ1bmN0aW9uIFN0KGUpe2lmKGNvbnNvbGUuZXJyb3Ipe2NvbnNvbGUuZXJyb3IoZSl9ZWxzZSBpZihjb25zb2xlLmxvZyl7Y29uc29sZS5sb2coXCJFUlJPUjogXCIsZSl9fWZ1bmN0aW9uIGVlKGUsdCxyKXtlPU0oZSk7aWYocj09bnVsbCl7cj17fX1yW1wiZWx0XCJdPWU7dmFyIG49eHQodCxyKTtpZih6LmxvZ2dlciYmIWJ0KHQpKXt6LmxvZ2dlcihlLHQscil9aWYoci5lcnJvcil7U3Qoci5lcnJvcik7ZWUoZSxcImh0bXg6ZXJyb3JcIix7ZXJyb3JJbmZvOnJ9KX12YXIgaT1lLmRpc3BhdGNoRXZlbnQobik7dmFyIGE9eXQodCk7aWYoaSYmYSE9PXQpe3ZhciBvPXh0KGEsbi5kZXRhaWwpO2k9aSYmZS5kaXNwYXRjaEV2ZW50KG8pfXd0KGUsZnVuY3Rpb24oZSl7aT1pJiZlLm9uRXZlbnQodCxuKSE9PWZhbHNlfSk7cmV0dXJuIGl9dmFyIEV0PWxvY2F0aW9uLnBhdGhuYW1lK2xvY2F0aW9uLnNlYXJjaDtmdW5jdGlvbiBDdCgpe3ZhciBlPSQoKS5xdWVyeVNlbGVjdG9yKFwiW2h4LWhpc3RvcnktZWx0XSxbZGF0YS1oeC1oaXN0b3J5LWVsdF1cIik7cmV0dXJuIGV8fCQoKS5ib2R5fWZ1bmN0aW9uIFJ0KGUsdCxyLG4pe2lmKCFTKCkpe3JldHVybn12YXIgaT13KGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaHRteC1oaXN0b3J5LWNhY2hlXCIpKXx8W107Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspe2lmKGlbYV0udXJsPT09ZSl7aS5zcGxpY2UoYSwxKTticmVha319dmFyIG89e3VybDplLGNvbnRlbnQ6dCx0aXRsZTpyLHNjcm9sbDpufTtlZSgkKCkuYm9keSxcImh0bXg6aGlzdG9yeUl0ZW1DcmVhdGVkXCIse2l0ZW06byxjYWNoZTppfSk7aS5wdXNoKG8pO3doaWxlKGkubGVuZ3RoPnouY29uZmlnLmhpc3RvcnlDYWNoZVNpemUpe2kuc2hpZnQoKX13aGlsZShpLmxlbmd0aD4wKXt0cnl7bG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJodG14LWhpc3RvcnktY2FjaGVcIixKU09OLnN0cmluZ2lmeShpKSk7YnJlYWt9Y2F0Y2goZSl7USgkKCkuYm9keSxcImh0bXg6aGlzdG9yeUNhY2hlRXJyb3JcIix7Y2F1c2U6ZSxjYWNoZTppfSk7aS5zaGlmdCgpfX19ZnVuY3Rpb24gT3QoZSl7aWYoIVMoKSl7cmV0dXJuIG51bGx9dmFyIHQ9dyhsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImh0bXgtaGlzdG9yeS1jYWNoZVwiKSl8fFtdO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXtpZih0W3JdLnVybD09PWUpe3JldHVybiB0W3JdfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBxdChlKXt2YXIgdD16LmNvbmZpZy5yZXF1ZXN0Q2xhc3M7dmFyIHI9ZS5jbG9uZU5vZGUodHJ1ZSk7WShSKHIsXCIuXCIrdCksZnVuY3Rpb24oZSl7VChlLHQpfSk7cmV0dXJuIHIuaW5uZXJIVE1MfWZ1bmN0aW9uIFR0KCl7dmFyIGU9Q3QoKTt2YXIgdD1FdHx8bG9jYXRpb24ucGF0aG5hbWUrbG9jYXRpb24uc2VhcmNoO3ZhciByPSQoKS5xdWVyeVNlbGVjdG9yKCdbaHgtaGlzdG9yeT1cImZhbHNlXCIgaV0sW2RhdGEtaHgtaGlzdG9yeT1cImZhbHNlXCIgaV0nKTtpZighcil7ZWUoJCgpLmJvZHksXCJodG14OmJlZm9yZUhpc3RvcnlTYXZlXCIse3BhdGg6dCxoaXN0b3J5RWx0OmV9KTtSdCh0LHF0KGUpLCQoKS50aXRsZSx3aW5kb3cuc2Nyb2xsWSl9aWYoei5jb25maWcuaGlzdG9yeUVuYWJsZWQpaGlzdG9yeS5yZXBsYWNlU3RhdGUoe2h0bXg6dHJ1ZX0sJCgpLnRpdGxlLHdpbmRvdy5sb2NhdGlvbi5ocmVmKX1mdW5jdGlvbiBMdChlKXtpZih6LmNvbmZpZy5nZXRDYWNoZUJ1c3RlclBhcmFtKXtlPWUucmVwbGFjZSgvb3JnXFwuaHRteFxcLmNhY2hlLWJ1c3Rlcj1bXiZdKiY/LyxcIlwiKTtpZihlLmVuZHNXaXRoKFwiJlwiKXx8ZS5lbmRzV2l0aChcIj9cIikpe2U9ZS5zbGljZSgwLC0xKX19aWYoei5jb25maWcuaGlzdG9yeUVuYWJsZWQpe2hpc3RvcnkucHVzaFN0YXRlKHtodG14OnRydWV9LFwiXCIsZSl9RXQ9ZX1mdW5jdGlvbiBIdChlKXtpZih6LmNvbmZpZy5oaXN0b3J5RW5hYmxlZCloaXN0b3J5LnJlcGxhY2VTdGF0ZSh7aHRteDp0cnVlfSxcIlwiLGUpO0V0PWV9ZnVuY3Rpb24gQXQoZSl7WShlLGZ1bmN0aW9uKGUpe2UuY2FsbCgpfSl9ZnVuY3Rpb24gTnQoYSl7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3ZhciBvPXtwYXRoOmEseGhyOmV9O2VlKCQoKS5ib2R5LFwiaHRteDpoaXN0b3J5Q2FjaGVNaXNzXCIsbyk7ZS5vcGVuKFwiR0VUXCIsYSx0cnVlKTtlLnNldFJlcXVlc3RIZWFkZXIoXCJIWC1IaXN0b3J5LVJlc3RvcmUtUmVxdWVzdFwiLFwidHJ1ZVwiKTtlLm9ubG9hZD1mdW5jdGlvbigpe2lmKHRoaXMuc3RhdHVzPj0yMDAmJnRoaXMuc3RhdHVzPDQwMCl7ZWUoJCgpLmJvZHksXCJodG14Omhpc3RvcnlDYWNoZU1pc3NMb2FkXCIsbyk7dmFyIGU9Zih0aGlzLnJlc3BvbnNlKTtlPWUucXVlcnlTZWxlY3RvcihcIltoeC1oaXN0b3J5LWVsdF0sW2RhdGEtaHgtaGlzdG9yeS1lbHRdXCIpfHxlO3ZhciB0PUN0KCk7dmFyIHI9WnQodCk7dmFyIG49UmUodGhpcy5yZXNwb25zZSk7aWYobil7dmFyIGk9QyhcInRpdGxlXCIpO2lmKGkpe2kuaW5uZXJIVE1MPW59ZWxzZXt3aW5kb3cuZG9jdW1lbnQudGl0bGU9bn19U2UodCxlLHIpO0F0KHIudGFza3MpO0V0PWE7ZWUoJCgpLmJvZHksXCJodG14Omhpc3RvcnlSZXN0b3JlXCIse3BhdGg6YSxjYWNoZU1pc3M6dHJ1ZSxzZXJ2ZXJSZXNwb25zZTp0aGlzLnJlc3BvbnNlfSl9ZWxzZXtRKCQoKS5ib2R5LFwiaHRteDpoaXN0b3J5Q2FjaGVNaXNzTG9hZEVycm9yXCIsbyl9fTtlLnNlbmQoKX1mdW5jdGlvbiBJdChlKXtUdCgpO2U9ZXx8bG9jYXRpb24ucGF0aG5hbWUrbG9jYXRpb24uc2VhcmNoO3ZhciB0PU90KGUpO2lmKHQpe3ZhciByPWYodC5jb250ZW50KTt2YXIgbj1DdCgpO3ZhciBpPVp0KG4pO1NlKG4scixpKTtBdChpLnRhc2tzKTtkb2N1bWVudC50aXRsZT10LnRpdGxlO3dpbmRvdy5zY3JvbGxUbygwLHQuc2Nyb2xsKTtFdD1lO2VlKCQoKS5ib2R5LFwiaHRteDpoaXN0b3J5UmVzdG9yZVwiLHtwYXRoOmUsaXRlbTp0fSl9ZWxzZXtpZih6LmNvbmZpZy5yZWZyZXNoT25IaXN0b3J5TWlzcyl7d2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKX1lbHNle050KGUpfX19ZnVuY3Rpb24ga3QoZSl7dmFyIHQ9RihlLFwiaHgtaW5kaWNhdG9yXCIpO2lmKHQ9PW51bGwpe3Q9W2VdfVkodCxmdW5jdGlvbihlKXt2YXIgdD1LKGUpO3QucmVxdWVzdENvdW50PSh0LnJlcXVlc3RDb3VudHx8MCkrMTtlLmNsYXNzTGlzdFtcImFkZFwiXS5jYWxsKGUuY2xhc3NMaXN0LHouY29uZmlnLnJlcXVlc3RDbGFzcyl9KTtyZXR1cm4gdH1mdW5jdGlvbiBNdChlKXtZKGUsZnVuY3Rpb24oZSl7dmFyIHQ9SyhlKTt0LnJlcXVlc3RDb3VudD0odC5yZXF1ZXN0Q291bnR8fDApLTE7aWYodC5yZXF1ZXN0Q291bnQ9PT0wKXtlLmNsYXNzTGlzdFtcInJlbW92ZVwiXS5jYWxsKGUuY2xhc3NMaXN0LHouY29uZmlnLnJlcXVlc3RDbGFzcyl9fSl9ZnVuY3Rpb24gUHQoZSx0KXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49ZVtyXTtpZihuLmlzU2FtZU5vZGUodCkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gRHQoZSl7aWYoZS5uYW1lPT09XCJcInx8ZS5uYW1lPT1udWxsfHxlLmRpc2FibGVkKXtyZXR1cm4gZmFsc2V9aWYoZS50eXBlPT09XCJidXR0b25cInx8ZS50eXBlPT09XCJzdWJtaXRcInx8ZS50YWdOYW1lPT09XCJpbWFnZVwifHxlLnRhZ05hbWU9PT1cInJlc2V0XCJ8fGUudGFnTmFtZT09PVwiZmlsZVwiKXtyZXR1cm4gZmFsc2V9aWYoZS50eXBlPT09XCJjaGVja2JveFwifHxlLnR5cGU9PT1cInJhZGlvXCIpe3JldHVybiBlLmNoZWNrZWR9cmV0dXJuIHRydWV9ZnVuY3Rpb24gWHQodCxyLG4sZSxpKXtpZihlPT1udWxsfHxQdCh0LGUpKXtyZXR1cm59ZWxzZXt0LnB1c2goZSl9aWYoRHQoZSkpe3ZhciBhPUcoZSxcIm5hbWVcIik7dmFyIG89ZS52YWx1ZTtpZihlLm11bHRpcGxlKXtvPXkoZS5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uOmNoZWNrZWRcIikpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS52YWx1ZX0pfWlmKGUuZmlsZXMpe289eShlLmZpbGVzKX1pZihhIT1udWxsJiZvIT1udWxsKXt2YXIgcz1yW2FdO2lmKHMhPT11bmRlZmluZWQpe2lmKEFycmF5LmlzQXJyYXkocykpe2lmKEFycmF5LmlzQXJyYXkobykpe3JbYV09cy5jb25jYXQobyl9ZWxzZXtzLnB1c2gobyl9fWVsc2V7aWYoQXJyYXkuaXNBcnJheShvKSl7clthXT1bc10uY29uY2F0KG8pfWVsc2V7clthXT1bcyxvXX19fWVsc2V7clthXT1vfX1pZihpKXtGdChlLG4pfX1pZihkKGUsXCJmb3JtXCIpKXt2YXIgbD1lLmVsZW1lbnRzO1kobCxmdW5jdGlvbihlKXtYdCh0LHIsbixlLGkpfSl9fWZ1bmN0aW9uIEZ0KGUsdCl7aWYoZS53aWxsVmFsaWRhdGUpe2VlKGUsXCJodG14OnZhbGlkYXRpb246dmFsaWRhdGVcIik7aWYoIWUuY2hlY2tWYWxpZGl0eSgpKXt0LnB1c2goe2VsdDplLG1lc3NhZ2U6ZS52YWxpZGF0aW9uTWVzc2FnZSx2YWxpZGl0eTplLnZhbGlkaXR5fSk7ZWUoZSxcImh0bXg6dmFsaWRhdGlvbjpmYWlsZWRcIix7bWVzc2FnZTplLnZhbGlkYXRpb25NZXNzYWdlLHZhbGlkaXR5OmUudmFsaWRpdHl9KX19fWZ1bmN0aW9uIEJ0KGUsdCl7dmFyIHI9W107dmFyIG49e307dmFyIGk9e307dmFyIGE9W107dmFyIG89SyhlKTt2YXIgcz1kKGUsXCJmb3JtXCIpJiZlLm5vVmFsaWRhdGUhPT10cnVlfHxKKGUsXCJoeC12YWxpZGF0ZVwiKT09PVwidHJ1ZVwiO2lmKG8ubGFzdEJ1dHRvbkNsaWNrZWQpe3M9cyYmby5sYXN0QnV0dG9uQ2xpY2tlZC5mb3JtTm9WYWxpZGF0ZSE9PXRydWV9aWYodCE9PVwiZ2V0XCIpe1h0KHIsaSxhLEEoZSxcImZvcm1cIikscyl9WHQocixuLGEsZSxzKTtpZihvLmxhc3RCdXR0b25DbGlja2VkKXt2YXIgbD1HKG8ubGFzdEJ1dHRvbkNsaWNrZWQsXCJuYW1lXCIpO2lmKGwpe25bbF09by5sYXN0QnV0dG9uQ2xpY2tlZC52YWx1ZX19dmFyIHU9RihlLFwiaHgtaW5jbHVkZVwiKTtZKHUsZnVuY3Rpb24oZSl7WHQocixuLGEsZSxzKTtpZighZChlLFwiZm9ybVwiKSl7WShlLnF1ZXJ5U2VsZWN0b3JBbGwoRGUpLGZ1bmN0aW9uKGUpe1h0KHIsbixhLGUscyl9KX19KTtuPW5lKG4saSk7cmV0dXJue2Vycm9yczphLHZhbHVlczpufX1mdW5jdGlvbiBqdChlLHQscil7aWYoZSE9PVwiXCIpe2UrPVwiJlwifWlmKFN0cmluZyhyKT09PVwiW29iamVjdCBPYmplY3RdXCIpe3I9SlNPTi5zdHJpbmdpZnkocil9dmFyIG49ZW5jb2RlVVJJQ29tcG9uZW50KHIpO2UrPWVuY29kZVVSSUNvbXBvbmVudCh0KStcIj1cIituO3JldHVybiBlfWZ1bmN0aW9uIFV0KGUpe3ZhciB0PVwiXCI7Zm9yKHZhciByIGluIGUpe2lmKGUuaGFzT3duUHJvcGVydHkocikpe3ZhciBuPWVbcl07aWYoQXJyYXkuaXNBcnJheShuKSl7WShuLGZ1bmN0aW9uKGUpe3Q9anQodCxyLGUpfSl9ZWxzZXt0PWp0KHQscixuKX19fXJldHVybiB0fWZ1bmN0aW9uIFZ0KGUpe3ZhciB0PW5ldyBGb3JtRGF0YTtmb3IodmFyIHIgaW4gZSl7aWYoZS5oYXNPd25Qcm9wZXJ0eShyKSl7dmFyIG49ZVtyXTtpZihBcnJheS5pc0FycmF5KG4pKXtZKG4sZnVuY3Rpb24oZSl7dC5hcHBlbmQocixlKX0pfWVsc2V7dC5hcHBlbmQocixuKX19fXJldHVybiB0fWZ1bmN0aW9uIF90KGUsdCxyKXt2YXIgbj17XCJIWC1SZXF1ZXN0XCI6XCJ0cnVlXCIsXCJIWC1UcmlnZ2VyXCI6RyhlLFwiaWRcIiksXCJIWC1UcmlnZ2VyLU5hbWVcIjpHKGUsXCJuYW1lXCIpLFwiSFgtVGFyZ2V0XCI6Sih0LFwiaWRcIiksXCJIWC1DdXJyZW50LVVSTFwiOiQoKS5sb2NhdGlvbi5ocmVmfTtZdChlLFwiaHgtaGVhZGVyc1wiLGZhbHNlLG4pO2lmKHIhPT11bmRlZmluZWQpe25bXCJIWC1Qcm9tcHRcIl09cn1pZihLKGUpLmJvb3N0ZWQpe25bXCJIWC1Cb29zdGVkXCJdPVwidHJ1ZVwifXJldHVybiBufWZ1bmN0aW9uIFd0KHQsZSl7dmFyIHI9WihlLFwiaHgtcGFyYW1zXCIpO2lmKHIpe2lmKHI9PT1cIm5vbmVcIil7cmV0dXJue319ZWxzZSBpZihyPT09XCIqXCIpe3JldHVybiB0fWVsc2UgaWYoci5pbmRleE9mKFwibm90IFwiKT09PTApe1koci5zdWJzdHIoNCkuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGUpe2U9ZS50cmltKCk7ZGVsZXRlIHRbZV19KTtyZXR1cm4gdH1lbHNle3ZhciBuPXt9O1koci5zcGxpdChcIixcIiksZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtuW2VdPXRbZV19KTtyZXR1cm4gbn19ZWxzZXtyZXR1cm4gdH19ZnVuY3Rpb24genQoZSl7cmV0dXJuIEcoZSxcImhyZWZcIikmJkcoZSxcImhyZWZcIikuaW5kZXhPZihcIiNcIik+PTB9ZnVuY3Rpb24gR3QoZSx0KXt2YXIgcj10P3Q6WihlLFwiaHgtc3dhcFwiKTt2YXIgbj17c3dhcFN0eWxlOksoZSkuYm9vc3RlZD9cImlubmVySFRNTFwiOnouY29uZmlnLmRlZmF1bHRTd2FwU3R5bGUsc3dhcERlbGF5OnouY29uZmlnLmRlZmF1bHRTd2FwRGVsYXksc2V0dGxlRGVsYXk6ei5jb25maWcuZGVmYXVsdFNldHRsZURlbGF5fTtpZihLKGUpLmJvb3N0ZWQmJiF6dChlKSl7bltcInNob3dcIl09XCJ0b3BcIn1pZihyKXt2YXIgaT1iKHIpO2lmKGkubGVuZ3RoPjApe25bXCJzd2FwU3R5bGVcIl09aVswXTtmb3IodmFyIGE9MTthPGkubGVuZ3RoO2ErKyl7dmFyIG89aVthXTtpZihvLmluZGV4T2YoXCJzd2FwOlwiKT09PTApe25bXCJzd2FwRGVsYXlcIl09dihvLnN1YnN0cig1KSl9aWYoby5pbmRleE9mKFwic2V0dGxlOlwiKT09PTApe25bXCJzZXR0bGVEZWxheVwiXT12KG8uc3Vic3RyKDcpKX1pZihvLmluZGV4T2YoXCJzY3JvbGw6XCIpPT09MCl7dmFyIHM9by5zdWJzdHIoNyk7dmFyIGw9cy5zcGxpdChcIjpcIik7dmFyIGY9bC5wb3AoKTt2YXIgdT1sLmxlbmd0aD4wP2wuam9pbihcIjpcIik6bnVsbDtuW1wic2Nyb2xsXCJdPWY7bltcInNjcm9sbFRhcmdldFwiXT11fWlmKG8uaW5kZXhPZihcInNob3c6XCIpPT09MCl7dmFyIGM9by5zdWJzdHIoNSk7dmFyIGw9Yy5zcGxpdChcIjpcIik7dmFyIGg9bC5wb3AoKTt2YXIgdT1sLmxlbmd0aD4wP2wuam9pbihcIjpcIik6bnVsbDtuW1wic2hvd1wiXT1oO25bXCJzaG93VGFyZ2V0XCJdPXV9aWYoby5pbmRleE9mKFwiZm9jdXMtc2Nyb2xsOlwiKT09PTApe3ZhciBkPW8uc3Vic3RyKFwiZm9jdXMtc2Nyb2xsOlwiLmxlbmd0aCk7bltcImZvY3VzU2Nyb2xsXCJdPWQ9PVwidHJ1ZVwifX19fXJldHVybiBufWZ1bmN0aW9uIEp0KGUpe3JldHVybiBaKGUsXCJoeC1lbmNvZGluZ1wiKT09PVwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwifHxkKGUsXCJmb3JtXCIpJiZHKGUsXCJlbmN0eXBlXCIpPT09XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJ9ZnVuY3Rpb24gJHQodCxyLG4pe3ZhciBpPW51bGw7d3QocixmdW5jdGlvbihlKXtpZihpPT1udWxsKXtpPWUuZW5jb2RlUGFyYW1ldGVycyh0LG4scil9fSk7aWYoaSE9bnVsbCl7cmV0dXJuIGl9ZWxzZXtpZihKdChyKSl7cmV0dXJuIFZ0KG4pfWVsc2V7cmV0dXJuIFV0KG4pfX19ZnVuY3Rpb24gWnQoZSl7cmV0dXJue3Rhc2tzOltdLGVsdHM6W2VdfX1mdW5jdGlvbiBLdChlLHQpe3ZhciByPWVbMF07dmFyIG49ZVtlLmxlbmd0aC0xXTtpZih0LnNjcm9sbCl7dmFyIGk9bnVsbDtpZih0LnNjcm9sbFRhcmdldCl7aT1pZShyLHQuc2Nyb2xsVGFyZ2V0KX1pZih0LnNjcm9sbD09PVwidG9wXCImJihyfHxpKSl7aT1pfHxyO2kuc2Nyb2xsVG9wPTB9aWYodC5zY3JvbGw9PT1cImJvdHRvbVwiJiYobnx8aSkpe2k9aXx8bjtpLnNjcm9sbFRvcD1pLnNjcm9sbEhlaWdodH19aWYodC5zaG93KXt2YXIgaT1udWxsO2lmKHQuc2hvd1RhcmdldCl7dmFyIGE9dC5zaG93VGFyZ2V0O2lmKHQuc2hvd1RhcmdldD09PVwid2luZG93XCIpe2E9XCJib2R5XCJ9aT1pZShyLGEpfWlmKHQuc2hvdz09PVwidG9wXCImJihyfHxpKSl7aT1pfHxyO2kuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOlwic3RhcnRcIixiZWhhdmlvcjp6LmNvbmZpZy5zY3JvbGxCZWhhdmlvcn0pfWlmKHQuc2hvdz09PVwiYm90dG9tXCImJihufHxpKSl7aT1pfHxuO2kuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOlwiZW5kXCIsYmVoYXZpb3I6ei5jb25maWcuc2Nyb2xsQmVoYXZpb3J9KX19fWZ1bmN0aW9uIFl0KGUsdCxyLG4pe2lmKG49PW51bGwpe249e319aWYoZT09bnVsbCl7cmV0dXJuIG59dmFyIGk9SihlLHQpO2lmKGkpe3ZhciBhPWkudHJpbSgpO3ZhciBvPXI7aWYoYT09PVwidW5zZXRcIil7cmV0dXJuIG51bGx9aWYoYS5pbmRleE9mKFwiamF2YXNjcmlwdDpcIik9PT0wKXthPWEuc3Vic3RyKDExKTtvPXRydWV9ZWxzZSBpZihhLmluZGV4T2YoXCJqczpcIik9PT0wKXthPWEuc3Vic3RyKDMpO289dHJ1ZX1pZihhLmluZGV4T2YoXCJ7XCIpIT09MCl7YT1cIntcIithK1wifVwifXZhciBzO2lmKG8pe3M9UXQoZSxmdW5jdGlvbigpe3JldHVybiBGdW5jdGlvbihcInJldHVybiAoXCIrYStcIilcIikoKX0se30pfWVsc2V7cz13KGEpfWZvcih2YXIgbCBpbiBzKXtpZihzLmhhc093blByb3BlcnR5KGwpKXtpZihuW2xdPT1udWxsKXtuW2xdPXNbbF19fX19cmV0dXJuIFl0KHUoZSksdCxyLG4pfWZ1bmN0aW9uIFF0KGUsdCxyKXtpZih6LmNvbmZpZy5hbGxvd0V2YWwpe3JldHVybiB0KCl9ZWxzZXtRKGUsXCJodG14OmV2YWxEaXNhbGxvd2VkRXJyb3JcIik7cmV0dXJuIHJ9fWZ1bmN0aW9uIGVyKGUsdCl7cmV0dXJuIFl0KGUsXCJoeC12YXJzXCIsdHJ1ZSx0KX1mdW5jdGlvbiB0cihlLHQpe3JldHVybiBZdChlLFwiaHgtdmFsc1wiLGZhbHNlLHQpfWZ1bmN0aW9uIHJyKGUpe3JldHVybiBuZShlcihlKSx0cihlKSl9ZnVuY3Rpb24gbnIodCxyLG4pe2lmKG4hPT1udWxsKXt0cnl7dC5zZXRSZXF1ZXN0SGVhZGVyKHIsbil9Y2F0Y2goZSl7dC5zZXRSZXF1ZXN0SGVhZGVyKHIsZW5jb2RlVVJJQ29tcG9uZW50KG4pKTt0LnNldFJlcXVlc3RIZWFkZXIocitcIi1VUkktQXV0b0VuY29kZWRcIixcInRydWVcIil9fX1mdW5jdGlvbiBpcih0KXtpZih0LnJlc3BvbnNlVVJMJiZ0eXBlb2YgVVJMIT09XCJ1bmRlZmluZWRcIil7dHJ5e3ZhciBlPW5ldyBVUkwodC5yZXNwb25zZVVSTCk7cmV0dXJuIGUucGF0aG5hbWUrZS5zZWFyY2h9Y2F0Y2goZSl7USgkKCkuYm9keSxcImh0bXg6YmFkUmVzcG9uc2VVcmxcIix7dXJsOnQucmVzcG9uc2VVUkx9KX19fWZ1bmN0aW9uIGFyKGUsdCl7cmV0dXJuIGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkubWF0Y2godCl9ZnVuY3Rpb24gb3IoZSx0LHIpe2U9ZS50b0xvd2VyQ2FzZSgpO2lmKHIpe2lmKHIgaW5zdGFuY2VvZiBFbGVtZW50fHxnKHIsXCJTdHJpbmdcIikpe3JldHVybiBscihlLHQsbnVsbCxudWxsLHt0YXJnZXRPdmVycmlkZTpNKHIpLHJldHVyblByb21pc2U6dHJ1ZX0pfWVsc2V7cmV0dXJuIGxyKGUsdCxNKHIuc291cmNlKSxyLmV2ZW50LHtoYW5kbGVyOnIuaGFuZGxlcixoZWFkZXJzOnIuaGVhZGVycyx2YWx1ZXM6ci52YWx1ZXMsdGFyZ2V0T3ZlcnJpZGU6TShyLnRhcmdldCksc3dhcE92ZXJyaWRlOnIuc3dhcCxyZXR1cm5Qcm9taXNlOnRydWV9KX19ZWxzZXtyZXR1cm4gbHIoZSx0LG51bGwsbnVsbCx7cmV0dXJuUHJvbWlzZTp0cnVlfSl9fWZ1bmN0aW9uIHNyKGUpe3ZhciB0PVtdO3doaWxlKGUpe3QucHVzaChlKTtlPWUucGFyZW50RWxlbWVudH1yZXR1cm4gdH1mdW5jdGlvbiBscihlLHQsbixyLGksZil7dmFyIGM9bnVsbDt2YXIgaD1udWxsO2k9aSE9bnVsbD9pOnt9O2lmKGkucmV0dXJuUHJvbWlzZSYmdHlwZW9mIFByb21pc2UhPT1cInVuZGVmaW5lZFwiKXt2YXIgZD1uZXcgUHJvbWlzZShmdW5jdGlvbihlLHQpe2M9ZTtoPXR9KX1pZihuPT1udWxsKXtuPSQoKS5ib2R5fXZhciB2PWkuaGFuZGxlcnx8ZnI7aWYoIXJlKG4pKXtyZXR1cm59dmFyIGc9aS50YXJnZXRPdmVycmlkZXx8c2Uobik7aWYoZz09bnVsbHx8Zz09YWUpe1EobixcImh0bXg6dGFyZ2V0RXJyb3JcIix7dGFyZ2V0OkoobixcImh4LXRhcmdldFwiKX0pO3JldHVybn1pZighZil7dmFyIHA9ZnVuY3Rpb24oKXtyZXR1cm4gbHIoZSx0LG4scixpLHRydWUpfTt2YXIgbT17dGFyZ2V0OmcsZWx0Om4scGF0aDp0LHZlcmI6ZSx0cmlnZ2VyaW5nRXZlbnQ6cixldGM6aSxpc3N1ZVJlcXVlc3Q6cH07aWYoZWUobixcImh0bXg6Y29uZmlybVwiLG0pPT09ZmFsc2Upe3JldHVybn19dmFyIHk9bjt2YXIgYT1LKG4pO3ZhciB4PVoobixcImh4LXN5bmNcIik7dmFyIGI9bnVsbDt2YXIgdz1mYWxzZTtpZih4KXt2YXIgUz14LnNwbGl0KFwiOlwiKTt2YXIgRT1TWzBdLnRyaW0oKTtpZihFPT09XCJ0aGlzXCIpe3k9b2UobixcImh4LXN5bmNcIil9ZWxzZXt5PWllKG4sRSl9eD0oU1sxXXx8XCJkcm9wXCIpLnRyaW0oKTthPUsoeSk7aWYoeD09PVwiZHJvcFwiJiZhLnhociYmYS5hYm9ydGFibGUhPT10cnVlKXtyZXR1cm59ZWxzZSBpZih4PT09XCJhYm9ydFwiKXtpZihhLnhocil7cmV0dXJufWVsc2V7dz10cnVlfX1lbHNlIGlmKHg9PT1cInJlcGxhY2VcIil7ZWUoeSxcImh0bXg6YWJvcnRcIil9ZWxzZSBpZih4LmluZGV4T2YoXCJxdWV1ZVwiKT09PTApe3ZhciBDPXguc3BsaXQoXCIgXCIpO2I9KENbMV18fFwibGFzdFwiKS50cmltKCl9fWlmKGEueGhyKXtpZihhLmFib3J0YWJsZSl7ZWUoeSxcImh0bXg6YWJvcnRcIil9ZWxzZXtpZihiPT1udWxsKXtpZihyKXt2YXIgUj1LKHIpO2lmKFImJlIudHJpZ2dlclNwZWMmJlIudHJpZ2dlclNwZWMucXVldWUpe2I9Ui50cmlnZ2VyU3BlYy5xdWV1ZX19aWYoYj09bnVsbCl7Yj1cImxhc3RcIn19aWYoYS5xdWV1ZWRSZXF1ZXN0cz09bnVsbCl7YS5xdWV1ZWRSZXF1ZXN0cz1bXX1pZihiPT09XCJmaXJzdFwiJiZhLnF1ZXVlZFJlcXVlc3RzLmxlbmd0aD09PTApe2EucXVldWVkUmVxdWVzdHMucHVzaChmdW5jdGlvbigpe2xyKGUsdCxuLHIsaSl9KX1lbHNlIGlmKGI9PT1cImFsbFwiKXthLnF1ZXVlZFJlcXVlc3RzLnB1c2goZnVuY3Rpb24oKXtscihlLHQsbixyLGkpfSl9ZWxzZSBpZihiPT09XCJsYXN0XCIpe2EucXVldWVkUmVxdWVzdHM9W107YS5xdWV1ZWRSZXF1ZXN0cy5wdXNoKGZ1bmN0aW9uKCl7bHIoZSx0LG4scixpKX0pfXJldHVybn19dmFyIG89bmV3IFhNTEh0dHBSZXF1ZXN0O2EueGhyPW87YS5hYm9ydGFibGU9dzt2YXIgcz1mdW5jdGlvbigpe2EueGhyPW51bGw7YS5hYm9ydGFibGU9ZmFsc2U7aWYoYS5xdWV1ZWRSZXF1ZXN0cyE9bnVsbCYmYS5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGg+MCl7dmFyIGU9YS5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO2UoKX19O3ZhciBPPVoobixcImh4LXByb21wdFwiKTtpZihPKXt2YXIgcT1wcm9tcHQoTyk7aWYocT09PW51bGx8fCFlZShuLFwiaHRteDpwcm9tcHRcIix7cHJvbXB0OnEsdGFyZ2V0Omd9KSl7dGUoYyk7cygpO3JldHVybiBkfX12YXIgVD1aKG4sXCJoeC1jb25maXJtXCIpO2lmKFQpe2lmKCFjb25maXJtKFQpKXt0ZShjKTtzKCk7cmV0dXJuIGR9fXZhciBMPV90KG4sZyxxKTtpZihpLmhlYWRlcnMpe0w9bmUoTCxpLmhlYWRlcnMpfXZhciBIPUJ0KG4sZSk7dmFyIEE9SC5lcnJvcnM7dmFyIE49SC52YWx1ZXM7aWYoaS52YWx1ZXMpe049bmUoTixpLnZhbHVlcyl9dmFyIEk9cnIobik7dmFyIGs9bmUoTixJKTt2YXIgTT1XdChrLG4pO2lmKGUhPT1cImdldFwiJiYhSnQobikpe0xbXCJDb250ZW50LVR5cGVcIl09XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn1pZih6LmNvbmZpZy5nZXRDYWNoZUJ1c3RlclBhcmFtJiZlPT09XCJnZXRcIil7TVtcIm9yZy5odG14LmNhY2hlLWJ1c3RlclwiXT1HKGcsXCJpZFwiKXx8XCJ0cnVlXCJ9aWYodD09bnVsbHx8dD09PVwiXCIpe3Q9JCgpLmxvY2F0aW9uLmhyZWZ9dmFyIFA9WXQobixcImh4LXJlcXVlc3RcIik7dmFyIEQ9SyhuKS5ib29zdGVkO3ZhciBsPXtib29zdGVkOkQscGFyYW1ldGVyczpNLHVuZmlsdGVyZWRQYXJhbWV0ZXJzOmssaGVhZGVyczpMLHRhcmdldDpnLHZlcmI6ZSxlcnJvcnM6QSx3aXRoQ3JlZGVudGlhbHM6aS5jcmVkZW50aWFsc3x8UC5jcmVkZW50aWFsc3x8ei5jb25maWcud2l0aENyZWRlbnRpYWxzLHRpbWVvdXQ6aS50aW1lb3V0fHxQLnRpbWVvdXR8fHouY29uZmlnLnRpbWVvdXQscGF0aDp0LHRyaWdnZXJpbmdFdmVudDpyfTtpZighZWUobixcImh0bXg6Y29uZmlnUmVxdWVzdFwiLGwpKXt0ZShjKTtzKCk7cmV0dXJuIGR9dD1sLnBhdGg7ZT1sLnZlcmI7TD1sLmhlYWRlcnM7TT1sLnBhcmFtZXRlcnM7QT1sLmVycm9ycztpZihBJiZBLmxlbmd0aD4wKXtlZShuLFwiaHRteDp2YWxpZGF0aW9uOmhhbHRlZFwiLGwpO3RlKGMpO3MoKTtyZXR1cm4gZH12YXIgWD10LnNwbGl0KFwiI1wiKTt2YXIgRj1YWzBdO3ZhciBCPVhbMV07dmFyIGo9bnVsbDtpZihlPT09XCJnZXRcIil7aj1GO3ZhciBVPU9iamVjdC5rZXlzKE0pLmxlbmd0aCE9PTA7aWYoVSl7aWYoai5pbmRleE9mKFwiP1wiKTwwKXtqKz1cIj9cIn1lbHNle2orPVwiJlwifWorPVV0KE0pO2lmKEIpe2orPVwiI1wiK0J9fW8ub3BlbihcIkdFVFwiLGosdHJ1ZSl9ZWxzZXtvLm9wZW4oZS50b1VwcGVyQ2FzZSgpLHQsdHJ1ZSl9by5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9odG1sXCIpO28ud2l0aENyZWRlbnRpYWxzPWwud2l0aENyZWRlbnRpYWxzO28udGltZW91dD1sLnRpbWVvdXQ7aWYoUC5ub0hlYWRlcnMpe31lbHNle2Zvcih2YXIgViBpbiBMKXtpZihMLmhhc093blByb3BlcnR5KFYpKXt2YXIgXz1MW1ZdO25yKG8sVixfKX19fXZhciB1PXt4aHI6byx0YXJnZXQ6ZyxyZXF1ZXN0Q29uZmlnOmwsZXRjOmksYm9vc3RlZDpELHBhdGhJbmZvOntyZXF1ZXN0UGF0aDp0LGZpbmFsUmVxdWVzdFBhdGg6anx8dCxhbmNob3I6Qn19O28ub25sb2FkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXNyKG4pO3UucGF0aEluZm8ucmVzcG9uc2VQYXRoPWlyKG8pO3Yobix1KTtNdChXKTtlZShuLFwiaHRteDphZnRlclJlcXVlc3RcIix1KTtlZShuLFwiaHRteDphZnRlck9uTG9hZFwiLHUpO2lmKCFyZShuKSl7dmFyIHQ9bnVsbDt3aGlsZShlLmxlbmd0aD4wJiZ0PT1udWxsKXt2YXIgcj1lLnNoaWZ0KCk7aWYocmUocikpe3Q9cn19aWYodCl7ZWUodCxcImh0bXg6YWZ0ZXJSZXF1ZXN0XCIsdSk7ZWUodCxcImh0bXg6YWZ0ZXJPbkxvYWRcIix1KX19dGUoYyk7cygpfWNhdGNoKGUpe1EobixcImh0bXg6b25Mb2FkRXJyb3JcIixuZSh7ZXJyb3I6ZX0sdSkpO3Rocm93IGV9fTtvLm9uZXJyb3I9ZnVuY3Rpb24oKXtNdChXKTtRKG4sXCJodG14OmFmdGVyUmVxdWVzdFwiLHUpO1EobixcImh0bXg6c2VuZEVycm9yXCIsdSk7dGUoaCk7cygpfTtvLm9uYWJvcnQ9ZnVuY3Rpb24oKXtNdChXKTtRKG4sXCJodG14OmFmdGVyUmVxdWVzdFwiLHUpO1EobixcImh0bXg6c2VuZEFib3J0XCIsdSk7dGUoaCk7cygpfTtvLm9udGltZW91dD1mdW5jdGlvbigpe010KFcpO1EobixcImh0bXg6YWZ0ZXJSZXF1ZXN0XCIsdSk7UShuLFwiaHRteDp0aW1lb3V0XCIsdSk7dGUoaCk7cygpfTtpZighZWUobixcImh0bXg6YmVmb3JlUmVxdWVzdFwiLHUpKXt0ZShjKTtzKCk7cmV0dXJuIGR9dmFyIFc9a3Qobik7WShbXCJsb2Fkc3RhcnRcIixcImxvYWRlbmRcIixcInByb2dyZXNzXCIsXCJhYm9ydFwiXSxmdW5jdGlvbih0KXtZKFtvLG8udXBsb2FkXSxmdW5jdGlvbihlKXtlLmFkZEV2ZW50TGlzdGVuZXIodCxmdW5jdGlvbihlKXtlZShuLFwiaHRteDp4aHI6XCIrdCx7bGVuZ3RoQ29tcHV0YWJsZTplLmxlbmd0aENvbXB1dGFibGUsbG9hZGVkOmUubG9hZGVkLHRvdGFsOmUudG90YWx9KX0pfSl9KTtlZShuLFwiaHRteDpiZWZvcmVTZW5kXCIsdSk7by5zZW5kKGU9PT1cImdldFwiP251bGw6JHQobyxuLE0pKTtyZXR1cm4gZH1mdW5jdGlvbiB1cihlLHQpe3ZhciByPXQueGhyO3ZhciBuPW51bGw7dmFyIGk9bnVsbDtpZihhcihyLC9IWC1QdXNoOi9pKSl7bj1yLmdldFJlc3BvbnNlSGVhZGVyKFwiSFgtUHVzaFwiKTtpPVwicHVzaFwifWVsc2UgaWYoYXIociwvSFgtUHVzaC1Vcmw6L2kpKXtuPXIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJIWC1QdXNoLVVybFwiKTtpPVwicHVzaFwifWVsc2UgaWYoYXIociwvSFgtUmVwbGFjZS1Vcmw6L2kpKXtuPXIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJIWC1SZXBsYWNlLVVybFwiKTtpPVwicmVwbGFjZVwifWlmKG4pe2lmKG49PT1cImZhbHNlXCIpe3JldHVybnt9fWVsc2V7cmV0dXJue3R5cGU6aSxwYXRoOm59fX12YXIgYT10LnBhdGhJbmZvLmZpbmFsUmVxdWVzdFBhdGg7dmFyIG89dC5wYXRoSW5mby5yZXNwb25zZVBhdGg7dmFyIHM9WihlLFwiaHgtcHVzaC11cmxcIik7dmFyIGY9WihlLFwiaHgtcmVwbGFjZS11cmxcIik7dmFyIGM9SyhlKS5ib29zdGVkO3ZhciBsPW51bGw7dmFyIHU9bnVsbDtpZihzKXtsPVwicHVzaFwiO3U9c31lbHNlIGlmKGYpe2w9XCJyZXBsYWNlXCI7dT1mfWVsc2UgaWYoYyl7bD1cInB1c2hcIjt1PW98fGF9aWYodSl7aWYodT09PVwiZmFsc2VcIil7cmV0dXJue319aWYodT09PVwidHJ1ZVwiKXt1PW98fGF9aWYodC5wYXRoSW5mby5hbmNob3ImJnUuaW5kZXhPZihcIiNcIik9PT0tMSl7dT11K1wiI1wiK3QucGF0aEluZm8uYW5jaG9yfXJldHVybnt0eXBlOmwscGF0aDp1fX1lbHNle3JldHVybnt9fX1mdW5jdGlvbiBmcihzLGwpe3ZhciB1PWwueGhyO3ZhciBmPWwudGFyZ2V0O3ZhciBuPWwuZXRjO2lmKCFlZShzLFwiaHRteDpiZWZvcmVPbkxvYWRcIixsKSlyZXR1cm47aWYoYXIodSwvSFgtVHJpZ2dlcjovaSkpe3FlKHUsXCJIWC1UcmlnZ2VyXCIscyl9aWYoYXIodSwvSFgtTG9jYXRpb246L2kpKXtUdCgpO3ZhciBlPXUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJIWC1Mb2NhdGlvblwiKTt2YXIgYztpZihlLmluZGV4T2YoXCJ7XCIpPT09MCl7Yz13KGUpO2U9Y1tcInBhdGhcIl07ZGVsZXRlIGNbXCJwYXRoXCJdfW9yKFwiR0VUXCIsZSxjKS50aGVuKGZ1bmN0aW9uKCl7THQoZSl9KTtyZXR1cm59aWYoYXIodSwvSFgtUmVkaXJlY3Q6L2kpKXtsb2NhdGlvbi5ocmVmPXUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJIWC1SZWRpcmVjdFwiKTtyZXR1cm59aWYoYXIodSwvSFgtUmVmcmVzaDovaSkpe2lmKFwidHJ1ZVwiPT09dS5nZXRSZXNwb25zZUhlYWRlcihcIkhYLVJlZnJlc2hcIikpe2xvY2F0aW9uLnJlbG9hZCgpO3JldHVybn19aWYoYXIodSwvSFgtUmV0YXJnZXQ6L2kpKXtsLnRhcmdldD0kKCkucXVlcnlTZWxlY3Rvcih1LmdldFJlc3BvbnNlSGVhZGVyKFwiSFgtUmV0YXJnZXRcIikpfXZhciBoPXVyKHMsbCk7dmFyIGk9dS5zdGF0dXM+PTIwMCYmdS5zdGF0dXM8NDAwJiZ1LnN0YXR1cyE9PTIwNDt2YXIgZD11LnJlc3BvbnNlO3ZhciB0PXUuc3RhdHVzPj00MDA7dmFyIHI9bmUoe3Nob3VsZFN3YXA6aSxzZXJ2ZXJSZXNwb25zZTpkLGlzRXJyb3I6dH0sbCk7aWYoIWVlKGYsXCJodG14OmJlZm9yZVN3YXBcIixyKSlyZXR1cm47Zj1yLnRhcmdldDtkPXIuc2VydmVyUmVzcG9uc2U7dD1yLmlzRXJyb3I7bC5mYWlsZWQ9dDtsLnN1Y2Nlc3NmdWw9IXQ7aWYoci5zaG91bGRTd2FwKXtpZih1LnN0YXR1cz09PTI4Nil7RmUocyl9d3QocyxmdW5jdGlvbihlKXtkPWUudHJhbnNmb3JtUmVzcG9uc2UoZCx1LHMpfSk7aWYoaC50eXBlKXtUdCgpfXZhciBhPW4uc3dhcE92ZXJyaWRlO2lmKGFyKHUsL0hYLVJlc3dhcDovaSkpe2E9dS5nZXRSZXNwb25zZUhlYWRlcihcIkhYLVJlc3dhcFwiKX12YXIgYz1HdChzLGEpO2YuY2xhc3NMaXN0LmFkZCh6LmNvbmZpZy5zd2FwcGluZ0NsYXNzKTt2YXIgbz1mdW5jdGlvbigpe3RyeXt2YXIgZT1kb2N1bWVudC5hY3RpdmVFbGVtZW50O3ZhciB0PXt9O3RyeXt0PXtlbHQ6ZSxzdGFydDplP2Uuc2VsZWN0aW9uU3RhcnQ6bnVsbCxlbmQ6ZT9lLnNlbGVjdGlvbkVuZDpudWxsfX1jYXRjaChlKXt9dmFyIG49WnQoZik7T2UoYy5zd2FwU3R5bGUsZixzLGQsbik7aWYodC5lbHQmJiFyZSh0LmVsdCkmJnQuZWx0LmlkKXt2YXIgcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0LmVsdC5pZCk7dmFyIGk9e3ByZXZlbnRTY3JvbGw6Yy5mb2N1c1Njcm9sbCE9PXVuZGVmaW5lZD8hYy5mb2N1c1Njcm9sbDohei5jb25maWcuZGVmYXVsdEZvY3VzU2Nyb2xsfTtpZihyKXtpZih0LnN0YXJ0JiZyLnNldFNlbGVjdGlvblJhbmdlKXt0cnl7ci5zZXRTZWxlY3Rpb25SYW5nZSh0LnN0YXJ0LHQuZW5kKX1jYXRjaChlKXt9fXIuZm9jdXMoaSl9fWYuY2xhc3NMaXN0LnJlbW92ZSh6LmNvbmZpZy5zd2FwcGluZ0NsYXNzKTtZKG4uZWx0cyxmdW5jdGlvbihlKXtpZihlLmNsYXNzTGlzdCl7ZS5jbGFzc0xpc3QuYWRkKHouY29uZmlnLnNldHRsaW5nQ2xhc3MpfWVlKGUsXCJodG14OmFmdGVyU3dhcFwiLGwpfSk7aWYoYXIodSwvSFgtVHJpZ2dlci1BZnRlci1Td2FwOi9pKSl7dmFyIGE9cztpZighcmUocykpe2E9JCgpLmJvZHl9cWUodSxcIkhYLVRyaWdnZXItQWZ0ZXItU3dhcFwiLGEpfXZhciBvPWZ1bmN0aW9uKCl7WShuLnRhc2tzLGZ1bmN0aW9uKGUpe2UuY2FsbCgpfSk7WShuLmVsdHMsZnVuY3Rpb24oZSl7aWYoZS5jbGFzc0xpc3Qpe2UuY2xhc3NMaXN0LnJlbW92ZSh6LmNvbmZpZy5zZXR0bGluZ0NsYXNzKX1lZShlLFwiaHRteDphZnRlclNldHRsZVwiLGwpfSk7aWYoaC50eXBlKXtpZihoLnR5cGU9PT1cInB1c2hcIil7THQoaC5wYXRoKTtlZSgkKCkuYm9keSxcImh0bXg6cHVzaGVkSW50b0hpc3RvcnlcIix7cGF0aDpoLnBhdGh9KX1lbHNle0h0KGgucGF0aCk7ZWUoJCgpLmJvZHksXCJodG14OnJlcGxhY2VkSW5IaXN0b3J5XCIse3BhdGg6aC5wYXRofSl9fWlmKGwucGF0aEluZm8uYW5jaG9yKXt2YXIgZT1DKFwiI1wiK2wucGF0aEluZm8uYW5jaG9yKTtpZihlKXtlLnNjcm9sbEludG9WaWV3KHtibG9jazpcInN0YXJ0XCIsYmVoYXZpb3I6XCJhdXRvXCJ9KX19aWYobi50aXRsZSl7dmFyIHQ9QyhcInRpdGxlXCIpO2lmKHQpe3QuaW5uZXJIVE1MPW4udGl0bGV9ZWxzZXt3aW5kb3cuZG9jdW1lbnQudGl0bGU9bi50aXRsZX19S3Qobi5lbHRzLGMpO2lmKGFyKHUsL0hYLVRyaWdnZXItQWZ0ZXItU2V0dGxlOi9pKSl7dmFyIHI9cztpZighcmUocykpe3I9JCgpLmJvZHl9cWUodSxcIkhYLVRyaWdnZXItQWZ0ZXItU2V0dGxlXCIscil9fTtpZihjLnNldHRsZURlbGF5PjApe3NldFRpbWVvdXQobyxjLnNldHRsZURlbGF5KX1lbHNle28oKX19Y2F0Y2goZSl7UShzLFwiaHRteDpzd2FwRXJyb3JcIixsKTt0aHJvdyBlfX07aWYoYy5zd2FwRGVsYXk+MCl7c2V0VGltZW91dChvLGMuc3dhcERlbGF5KX1lbHNle28oKX19aWYodCl7UShzLFwiaHRteDpyZXNwb25zZUVycm9yXCIsbmUoe2Vycm9yOlwiUmVzcG9uc2UgU3RhdHVzIEVycm9yIENvZGUgXCIrdS5zdGF0dXMrXCIgZnJvbSBcIitsLnBhdGhJbmZvLnJlcXVlc3RQYXRofSxsKSl9fXZhciBjcj17fTtmdW5jdGlvbiBocigpe3JldHVybntpbml0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSxvbkV2ZW50OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRydWV9LHRyYW5zZm9ybVJlc3BvbnNlOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZX0saXNJbmxpbmVTd2FwOmZ1bmN0aW9uKGUpe3JldHVybiBmYWxzZX0saGFuZGxlU3dhcDpmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gZmFsc2V9LGVuY29kZVBhcmFtZXRlcnM6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBudWxsfX19ZnVuY3Rpb24gZHIoZSx0KXtpZih0LmluaXQpe3QuaW5pdChyKX1jcltlXT1uZShocigpLHQpfWZ1bmN0aW9uIHZyKGUpe2RlbGV0ZSBjcltlXX1mdW5jdGlvbiBncihlLHIsbil7aWYoZT09dW5kZWZpbmVkKXtyZXR1cm4gcn1pZihyPT11bmRlZmluZWQpe3I9W119aWYobj09dW5kZWZpbmVkKXtuPVtdfXZhciB0PUooZSxcImh4LWV4dFwiKTtpZih0KXtZKHQuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGUpe2U9ZS5yZXBsYWNlKC8gL2csXCJcIik7aWYoZS5zbGljZSgwLDcpPT1cImlnbm9yZTpcIil7bi5wdXNoKGUuc2xpY2UoNykpO3JldHVybn1pZihuLmluZGV4T2YoZSk8MCl7dmFyIHQ9Y3JbZV07aWYodCYmci5pbmRleE9mKHQpPDApe3IucHVzaCh0KX19fSl9cmV0dXJuIGdyKHUoZSkscixuKX1mdW5jdGlvbiBwcihlKXtpZigkKCkucmVhZHlTdGF0ZSE9PVwibG9hZGluZ1wiKXtlKCl9ZWxzZXskKCkuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixlKX19ZnVuY3Rpb24gbXIoKXtpZih6LmNvbmZpZy5pbmNsdWRlSW5kaWNhdG9yU3R5bGVzIT09ZmFsc2UpeyQoKS5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHN0eWxlPiAgICAgICAgICAgICAgICAgICAgICAuXCIrei5jb25maWcuaW5kaWNhdG9yQ2xhc3MrXCJ7b3BhY2l0eTowO3RyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbjt9ICAgICAgICAgICAgICAgICAgICAgIC5cIit6LmNvbmZpZy5yZXF1ZXN0Q2xhc3MrXCIgLlwiK3ouY29uZmlnLmluZGljYXRvckNsYXNzK1wie29wYWNpdHk6MX0gICAgICAgICAgICAgICAgICAgICAgLlwiK3ouY29uZmlnLnJlcXVlc3RDbGFzcytcIi5cIit6LmNvbmZpZy5pbmRpY2F0b3JDbGFzcytcIntvcGFjaXR5OjF9ICAgICAgICAgICAgICAgICAgICA8L3N0eWxlPlwiKX19ZnVuY3Rpb24geXIoKXt2YXIgZT0kKCkucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiaHRteC1jb25maWdcIl0nKTtpZihlKXtyZXR1cm4gdyhlLmNvbnRlbnQpfWVsc2V7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHhyKCl7dmFyIGU9eXIoKTtpZihlKXt6LmNvbmZpZz1uZSh6LmNvbmZpZyxlKX19cHIoZnVuY3Rpb24oKXt4cigpO21yKCk7dmFyIGU9JCgpLmJvZHk7bXQoZSk7dmFyIHQ9JCgpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaHgtdHJpZ2dlcj0ncmVzdG9yZWQnXSxbZGF0YS1oeC10cmlnZ2VyPSdyZXN0b3JlZCddXCIpO2UuYWRkRXZlbnRMaXN0ZW5lcihcImh0bXg6YWJvcnRcIixmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDt2YXIgcj1LKHQpO2lmKHImJnIueGhyKXtyLnhoci5hYm9ydCgpfX0pO3dpbmRvdy5vbnBvcHN0YXRlPWZ1bmN0aW9uKGUpe2lmKGUuc3RhdGUmJmUuc3RhdGUuaHRteCl7SXQoKTtZKHQsZnVuY3Rpb24oZSl7ZWUoZSxcImh0bXg6cmVzdG9yZWRcIix7ZG9jdW1lbnQ6JCgpLHRyaWdnZXJFdmVudDplZX0pfSl9fTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZWUoZSxcImh0bXg6bG9hZFwiLHt9KX0sMCl9KTtyZXR1cm4gen0oKX0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/htmx.org/dist/htmx.min.js\n");

/***/ }),

/***/ "./assets/css/app.scss":
/*!*****************************!*\
  !*** ./assets/css/app.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY3NzL2FwcC5zY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9jc3MvYXBwLnNjc3M/ZjI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/css/app.scss\n");

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popper);\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Es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Q1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7OztBQUdBLHlEQUF5RCxxQkFBTTtBQUMvRDtBQUNBOztBQUVBLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzP2VhMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNi4xXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciB0aW1lb3V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59KCk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBub2RlIG9mIHRoZSByZWZlcmVuY2Ugb2JqZWN0LCBvciB0aGUgcmVmZXJlbmNlIG9iamVjdCBpdHNlbGYuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10pICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuaGVpZ2h0O1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICB2YXIgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gIH07XG59XG5cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20gfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NUb3ApO1xuXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgfHwgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudDtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHZhciBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICB2YXIgdG9wID0gcG9wcGVyU3R5bGVzLnRvcCxcbiAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcblxuICBwb3BwZXJTdHlsZXMudG9wID0gJyc7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9ICcnO1xuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/popper.js/dist/esm/popper.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./assets/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./assets/css/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;